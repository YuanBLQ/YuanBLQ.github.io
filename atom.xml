<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanblq.github.io/"/>
  <updated>2018-03-13T08:20:52.000Z</updated>
  <id>https://yuanblq.github.io/</id>
  
  <author>
    <name>Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集中式日志系统ELK协议栈简介与入门</title>
    <link href="https://yuanblq.github.io/2018/03/13/ELK-ABC/"/>
    <id>https://yuanblq.github.io/2018/03/13/ELK-ABC/</id>
    <published>2018-03-13T08:14:25.000Z</published>
    <updated>2018-03-13T08:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集中式日志系统ELK协议栈简介与入门"><a href="#集中式日志系统ELK协议栈简介与入门" class="headerlink" title="集中式日志系统ELK协议栈简介与入门"></a>集中式日志系统ELK协议栈简介与入门</h1><p>什么是“ELK”？</p>
<p>“ELK”是三大开源软件的缩写：Elasticsearch、Logstash、Kibana。</p>
<p>Elasticsearch 负责搜索和分析，Logstash 负责从各个来源搜集、转换数据，kibana 以图表的形式在 Elasticsearch 中展示数据。</p>
<a id="more"></a>
<h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Logstash 需要 Java8 的支持，可以通过<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">官方发布版本</a>或者其他<a href="http://openjdk.java.net/" target="_blank" rel="external">开源版本</a>进行安装</p>
<p>安装完之后通过以下命令检查是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -version</div></pre></td></tr></table></figure></p>
<p>安装正常的话会出现下面类似的响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version &quot;1.8.0_65&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_65-b17)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)</div></pre></td></tr></table></figure></p>
<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>从<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">官网</a>下载符合你操作系统的安装文件。然后解压，记住不要安装在带有冒号（:）的路径中。</p>
<h3 id="仓库安装"><a href="#仓库安装" class="headerlink" title="仓库安装"></a>仓库安装</h3><p>对于一些 Linux 发布版，可以直接从其软件仓库直接安装。</p>
<h4 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h4><p>下载公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure></p>
<p>确保 <code>apt-transport-https</code> 包已经安装，没有的话先安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install apt-transport-https</div></pre></td></tr></table></figure></p>
<p>加入仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://artifacts.elastic.co/packages/6.x/apt stable main"</span> | sudo tee <span class="_">-a</span> /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure></p>
<p>最后安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install logstash</div></pre></td></tr></table></figure></p>
<h4 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h4><p>下载安装公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</div></pre></td></tr></table></figure></p>
<p>将下面的内容写入新文件 <code>/etc/yum.repos.d/logstash.repo</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[logstash-6.x]</div><div class="line">name=Elastic repository for 6.x packages</div><div class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</div><div class="line">enabled=1</div><div class="line">autorefresh=1</div><div class="line">type=rpm-md</div></pre></td></tr></table></figure></p>
<p>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install logstash</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考文档：<br><a href="https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#package-repositories" target="_blank" rel="external">https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#package-repositories</a></p>
</blockquote>
<h2 id="测试Logstash"><a href="#测试Logstash" class="headerlink" title="测试Logstash"></a>测试Logstash</h2><p>每个 Logstash 的 Pipeline 都必须这两个元素：<code>input</code> 和 <code>output</code>，以及一个可选元素：<code>filter</code>。</p>
<p>先来测试 Logstash 有没有安装成功。在命令行运行以下最基本的 Pipeline：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-e</span> <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'</span></div></pre></td></tr></table></figure></p>
<p>启动 Logstash 之后，看见 <code>The stdin plugin is now waiting for input:</code> 说明已经启动成功，然后在命令行输入 <code>hello world</code>，你会得到如下相似的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The stdin plugin is now waiting <span class="keyword">for</span> input:</div><div class="line">hello world</div><div class="line">2018-03-12T08:37:16.976Z xxxdeiMac.local hello world</div></pre></td></tr></table></figure></p>
<p>Logstash 会把时间戳和 IP 地址信息传递给 message。通过 CTRL-D 退出 Logstash。</p>
<h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><p>不同的操作系统发布版本安装过程有些许不同，具体见<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html" target="_blank" rel="external">官网</a>。下面以 Ubuntu 为例。</p>
<h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><p>同样需要 Java8 的环境</p>
<h3 id="仓库安装-1"><a href="#仓库安装-1" class="headerlink" title="仓库安装"></a>仓库安装</h3><p>导入公钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure>
<p>从APT仓库安装</p>
<p>如果没有安装过 <code>apt-transport-https</code> 包，同样要先安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install apt-transport-https</div></pre></td></tr></table></figure></p>
<p>加入仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://artifacts.elastic.co/packages/6.x/apt stable main"</span> | sudo tee <span class="_">-a</span> /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install elasticsearch</div></pre></td></tr></table></figure>
<h3 id="启动Elasticsearch"><a href="#启动Elasticsearch" class="headerlink" title="启动Elasticsearch"></a>启动Elasticsearch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ <span class="built_in">cd</span> elasticsearch-6.2.2</div><div class="line">➜  elasticsearch-6.2.2 bin/elasticsearch</div></pre></td></tr></table></figure>
<p>当看到如下类似的log，说明基本启动完成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2018-03-12T17:30:02,153][INFO ][o.e.n.Node] [0TDYPSN] started</div></pre></td></tr></table></figure></p>
<p>打开浏览器，进入 <code>localhost:9200</code>，看见如下内容说明已经启动了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;0TDYPSN&quot;,</div><div class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</div><div class="line">  &quot;cluster_uuid&quot; : &quot;uQ0qekKORmKT5XgH6rzWmA&quot;,</div><div class="line">  &quot;version&quot; : &#123;</div><div class="line">    &quot;number&quot; : &quot;6.2.2&quot;,</div><div class="line">    &quot;build_hash&quot; : &quot;10b1edd&quot;,</div><div class="line">    &quot;build_date&quot; : &quot;2018-02-16T19:01:30.685723Z&quot;,</div><div class="line">    &quot;build_snapshot&quot; : false,</div><div class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</div><div class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</div><div class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用-Logstash-解析-log-并输出到-Elasticsearch"><a href="#利用-Logstash-解析-log-并输出到-Elasticsearch" class="headerlink" title="利用 Logstash 解析 log 并输出到 Elasticsearch"></a>利用 Logstash 解析 log 并输出到 Elasticsearch</h2><p>上面我们创建了一个最最基本的 Logstash Pipeline 用于测试安装是否成功。在实际工作中，一个 Pipeline 都会比这复杂点：经常会有多个 <code>input</code>，<code>filter</code> 和 <code>output</code> 插件。</p>
<p>现在我们通过 Filebeat 来把实际工作中产生的日志文件发送给 Logstash。</p>
<h3 id="安装-Filebeat"><a href="#安装-Filebeat" class="headerlink" title="安装 Filebeat"></a>安装 Filebeat</h3><p>根据自己的操作系统从<a href="https://www.elastic.co/guide/en/beats/filebeat/6.2/filebeat-installation.html" target="_blank" rel="external">官网</a>匹配合适的安装方式</p>
<h3 id="配置-Filebeat"><a href="#配置-Filebeat" class="headerlink" title="配置 Filebeat"></a>配置 Filebeat</h3><p>将下面的内容覆盖到 Filebeat 文件夹下的 <code>filebeat.yml</code> 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filebeat.prospectors:</div><div class="line">- type: log</div><div class="line">  paths:</div><div class="line">    - /absolute/path/to/file/test_logs.log </div><div class="line">output.logstash:</div><div class="line">  hosts: [&quot;localhost:5044&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="配置-Logstash-来接收-Filebeat-的输入"><a href="#配置-Logstash-来接收-Filebeat-的输入" class="headerlink" title="配置 Logstash 来接收 Filebeat 的输入"></a>配置 Logstash 来接收 Filebeat 的输入</h3><p>前面我们验证 Logstash 有没有安装成功的时候，在命令行创建了一个最简单的 Pipeline（命令行接收 Events，并在命令行输出），现在我们要创建一个比较复杂的 Pipeline 来从 Beats 接收 Events。</p>
<p>当然比较复杂的 Pipeline 就不能再在命令行直接创建了，我们得先配置在文件中。</p>
<p>在 Logstash 目录下，创建 <code>first-pipeline.conf</code> 文件。</p>
<p>先把下面这个 Pipeline 的骨架搭好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 井号可以用作注释</div><div class="line">input &#123;</div><div class="line">&#125;</div><div class="line"># 还记得吗 filter 这部件适可选的</div><div class="line"># filter &#123;</div><div class="line">#</div><div class="line"># &#125;</div><div class="line">output &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>骨架就这样，当然现在还不能用，我们还得定义输入输出部分的配置。</p>
<ul>
<li><p>在 <code>input</code> 部分配置 Beat 插件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beats &#123;</div><div class="line">    port =&gt; &quot;5044&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>output</code> 部分<br>  我们先把输出配置到 stdout，之后再搞到 Elasticsearch（一步步来 ~。~）。<br>  在 <code>output</code> 块中添加如下配置：  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stdout &#123; codec =&gt; rubydebug &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面配完之后，你的 <code>first-pipeline.conf</code> 文件基本长成这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5044&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># filter &#123;</div><div class="line">#</div><div class="line"># &#125;</div><div class="line">output &#123;</div><div class="line">    stdout &#123; codec =&gt; rubydebug &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这个 Pipeline 之前，可以用下面的命令检查配置是否正确：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-f</span> first-pipeline.conf --config.test_and_exit</div></pre></td></tr></table></figure></p>
<p>如果测试通过，则会在命令行出现以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2018-03-13T10:02:29,275][INFO ][logstash.runner] Using config.test_and_exit mode. Config Validation Result: OK. Exiting Logstash</div></pre></td></tr></table></figure></p>
<p>通过测试后，通过下面的命令启动 Logstash：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-f</span> first-pipeline.conf --config.reload.automatic</div></pre></td></tr></table></figure></p>
<p><code>--config.reload.automatic</code> 能够自动重载配置，这样每次修改完配置后不用重启 Logstash 了。</p>
<h3 id="生产假数据-）"><a href="#生产假数据-）" class="headerlink" title="生产假数据 ;）"></a>生产假数据 ;）</h3><p>现在还没有可以采集的 log 日志，但是，毛主席说过：没有 log 我们就自己创造 log！</p>
<p>将以下内容复制到 <code>generate_logs.py</code> 文件中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">METHODS = [<span class="string">'GET'</span>, <span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'DELETE'</span>]</div><div class="line">INTERFACES = [</div><div class="line">    <span class="string">'/interface/1'</span>, <span class="string">'/interface/2'</span>, <span class="string">'/interface/3'</span>,</div><div class="line">    <span class="string">'/interface/4'</span>, <span class="string">'/interface/5'</span>, <span class="string">'/interface/6'</span>,</div><div class="line">]</div><div class="line">STATUS_CODES = [<span class="number">200</span>, <span class="number">201</span>, <span class="number">301</span>, <span class="number">400</span>, <span class="number">401</span>, <span class="number">403</span>, <span class="number">404</span>, <span class="number">500</span>]</div><div class="line"></div><div class="line">LOG_FORMAT = <span class="string">'[&#123;&#125;] "&#123;&#125; &#123;&#125; HTTP/1.1" &#123;&#125;\r\n'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_fade_logs</span><span class="params">(log_path)</span>:</span></div><div class="line">    current_time = datetime.datetime.now().strftime(<span class="string">'%d/%m/%y %H:%M:%S'</span>)</div><div class="line">    method = random.choice(METHODS)</div><div class="line">    interface = random.choice(INTERFACES)</div><div class="line">    status_code = random.choice(STATUS_CODES)</div><div class="line"></div><div class="line">    log = LOG_FORMAT.format(current_time, method, interface, status_code)</div><div class="line"></div><div class="line">    <span class="keyword">with</span> open(log_path, <span class="string">'a'</span>) <span class="keyword">as</span> f:</div><div class="line">        f.writelines(log)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">while</span>  <span class="keyword">True</span>:</div><div class="line">        generate_fade_logs(<span class="string">'/Users/a/Desktop/test_logs.log'</span>)</div><div class="line">        time.sleep(random.randint(<span class="number">10</span>, <span class="number">20</span>))</div></pre></td></tr></table></figure></p>
<p>启动我们的“log生成器”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ python generate_logs.py</div></pre></td></tr></table></figure></p>
<h3 id="启动-Filebeat"><a href="#启动-Filebeat" class="headerlink" title="启动 Filebeat"></a>启动 Filebeat</h3><p>在另一个命令行窗口输入以下命令启动 Filebeat：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>启动之后，伴随着“log生成器”的辛勤工作，你会在前面 Logstash 启动的命令行窗口和 Filebeat 启动的命令窗口中不断看到如下类似的信息的出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;prospector&quot; =&gt; &#123;</div><div class="line">        &quot;type&quot; =&gt; &quot;log&quot;</div><div class="line">    &#125;,</div><div class="line">          &quot;tags&quot; =&gt; [</div><div class="line">        [0] &quot;beats_input_codec_plain_applied&quot;</div><div class="line">    ],</div><div class="line">        &quot;source&quot; =&gt; &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</div><div class="line">       &quot;message&quot; =&gt; &quot;[13/03/18 10:20:29] \&quot;DELETE /interface/5 HTTP/1.1\&quot; 404&quot;,</div><div class="line">    &quot;@timestamp&quot; =&gt; 2018-03-13T02:20:30.713Z,</div><div class="line">        &quot;offset&quot; =&gt; 4004,</div><div class="line">          &quot;beat&quot; =&gt; &#123;</div><div class="line">            &quot;name&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">        &quot;hostname&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">         &quot;version&quot; =&gt; &quot;6.2.2&quot;</div><div class="line">    &#125;,</div><div class="line">          &quot;host&quot; =&gt; &quot;xxxdeiMac.local&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用-Grok-过滤插件解析-log"><a href="#使用-Grok-过滤插件解析-log" class="headerlink" title="使用 Grok 过滤插件解析 log"></a>使用 Grok 过滤插件解析 log</h3><p>我们的 Pipeline 已经能从 Filebeat 中读取 log 信息了，但是你也看到了，输出的 log 信息全存在了 <code>message</code> 字段，我们得目的是获取这串 log 信息中的各个部分数据，为了解决这个问题，我们需要使用 <code>Grok</code> 过滤插件。</p>
<p>我们“log 生成器”生成的日志格式是长这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[13/03/18 10:22:29] &quot;POST /interface/2 HTTP/1.1&quot; 201</div></pre></td></tr></table></figure></p>
<p>中括号里面是时间，接着引号里面是请求方法、请求内容、HTTP协议，最后是响应的状态码。</p>
<p><code>Grok</code> 的解析语法一般长这样：<code>%{语法:语义}</code>。比如 <code>3.44</code> 这个数据，我们可以用 <code>NUMBER</code> 这个内置语法来捕获到，而 <code>POST</code> 这个单词可以用 <code>WORD</code> 这个内置语法捕获。</p>
<p>对于我们的日志格式，我们得 <code>Grok</code> 过滤语法可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们把这个过滤语法加到 <code>filter</code> 块中试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">filter &#123;</div><div class="line">    grok &#123;</div><div class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终，我们的 <code>first-pipeline.conf</code> 长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5044&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">filter &#123;</div><div class="line">    grok &#123;</div><div class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    stdout &#123; codec =&gt; rubydebug &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意:</strong><br>由于 Filebeat 读取日志文件的时候会记住当前读到哪个位置，下次会接在这个位置之后读取，我们先 <code>CTRL-C</code> 停止 FileBeat 的读取，然后我们需要把记录这个信息的文件删除：<code>rm data.registry</code></p>
</blockquote>
<p>现在重启 <code>Filebeat</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  filebeat-6.2.2-darwin-x86_64 ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>现在我们的 Logstash 命令行应该会输出以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">           &quot;beat&quot; =&gt; &#123;</div><div class="line">         &quot;version&quot; =&gt; &quot;6.2.2&quot;,</div><div class="line">            &quot;name&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">        &quot;hostname&quot; =&gt; &quot;xxxdeiMac.local&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;httpversion&quot; =&gt; &quot;1.1&quot;,</div><div class="line">           &quot;host&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">     &quot;prospector&quot; =&gt; &#123;</div><div class="line">        &quot;type&quot; =&gt; &quot;log&quot;</div><div class="line">    &#125;,</div><div class="line">           &quot;tags&quot; =&gt; [</div><div class="line">        [0] &quot;beats_input_codec_plain_applied&quot;</div><div class="line">    ],</div><div class="line">           &quot;date&quot; =&gt; &quot;13/03/18 15:07:38&quot;,</div><div class="line">           &quot;verb&quot; =&gt; &quot;PUT&quot;,</div><div class="line">        &quot;request&quot; =&gt; &quot;/interface/5&quot;,</div><div class="line">     &quot;@timestamp&quot; =&gt; 2018-03-13T07:07:44.509Z,</div><div class="line">         &quot;source&quot; =&gt; &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">    &quot;status_code&quot; =&gt; &quot;201&quot;,</div><div class="line">         &quot;offset&quot; =&gt; 5183,</div><div class="line">        &quot;message&quot; =&gt; &quot;[13/03/18 15:07:38] \&quot;PUT /interface/5 HTTP/1.1\&quot; 201&quot;,</div><div class="line">       &quot;@version&quot; =&gt; &quot;1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>date</code>，<code>verb</code>，<code>request</code>，<code>httpversion</code>，<code>status_code</code> 字段就是我们通过 <code>Grok</code> 解析出来的字段。当然，原本的 <code>message</code> 依然存在。</p>
<h3 id="索引化数据并发给-Elasticsearch"><a href="#索引化数据并发给-Elasticsearch" class="headerlink" title="索引化数据并发给 Elasticsearch"></a>索引化数据并发给 Elasticsearch</h3><p>首先，我们先把数据输出给 Elasticsearch，在 <code>first-pipeline.conf</code> 文件的 <code>output</code> 块中增加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        hosts =&gt; [ &quot;localhost:9200&quot; ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：</strong><br>上述的配置，假定 Logstash 和 Elasticsearch 都是跑在同一台实例上。</p>
</blockquote>
<p>像上面一样，重启 Filebeat，让 Filebeat 重新读取整个日志文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  filebeat-6.2.2-darwin-x86_64 rm data/registry</div><div class="line">➜  filebeat-6.2.2-darwin-x86_64 ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>上面我们安装 Elasticsearch 的时候已经启动了，如果没有启动的话现在可以启动 Elasticsearch 了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  elasticsearch-6.2.2 bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>由于 <code>Grok</code> 过滤插件已经帮我们把数据建好索引并发给了 Elasticsearch，我们可以通过在浏览器输入 <code>localhost:9200/_cat/indices?v</code> 来查看已经建好的索引名字，一般为 <code>logstash-$DATE</code>，<code>$DATE</code> 为 <code>Grok</code> 插件建立索引时候的日期：<code>YYYY.MM.DD</code>。</p>
<p>拿到索引名称后在浏览器输入 <code>localhost:9200/logstash-$DATE/_search?pretty&amp;q=status_code=404</code> 即可看到我们上面解析到的 <code>status_code</code> 这个字段全部为 <code>404</code> 的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot; : 30,</div><div class="line">  &quot;timed_out&quot; : false,</div><div class="line">  &quot;_shards&quot; : &#123;</div><div class="line">    &quot;total&quot; : 5,</div><div class="line">    &quot;successful&quot; : 5,</div><div class="line">    &quot;skipped&quot; : 0,</div><div class="line">    &quot;failed&quot; : 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot; : &#123;</div><div class="line">    &quot;total&quot; : 30,</div><div class="line">    &quot;max_score&quot; : 2.384823,</div><div class="line">    &quot;hits&quot; : [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot; : &quot;logstash-2018.03.13&quot;,</div><div class="line">        &quot;_type&quot; : &quot;doc&quot;,</div><div class="line">        &quot;_id&quot; : &quot;iNpDHmIBdTFR9RiADh6e&quot;,</div><div class="line">        &quot;_score&quot; : 2.384823,</div><div class="line">        &quot;_source&quot; : &#123;</div><div class="line">          &quot;date&quot; : &quot;13/03/18 15:05:21&quot;,</div><div class="line">          &quot;@timestamp&quot; : &quot;2018-03-13T07:28:46.413Z&quot;,</div><div class="line">          &quot;request&quot; : &quot;/interface/6&quot;,</div><div class="line">          &quot;verb&quot; : &quot;POST&quot;,</div><div class="line">          &quot;tags&quot; : [</div><div class="line">            &quot;beats_input_codec_plain_applied&quot;</div><div class="line">          ],</div><div class="line">          &quot;@version&quot; : &quot;1&quot;,</div><div class="line">          &quot;prospector&quot; : &#123;</div><div class="line">            &quot;type&quot; : &quot;log&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;status_code&quot; : &quot;404&quot;,</div><div class="line">          &quot;message&quot; : &quot;[13/03/18 15:05:21] \&quot;POST /interface/6 HTTP/1.1\&quot; 404&quot;,</div><div class="line">          &quot;source&quot; : &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">          &quot;beat&quot; : &#123;</div><div class="line">            &quot;version&quot; : &quot;6.2.2&quot;,</div><div class="line">            &quot;hostname&quot; : &quot;1deiMac.local&quot;,</div><div class="line">            &quot;name&quot; : &quot;1deiMac.local&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;host&quot; : &quot;1deiMac.local&quot;,</div><div class="line">          &quot;offset&quot; : 4702,</div><div class="line">          &quot;httpversion&quot; : &quot;1.1&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      ...</div><div class="line">      ...</div><div class="line">      ...</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们基本就已经把 <code>Filebeat --&gt; Logstash --&gt; Elasticsearch</code> 这条路打通了！</p>
<p>接下来要想更直观的查看分析数据，就需要引入 <code>ELK</code> 三大组件之 <code>Kibana</code>。</p>
<p>参考文档：<br><a href="https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html" target="_blank" rel="external">Logstash 官方文档</a><br><a href="https://www.elastic.co/guide/en/logstash/6.2/plugins-filters-grok.html" target="_blank" rel="external">Grok 官方文档</a><br><a href="http://grokconstructor.appspot.com/" target="_blank" rel="external">Grok Constructor</a><br><a href="http://grokdebug.herokuapp.com/" target="_blank" rel="external">Grok Debugger</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集中式日志系统ELK协议栈简介与入门&quot;&gt;&lt;a href=&quot;#集中式日志系统ELK协议栈简介与入门&quot; class=&quot;headerlink&quot; title=&quot;集中式日志系统ELK协议栈简介与入门&quot;&gt;&lt;/a&gt;集中式日志系统ELK协议栈简介与入门&lt;/h1&gt;&lt;p&gt;什么是“ELK”？&lt;/p&gt;
&lt;p&gt;“ELK”是三大开源软件的缩写：Elasticsearch、Logstash、Kibana。&lt;/p&gt;
&lt;p&gt;Elasticsearch 负责搜索和分析，Logstash 负责从各个来源搜集、转换数据，kibana 以图表的形式在 Elasticsearch 中展示数据。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Data" scheme="https://yuanblq.github.io/tags/Data/"/>
    
  </entry>
  
  <entry>
    <title>Celery 后台运行</title>
    <link href="https://yuanblq.github.io/2018/01/17/Celery-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>https://yuanblq.github.io/2018/01/17/Celery-后台运行/</id>
    <published>2018-01-17T07:20:15.000Z</published>
    <updated>2018-01-17T07:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Celery-后台运行"><a href="#Celery-后台运行" class="headerlink" title="Celery 后台运行"></a>Celery 后台运行</h2><p>测试的时候我们可以直接在不同的终端直接运行 Celery 进程，但是如果要在服务器上运行，那我们岂不是得开好几个终端，而且退出终端之后 Celery 进程也就停止了，能不能让 Celery 在后台以守护进程的方式运行？</p>
<p>不用说，当然是可以的，而且还不止一种方式。这里先介绍 <code>init-script</code> 方法。</p>
<a id="more"></a>
<h3 id="使用通用的-init-script"><a href="#使用通用的-init-script" class="headerlink" title="使用通用的 init-script"></a>使用通用的 init-script</h3><p>首先获取 Celery 的 GitHub 仓库 <a href="https://github.com/celery/celery/tree/3.1/extra/generic-init.d/" target="_blank" rel="external"><code>extra/generic-init.d/</code></a> 文件夹下的文件。</p>
<h4 id="启动-worker"><a href="#启动-worker" class="headerlink" title="启动 worker"></a>启动 worker</h4><p>将上面 GitHub 仓库文件夹下的 <code>celeryd</code> 文件复制到本地的 <code>/etc/init.d/celeryd</code> 文件中并赋予可执行的权限: <code>sudo chmod +x /etc/init.d/celeryd</code>，然后在 <code>/etc/default/</code> 文件夹下创建 <code>celeryd</code> 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Names of nodes to start</span></div><div class="line"><span class="comment">#   most people will only start one node:</span></div><div class="line">CELERYD_NODES=<span class="string">"worker1"</span></div><div class="line"><span class="comment">#   but you can also start multiple and configure settings</span></div><div class="line"><span class="comment">#   for each in CELERYD_OPTS</span></div><div class="line"><span class="comment">#CELERYD_NODES="worker1 worker2 worker3"</span></div><div class="line"><span class="comment">#   alternatively, you can specify the number of nodes to start:</span></div><div class="line"><span class="comment">#CELERYD_NODES=10</span></div><div class="line"></div><div class="line"><span class="comment"># Absolute or relative path to the 'celery' command:</span></div><div class="line">CELERY_BIN=<span class="string">"/usr/local/bin/celery"</span></div><div class="line"><span class="comment">#CELERY_BIN="/virtualenvs/def/bin/celery"</span></div><div class="line"></div><div class="line"><span class="comment"># App instance to use</span></div><div class="line"><span class="comment"># comment out this line if you don't use an app</span></div><div class="line">CELERY_APP=<span class="string">"proj"</span></div><div class="line"><span class="comment"># or fully qualified:</span></div><div class="line"><span class="comment">#CELERY_APP="proj.tasks:app"</span></div><div class="line"></div><div class="line"><span class="comment"># Where to chdir at start.</span></div><div class="line">CELERYD_CHDIR=<span class="string">"/opt/Myproject/"</span></div><div class="line"></div><div class="line"><span class="comment"># Extra command-line arguments to the worker</span></div><div class="line">CELERYD_OPTS=<span class="string">"--time-limit=300 --concurrency=8"</span></div><div class="line"><span class="comment"># Configure node-specific settings by appending node name to arguments:</span></div><div class="line"><span class="comment">#CELERYD_OPTS="--time-limit=300 -c 8 -c:worker2 4 -c:worker3 2 -Ofair:worker1"</span></div><div class="line"></div><div class="line"><span class="comment"># Set logging level to DEBUG</span></div><div class="line"><span class="comment">#CELERYD_LOG_LEVEL="DEBUG"</span></div><div class="line"></div><div class="line"><span class="comment"># %n will be replaced with the first part of the nodename.</span></div><div class="line">CELERYD_LOG_FILE=<span class="string">"/var/log/celery/%n%I.log"</span></div><div class="line">CELERYD_PID_FILE=<span class="string">"/var/run/celery/%n.pid"</span></div><div class="line"></div><div class="line"><span class="comment"># Workers should run as an unprivileged user.</span></div><div class="line"><span class="comment">#   You need to create this user manually (or you can choose</span></div><div class="line"><span class="comment">#   a user/group combination that already exists (e.g., nobody).</span></div><div class="line">CELERYD_USER=<span class="string">"celery"</span></div><div class="line">CELERYD_GROUP=<span class="string">"celery"</span></div><div class="line"></div><div class="line"><span class="comment"># If enabled pid and log directories will be created if missing,</span></div><div class="line"><span class="comment"># and owned by the userid/group configured.</span></div><div class="line">CELERY_CREATE_DIRS=1</div></pre></td></tr></table></figure>
<p>这个配置文件中，你可能需要更改 <code>CELERY_BIN</code>, <code>CELERY_APP</code>, <code>CELERYD_CHDIR</code>, <code>CELERYD_USER</code>, <code>CELERYD_GROUP</code>。</p>
<p>根据你自身项目配置好上述配置后就可以通过 <code>/etc/init.d/celeryd {start|stop|restart|graceful|kill|dryrun|create-paths}</code> 这些命令来控制 Celery worker 进程。</p>
<h4 id="启动-beat"><a href="#启动-beat" class="headerlink" title="启动 beat"></a>启动 beat</h4><p>如果你的项目中还有周期任务，那么还得把 Celery beat 启动起来。</p>
<p>把 GitHub 仓库中的 <code>celerybeat</code> 文件复制到 <code>/etc/init.d/celerybeat</code> 文件中，然后赋予可执行权限: <code>sudo chmod +x /etc/init.d/celerybeat</code>。</p>
<p>然后同样得有一个 <code>/etc/default/celerybeat</code> 配置文件。不过，如果没有什么特殊配置，可以直接使用 <code>/etc/default/celeryd</code> 配置文件，不必创建 <code>/etc/default/celerybeat</code> 配置文件。</p>
<p>如果你依然要创建的，那么这个文件可能是长这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Absolute or relative path to the 'celery' command:</span></div><div class="line">CELERY_BIN=<span class="string">"/usr/local/bin/celery"</span></div><div class="line"><span class="comment">#CELERY_BIN="/virtualenvs/def/bin/celery"</span></div><div class="line"></div><div class="line"><span class="comment"># App instance to use</span></div><div class="line"><span class="comment"># comment out this line if you don't use an app</span></div><div class="line">CELERY_APP=<span class="string">"proj"</span></div><div class="line"><span class="comment"># or fully qualified:</span></div><div class="line"><span class="comment">#CELERY_APP="proj.tasks:app"</span></div><div class="line"></div><div class="line"><span class="comment"># Where to chdir at start.</span></div><div class="line">CELERYBEAT_CHDIR=<span class="string">"/opt/Myproject/"</span></div><div class="line"></div><div class="line"><span class="comment"># Extra arguments to celerybeat</span></div><div class="line">CELERYBEAT_OPTS=<span class="string">"--schedule=/var/run/celery/celerybeat-schedule"</span></div></pre></td></tr></table></figure>
<p>完成配置后，同样通过 <code>/etc/init.d/celerybeat {start|stop|restart|create-paths|status}</code> 这些命令控制 Celery beat 进程。</p>
<blockquote>
<p>参考文档：<br><a href="http://docs.celeryproject.org/en/latest/userguide/daemonizing.html" target="_blank" rel="external">Celery daemon</a><br><a href="https://pythad.github.io/articles/2016-12/how-to-run-celery-as-a-daemon-in-production" target="_blank" rel="external">How to run celery as a daemon?</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Celery-后台运行&quot;&gt;&lt;a href=&quot;#Celery-后台运行&quot; class=&quot;headerlink&quot; title=&quot;Celery 后台运行&quot;&gt;&lt;/a&gt;Celery 后台运行&lt;/h2&gt;&lt;p&gt;测试的时候我们可以直接在不同的终端直接运行 Celery 进程，但是如果要在服务器上运行，那我们岂不是得开好几个终端，而且退出终端之后 Celery 进程也就停止了，能不能让 Celery 在后台以守护进程的方式运行？&lt;/p&gt;
&lt;p&gt;不用说，当然是可以的，而且还不止一种方式。这里先介绍 &lt;code&gt;init-script&lt;/code&gt; 方法。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Celery" scheme="https://yuanblq.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>celery入门到使用</title>
    <link href="https://yuanblq.github.io/2018/01/16/celery%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuanblq.github.io/2018/01/16/celery入门到使用/</id>
    <published>2018-01-16T09:10:46.000Z</published>
    <updated>2018-01-16T09:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="celery入门到使用"><a href="#celery入门到使用" class="headerlink" title="celery入门到使用"></a>celery入门到使用</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pip install celery</div><div class="line">$ pip install redis</div></pre></td></tr></table></figure>
<h3 id="celery应用"><a href="#celery应用" class="headerlink" title="celery应用"></a>celery应用</h3><p>使用 celery 的前提是你得有一个 Celery 的实例。我们可以称之为 Celery 应用或者简单地说 app。该实例是用来创建 task 任务、管理 worker 等等，所以必须保证在我们得其他模块中能将它导入过来。</p>
<a id="more"></a>
<h3 id="单个模块"><a href="#单个模块" class="headerlink" title="单个模块"></a>单个模块</h3><p>创建一个 tasks.py 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from celery import Celery</div><div class="line"></div><div class="line">app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379/1&apos;)</div><div class="line"></div><div class="line">@app.task</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div></pre></td></tr></table></figure></p>
<p>[分析]：<code>Celery()</code> 的第一个参数是当前模块的名字，第二个参数是 <code>broker</code> 关键字参数，填写你用的 broker 的 URL 地址。然后定义了一个叫做 add 的任务。</p>
<h3 id="启动-celery-worker-服务"><a href="#启动-celery-worker-服务" class="headerlink" title="启动 celery worker 服务"></a>启动 celery worker 服务</h3><p>通过 <code>worker</code> 参数启动我们的 worker：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ celery -A tasks worker --loglevel=info</div></pre></td></tr></table></figure></p>
<h3 id="调用-task"><a href="#调用-task" class="headerlink" title="调用 task"></a>调用 task</h3><p>调用 task 可以使用 <code>delay()</code> 方法，这是 <code>apply_async()</code> 方法的缩写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from tasks import add</div><div class="line">&gt;&gt;&gt; add.delay(4, 4)</div></pre></td></tr></table></figure></p>
<h3 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h3><p>如果我们要想跟踪 task 的结果或者状态，那么就必须有个地方存储这些信息。redis 提供 <code>backend</code> 配置来设置 task 结果的存储位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379/1&apos;, backend=&apos;redis://localhost:6379/2&apos;)</div></pre></td></tr></table></figure></p>
<p>现在我们重新启动 Celery 后，再次发送一个 task 任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.sleep(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p><code>ready()</code> 用来判断某个 task 任务是否完成。这个方法是立刻返回结果的，当然也可以等待 task 任务的完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.get(timeout=<span class="number">1</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>不过这种方法一般不常用，因为我们都已经做异步任务了，而这种方法是同步的。</p>
<p><code>get()</code> 方法有个参数 <code>propagate</code>，这个参数的意思是：如果这个 task 任务发生了 Exception，那么在 <code>get()</code> 方法中会再一次抛出这个异常，通过设置 <code>propagate=False</code>，可以阻止异常的传递。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>一般情况下，Celery 的默认配置能够满足绝大多数情况，不过 Celery 提供了大量的配置能满足你的其他需求。熟悉这些配置将会让你对之后的工作游刃有余。你可以在<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#configuration" target="_blank" rel="external">Celery 配置手册</a>中查看其他配置。</p>
<p>这些配置可以直接设置在 <code>celery_app</code> 实例中，也可以设置在一个独立的配置模块中。</p>
<p>举个例子，如果我们要配置 Celery 的默认序列化方式，可以修改 <code>task_serializer</code> 配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app.conf.task_serializer = <span class="string">'json'</span></div></pre></td></tr></table></figure></p>
<p>你也可以通过 <code>update</code> 来一次同时更新多个配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">celery_app.conf.update(</div><div class="line">    task_serializer=<span class="string">'json'</span>,</div><div class="line">    accept_content=[<span class="string">'json'</span>],  <span class="comment"># Ignore other content</span></div><div class="line">    result_serializer=<span class="string">'json'</span>,</div><div class="line">    timezone=<span class="string">'Asia/Shanghai'</span>,</div><div class="line">    enable_utc=<span class="keyword">True</span>,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>对于大点的项目，推荐使用独立的配置模块管理 Celery 配置。然后调用 <code>celery_app.config_from_object()</code> 方法告诉 Celery 实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app.config_from_object(<span class="string">'celeryconfig'</span>)</div></pre></td></tr></table></figure>
<p>上面的代码表示：从一个叫做 <code>celeryconfig.py</code> 的文件中读取配置，该文件可以存放在当前目录也可以是其他 Python 路径。</p>
<p>一个正经的 <code>celeryconfig.py</code> 文件也许长的是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># celeryconfig.py</span></div><div class="line">broker_url = <span class="string">'pyamqp://'</span></div><div class="line">result_backend = <span class="string">'rpc://'</span></div><div class="line"></div><div class="line">task_serializer = <span class="string">'json'</span></div><div class="line">result_serializer = <span class="string">'json'</span></div><div class="line">accept_content = [<span class="string">'json'</span>]</div><div class="line">timezone = <span class="string">'Asia/Shanghai'</span></div><div class="line">enable_utc = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>为了验证我们写的这个配置文件有没有语法错误可执行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python -m celeryconfig</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;celery入门到使用&quot;&gt;&lt;a href=&quot;#celery入门到使用&quot; class=&quot;headerlink&quot; title=&quot;celery入门到使用&quot;&gt;&lt;/a&gt;celery入门到使用&lt;/h2&gt;&lt;h3 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ pip install celery&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ pip install redis&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;celery应用&quot;&gt;&lt;a href=&quot;#celery应用&quot; class=&quot;headerlink&quot; title=&quot;celery应用&quot;&gt;&lt;/a&gt;celery应用&lt;/h3&gt;&lt;p&gt;使用 celery 的前提是你得有一个 Celery 的实例。我们可以称之为 Celery 应用或者简单地说 app。该实例是用来创建 task 任务、管理 worker 等等，所以必须保证在我们得其他模块中能将它导入过来。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Celery" scheme="https://yuanblq.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全说明</title>
    <link href="https://yuanblq.github.io/2018/01/10/Redis%E5%AE%89%E5%85%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://yuanblq.github.io/2018/01/10/Redis安全说明/</id>
    <published>2018-01-10T06:20:58.000Z</published>
    <updated>2018-01-10T09:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><h3 id="普通安全模型"><a href="#普通安全模型" class="headerlink" title="普通安全模型"></a>普通安全模型</h3><p>redis 设计的初衷就是用来给在可信环境的可信客户端访问的，也就是说直接把 redis 实例暴露在网络或者不可信的环境中不是一个明智的选择。</p>
<p>比如在一个普通的 web 应用上下文中，使用 redis 作为数据库、缓存、消息系统，位于 web 前端的客户端应用或者甚至是用户都可以通过查询 redis 来获取请求的操作页面。</p>
<p>这种情况下，web 应用暴露在 redis 和不可信的客户端之间（用户通过 web 应用访问）。</p>
<p>这是一个特殊案例，但通常对于连接到 redis 的不可信访问都必须通过一层 ACL 层来验证用户的输入，判断应该做出什么样的操作行为。</p>
<a id="more"></a>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>如果你只是在自己电脑上用用 redis，那么就没必要把 redis 的端口暴露在网络中。通过在 <code>redis.conf</code> 文件中的以下命令可以实现只是自己电脑的 redis 客户端通过回环接口访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>如果防止 redis 端口暴露在外部环境的尝试失败，那么将可能引发不可想象的毁灭。比如一个简单的 <code>FLUSHALL</code> 命令能删光你的所有数据。</p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>从 3.2.0 版本开始，默认情况下，redis 处于“保护模式”状态。该模式下，redis 只回复回环接口的 query 请求。保护请求依然可以被手动取消或者可以开放其他接口。</p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>对于访问操作，redis 并没有做处理，而是加了一层验证层，可以在 <code>redis.conf</code> 配置文件中设置。</p>
<p>设置完密码后可以通过 <code>AUTH &lt;password&gt;</code> 命令发送验证。该密码一般有系统管理员在 <code>redis.conf</code> 文件中配置，而且应尽量的复杂：</p>
<ul>
<li>redis 查询速度很快，所以短时间内攻击者可以尝试很多次</li>
<li>密码以明文的形式配置在 <code>redis.conf</code> 文件中，所以即使很复杂也不必担心忘记</li>
</ul>
<p>但 <code>AUTH</code> 命令和其他 redis 命令一样是不加密处理的。所以还是抵御不了一些有足够权限的攻击者。</p>
<h3 id="数据加密支持"><a href="#数据加密支持" class="headerlink" title="数据加密支持"></a>数据加密支持</h3><p>redis 本身不支持加密处理，但可以添加额外的层来实现，比如增加 SSL 代理，推荐使用 <a href="http://www.tarsnap.com/spiped.html" target="_blank" rel="external">spiped</a></p>
<h3 id="禁用指定命令"><a href="#禁用指定命令" class="headerlink" title="禁用指定命令"></a>禁用指定命令</h3><p>redis 有个 <code>CONFIG</code> 命令，用来操作 redis 的配置。如任何人都能操作这个命令那也是件很危险的事情。还好有两种方法可以解决这个问题：</p>
<ul>
<li>重命名 <code>CONFIG</code> 命令</li>
<li>隐藏 <code>CONFIG</code> 命令</li>
</ul>
<p>这两种方法实际上是同一种操作。redis 提供对命令的重命名操作：在 <code>redis.conf</code> 配置文件中通过添加如下一行即可对一个命令进行重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</div></pre></td></tr></table></figure></p>
<p>通过上面的配置之后 <code>redis-cli</code> 中就再也没有 <code>CONFIG</code> 这个命令了，取而代之的是 <code>b840fc02d524045429941cc15f59e41cb7be6c52</code>。蛤蛤，想不到吧，别人得猜到什么时候才能知道原来 <code>CONFIG</code> 的名字被改成了 <code>b840fc02d524045429941cc15f59e41cb7be6c52</code>。</p>
<p>当然如果你把 <code>CONFIG</code> 直接命名为 <code>&quot;&quot;</code>，那就是把这个命令隐藏了。</p>
<h3 id="字符串转义和-NoSQL-注入"><a href="#字符串转义和-NoSQL-注入" class="headerlink" title="字符串转义和 NoSQL 注入"></a>字符串转义和 NoSQL 注入</h3><p>redis 协议不存在字符串转义这个概念，所以对于一个正常的客户端来说，注入不存在的，都是安全的二进制。</p>
<h3 id="代码安全性"><a href="#代码安全性" class="headerlink" title="代码安全性"></a>代码安全性</h3><p>由于可以通过 <code>CONFIG</code> 命令来改变程序的工作目录或者改变 dump file 的名字。这也意味着客户端可能会随意地在任何地方写人 redis 的 RDB 文件。这个<a href="http://antirez.com/news/96" target="_blank" rel="external">安全问题</a>。</p>
<p>redis 的运行不需要 root 权限。redis 的作者正在调研是否要添加新的配置参数来禁止 <code>CONFIG SET/GET dir</code> 和类似的运行时配置。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis-安全&quot;&gt;&lt;a href=&quot;#Redis-安全&quot; class=&quot;headerlink&quot; title=&quot;Redis 安全&quot;&gt;&lt;/a&gt;Redis 安全&lt;/h2&gt;&lt;h3 id=&quot;普通安全模型&quot;&gt;&lt;a href=&quot;#普通安全模型&quot; class=&quot;headerlink&quot; title=&quot;普通安全模型&quot;&gt;&lt;/a&gt;普通安全模型&lt;/h3&gt;&lt;p&gt;redis 设计的初衷就是用来给在可信环境的可信客户端访问的，也就是说直接把 redis 实例暴露在网络或者不可信的环境中不是一个明智的选择。&lt;/p&gt;
&lt;p&gt;比如在一个普通的 web 应用上下文中，使用 redis 作为数据库、缓存、消息系统，位于 web 前端的客户端应用或者甚至是用户都可以通过查询 redis 来获取请求的操作页面。&lt;/p&gt;
&lt;p&gt;这种情况下，web 应用暴露在 redis 和不可信的客户端之间（用户通过 web 应用访问）。&lt;/p&gt;
&lt;p&gt;这是一个特殊案例，但通常对于连接到 redis 的不可信访问都必须通过一层 ACL 层来验证用户的输入，判断应该做出什么样的操作行为。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Django F对象</title>
    <link href="https://yuanblq.github.io/2018/01/05/Django-F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yuanblq.github.io/2018/01/05/Django-F对象/</id>
    <published>2018-01-05T06:55:55.000Z</published>
    <updated>2018-01-05T07:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-表达式"><a href="#F-表达式" class="headerlink" title="F() 表达式"></a>F() 表达式</h2><p>Django 常用的保存 model 对象的方法是 <code>save()</code>，但是这种做法并不是在所有情况下都适用的。</p>
<p>我们得先从数据库获取到对用对象的那条数据，转换成 Python 对象，对 Python 对象进行相应的操作，然后转换成相应数据保存到数据库中。</p>
<p>相当于先从数据库出来，在 Python 转一圈然后再回到数据库。这样难免会出一些问题。</p>
<a id="more"></a>
<p>相较于传统的 <code>save()</code> 操作，<code>F()</code> 对象，有以下几个特性：</p>
<h3 id="直接操作数据库"><a href="#直接操作数据库" class="headerlink" title="直接操作数据库"></a>直接操作数据库</h3><p>F() 对象能直接拿到 model 字段的值，并且不用将它们从数据库拉到 Python 的内存中，而可以直接在数据库层面操作。</p>
<p>实际上，Django 通过 F() 对象直接生成 SQL 表达式在数据库层级操作数据库。</p>
<p>通过下面的例子可以直观的理解这点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed += <span class="number">1</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>我们先从数据库中取出 <code>reporter.stories_field</code> 字段的值，然后经过熟悉的 Python 操作后再把对象存储到数据库中。</p>
<p>但我们同样可以这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</div><div class="line"></div><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>虽然这两种操作乍一看感觉不到什么区别，但是，前面我们说过，通过 F() 对象进行的操作是处于数据库层级的。所以，当我们进行 <code>reporter.stories_filed = F(&#39;stories_filed&#39;) + 1</code> 这一步操作的时候，其实并不像之前『把 model 字段值从数据库取出，经过对 Python 对象的一系列操作，最后把 model 对象保存进数据库。』实际上，使用 F() 对象时，我们是不会管当时的 <code>reporter.stories_filed</code> 这个字段的值的，而是会生成为该字段值加1的对应 SQL 语句。</p>
<p>之后要想获取该字段的新值必须得刷新该对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(pk=reporter.pk)</div><div class="line"><span class="comment"># 或者这种更简洁的做法:</span></div><div class="line">reporter.refresh_from_db()</div></pre></td></tr></table></figure></p>
<p>另外，还可以直接在 <code>filter()</code> 的 <code>update()</code> 中使用 F() 对象，这样就能避免先 get 到 model 对象，然后修改后 save 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Reporters.objects.filter(name=<span class="string">'Tintin'</span>).update(stories_filed=F(<span class="string">'stories_filed'</span>) + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<h3 id="避免竞争情况"><a href="#避免竞争情况" class="headerlink" title="避免竞争情况"></a>避免竞争情况</h3><p>有这样一种情况：如果有两个 Python 线程执行上面那个例子中的代码，一条线程“获取”、“增加”、“保存”，另一条只是从数据库“获取”。“获取值”的那条线程获取的值可能是原始值，而不是第一条线程“增加”后的值。也就是说第一条线程所做的基本是无用功。</p>
<p>正如前面所说的，F() 对象是直接通过 SQL 语句来操作数据库的，所以由 F() 对象操作的话，相当于是在数据库层面，那么此操作更加健壮。当调用 <code>save()</code> 和 <code>update()</code> 时，会基于数据库中的值，而不是获取对象时候对象中的字段值。</p>
<h3 id="F-永远在-Model-save-之后执行"><a href="#F-永远在-Model-save-之后执行" class="headerlink" title="F() 永远在 Model.save() 之后执行"></a>F() 永远在 Model.save() 之后执行</h3><p>F() 会在每个 <code>save()</code>之后执行一遍，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></div><div class="line">reporter.save()</div><div class="line"></div><div class="line">reporter.name = <span class="string">'Tintin Jr.'</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>如果 <code>stories_field</code> 的初始值为1，那么最后该值会变为3。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-表达式&quot;&gt;&lt;a href=&quot;#F-表达式&quot; class=&quot;headerlink&quot; title=&quot;F() 表达式&quot;&gt;&lt;/a&gt;F() 表达式&lt;/h2&gt;&lt;p&gt;Django 常用的保存 model 对象的方法是 &lt;code&gt;save()&lt;/code&gt;，但是这种做法并不是在所有情况下都适用的。&lt;/p&gt;
&lt;p&gt;我们得先从数据库获取到对用对象的那条数据，转换成 Python 对象，对 Python 对象进行相应的操作，然后转换成相应数据保存到数据库中。&lt;/p&gt;
&lt;p&gt;相当于先从数据库出来，在 Python 转一圈然后再回到数据库。这样难免会出一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="https://yuanblq.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅔</title>
    <link href="https://yuanblq.github.io/2017/08/25/channel-part5/"/>
    <id>https://yuanblq.github.io/2017/08/25/channel-part5/</id>
    <published>2017-08-25T02:22:57.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行带-Channels-的-Django-项目"><a href="#运行带-Channels-的-Django-项目" class="headerlink" title="运行带 Channels 的 Django 项目"></a>运行带 Channels 的 Django 项目</h2><p>当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 <code>channel layer</code>（你之前配置的）连接的一个或多个 <code>interface server</code> 以及 一个或多个 <code>worker server</code> 上运行。</p>
<a id="more"></a>
<p><code>interface server</code> 有多种类型，每一个都服务于不同类型的 request，比如同时能处理 WebSocket 和 HTTP 请求的，或者可能扮演一个 SMS 消息网关的角色。</p>
<p>Django 在不同 <code>worker server</code> 中，运行的逻辑是独立的，所以 <code>channel layer</code> 可以跨网络传输 channels 的内容。在生产环境中，你可能经常会把 <code>worker server</code> 和 <code>interface server</code> 独立开，作为一个独立的集群，但你当然可以把他们放在同一台机器的不同进程中运行。</p>
<p>默认情况下，Django 没有配置 <code>channel layer</code> —— 毕竟没必要用它来运行 WSGI 请求。所以，只要你添加了 consumer，你就需要配置一下。</p>
<p>在上面的例子中，我们使用 in-memory 形式的 <code>channel layer</code> 实现我们的默认 <code>channel layer</code>。它会把所有的 channel 数据以字典的形式存储在内存中，所以实际上不是跨进程的；它只能在 <code>runserver</code> 的进程中运行，也就是说它是在同一个进程中以多个线程的形式在运行。当我们部署到生产环境，你就需要使用 Redis 后端的 <code>channel layer</code>（<code>asgi_redis</code>）来实现跨进程工作。更多细节请看<a href="http://channels.readthedocs.io/en/latest/backends.html" target="_blank" rel="external">Channel Layer Types</a>。</p>
<p>当我们建立好 channel 后端之后，第二件需要我们考虑的事是，确保我们运行的 <code>interface server</code> 能处理 WebSocket。为了解决这个问题，<code>daphne</code> 应运而生，这是一个能同时处理 HTTP 和 WebSocket 的一个 <code>interface server</code>。前面你运行 <code>runserver</code> 的时候就已经和它绑定好了 —— 虽然看上去和 Django 的 <code>runserver</code> 没什么区别，但是有些配置还是不一样的。</p>
<blockquote>
<p>在处理引擎内部，<code>runserver</code> 现在在一个线程中运行着 Daphne，在另外一个线程中自动加载了一个 worker —— 这就是一个微型版本的部署，在一个进程中运行</p>
</blockquote>
<p>现在来试试 Redis 后端 —— Redis 几乎能在每一台机器上运行，而且开销很少，这就使得它很适合做这件事。</p>
<p>通过 <code>pip</code> 安装 <code>asgi_redis</code> 包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install asgi_redis</div></pre></td></tr></table></figure></p>
<p>在你的 channel layer 中做如下配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># setting.py</span></div><div class="line">CHANNEL_LAYERS = [</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgi_redis.RedisChannelLayer"</span>,</div><div class="line">        <span class="string">"CONFIG"</span>: &#123;</div><div class="line">            <span class="string">"hosts"</span>: [(<span class="string">"localhost"</span>, <span class="number">6379</span>)],</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>当然，在这之前你得安装过 Redis server，在 Ubuntu 中安装很方便，你只需：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install redis-server</div></pre></td></tr></table></figure></p>
<p>现在可以把 <code>runserver</code> 解雇了，当然你也可以用一种比较原生的方式实现跨进程，在两个终端中执行以下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver --noworker</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runworker</div></pre></td></tr></table></figure>
<p>你可能已经猜到，在 <code>runserver</code> 中禁止掉 <code>worker</code> 线程，然后在别的进程中开启 <code>worker</code> 来处理它们。如果你想在它运行 consumer 的时候查看日志，你可以给 <code>runwoker</code> 添加 <code>-v 2</code> 参数。</p>
<p>如果 Django 以 debug 模式运行（DEBUG=True），那么 <code>runworker</code> 会处理静态文件，就像以前 <code>runserver</code> 一样。和以前一样，如果你关闭了 <code>DEBUG</code> 模式，那你就需要配置你的静态文件服务。</p>
<h2 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h2><p>echo message 是一个很不错的简单案例，但是它忽略了像这样一个系统的一个实际需求 —— 为每个连接保存状态。</p>
<p>正如我们之前看到的，<code>reply_channel</code> 属性是指向打开 WebSocket 的唯一指针 —— 因为不同的客户端对应的 WebSocket 都是不同的。我们就是根据这个来追踪是谁发的消息。记住，Channels 是网络透明的并且可以在多个 worker 中运行，所以你不能只是以全局变量的形式来存储局部的信息。</p>
<p>解决的办法就是是以 <code>reply_channel</code> 为 key 把数据存储起来 —— 听起来很熟悉？Django 的session 框架就是使用一个 cookie 作为 key 来处理 HTTP 请求的。</p>
<p>如果我们使用 <code>reply_channel</code> 作为 key 来获取 session 会不会没用？</p>
<p>对此，Channels 提供了 <code>channel_session</code> 装饰器来解决这个问题 —— 它为你提供了一个叫 <code>message.channel_seesion</code> 的属性，就好像 Django 中的 session 一样。</p>
<p>现在，我们构建一个聊天服务，你可以在 WebSocket 的请求路径中传入一个聊天室的名字，以及用你用户名作为查询的一个字符串（暂时忽略验证一这块，这是我们接下来考虑的事）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 建立连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 解析 query string</span></div><div class="line">    params = parse_qs(message.content[<span class="string">"query_string"</span>])</div><div class="line">    <span class="keyword">if</span> <span class="string">b"username"</span> <span class="keyword">in</span> params:</div><div class="line">        <span class="comment"># 在 session 中设置 username</span></div><div class="line">        message.channel_session[<span class="string">"username"</span>] = params[<span class="string">b"username"</span>][<span class="number">0</span>].decode(<span class="string">"utf8"</span>)</div><div class="line">        <span class="comment"># 将用户加入到 room_name 组</span></div><div class="line">        Group(<span class="string">"chat-%s"</span> % room_name).add(message.reply_channel)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 关闭 connection</span></div><div class="line">        message.reply_channel.send(&#123;<span class="string">"close"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"text"</span>: message[<span class="string">"text"</span>],</div><div class="line">            <span class="string">"username"</span>: message.channel_session[<span class="string">"username"</span>],</div><div class="line">        &#125;),</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后更新下 <code>routing.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_connect, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_connect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>如果你能在 console 中控制它，或者用简单的 JavaScript 构建了一个聊天客户端，把收到的消息追加到一个 div 中，那你已经可以通过初始请求建立一个聊天室了。</p>
<h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>现在，WebSocket 的解决方案在某些方面可能还没法和你网站的其余部分共存 —— 特别是，我们想确保我们知道我们到底是在和谁聊天，万一我们有些私人聊天通道呢（我们不能通过让客户端自己请求正确的 channel 来解决这问题，因为这样任何人都可以通过输入私人聊天室名字进入其中）。</p>
<p>由于 WebSocket 是基于 HTTP 协议的，他们有很多相似的特征，包括 path、GET 参数以及 cookie。我们可以像使用 Django 的 session 和 验证系统一样来使用它们，毕竟如果我们无法分别他们是谁，或者无法安全地做事的话，那么 WebSocket 就不是个好东西。</p>
<p>另外，我们不想让 <code>interface server</code> 来存储数据或者执行验证，它们应该是简单、快速、可靠、无需过多状态的一个处理，我们需要在我们自己的 consumer 中做我们的验证逻辑。</p>
<p>辛运的是，Channels 对于 WebSocket 和 其他 message 有个底层规范（ASGI），它附带了一些装饰器，能帮你完成验证以及获取底层 Django 的 session。</p>
<p>Channels 可以从 cookies 中获取 Django 的 session （如果在同一域名内使用像 Daphne 这类来运行 WebSocket 服务），或者从 <code>session_key</code> 的 GET 参数中获取 Django 的 session （如果你想继续使用 WSGI 服务器来运行你的 HTTP 请求，并在另一个域名上运行一个服务进程来处理 WebSocket）。</p>
<p>你可以使用 <code>http_session</code> 装饰器来访问一个用户的 Django session —— 这个装饰器会给你提供一个 <code>message.http_session</code> 属性，就像 <code>request.session</code> 一样。你还可以使用 <code>http_seesion_user</code> 装饰器，这个会给你提供一个 <code>message.user</code> 属性，当然和之前 session 的那个属性一样。</p>
<p>现在，需要注意的是，你只能从 WebSocket 连接时的 <code>connect</code> message 中获取到详细的 HTTP 信息（你可能需要了解更多关于 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的规范）。也就意味着我们不会浪费带宽，去发送同样的信息。</p>
<p>这就意味着，我们需要在连接处理中抓取到用户的信息，并把它存在 session 中。幸好，Channels 自带的 <code>channel_session_user</code> 装饰器和上面我们提到的 <code>http_session_user</code> 装饰器差不多，但是它是从 <em>channel</em> 的 session 中加载用户信息，而不是从 <em>http</em> 的session。另外有个叫 <code>transfer_user</code> 的函数，能从一个 session 往另外一个 session 中复制用户信息。甚至有个更好的东西，<code>channel_session_user_from_http</code> 装饰器能把所有的这些集合在了一起。</p>
<p>现在，我们把这些组合起来，让我们的聊天服务器，只能是姓氏一样的用户才能在一个聊天室中聊天：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Channel, Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> channel_session_user, channel_session_user_from_http</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 连接</span></div><div class="line"><span class="meta">@channel_session_user_from_http</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把它们添加到合适的 group</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).send(&#123;</div><div class="line">        <span class="string">"text"</span>: message[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>如果你仅仅使用 <code>runserver</code>（或者 Daphne），你只需 connect，然后你的 cookie 就可以传递你的 auth 信息。如果你在不同的域上运行 WebSocket，那你就得像下边一样，在 URL 上提供 Django 的 sessionID：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:9000/?session_key=abcdefg"</span>);</div></pre></td></tr></table></figure></p>
<p>你可以在模板中使用 <code></code> 来获取当前的 session key。<strong>注意：</strong>对于已签名的 cookie session 没用 —— 因为只用 HTTP 响应才能设置 cookie，它需要一个后端来写入独立的存储你状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行带-Channels-的-Django-项目&quot;&gt;&lt;a href=&quot;#运行带-Channels-的-Django-项目&quot; class=&quot;headerlink&quot; title=&quot;运行带 Channels 的 Django 项目&quot;&gt;&lt;/a&gt;运行带 Channels 的 Django 项目&lt;/h2&gt;&lt;p&gt;当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 &lt;code&gt;channel layer&lt;/code&gt;（你之前配置的）连接的一个或多个 &lt;code&gt;interface server&lt;/code&gt; 以及 一个或多个 &lt;code&gt;worker server&lt;/code&gt; 上运行。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>celery 解决 web 耗时操作</title>
    <link href="https://yuanblq.github.io/2017/08/20/flask-celery/"/>
    <id>https://yuanblq.github.io/2017/08/20/flask-celery/</id>
    <published>2017-08-20T05:13:08.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>开发环境<br>flask 0.12.2、celery 4.1.0、redis 3.2.8</p>
</blockquote>
<p>进入虚拟环境，安装依赖：</p>
<ul>
<li>flask: pip install flask</li>
<li>celery: pip install celery</li>
<li>redis: sudo apt-get install redis-server</li>
<li>redis Python驱动包：pip install redis</li>
</ul>
<a id="more"></a>
<h2 id="配置-flask-主页路由"><a href="#配置-flask-主页路由" class="headerlink" title="配置 flask 主页路由"></a>配置 flask 主页路由</h2><p>创建项目文件夹:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir pro_demo</div></pre></td></tr></table></figure></p>
<p>创建 app 文件夹，以及 app/__init__.py、app/views.py 和 run.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># views.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line">flask_app.debug = <span class="keyword">True</span></div><div class="line">flask_app.run()</div></pre></td></tr></table></figure>
<h2 id="查看网页"><a href="#查看网页" class="headerlink" title="查看网页"></a>查看网页</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python run.py</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div><div class="line"> * Restarting with <span class="built_in">stat</span></div><div class="line"> * Debugger is active!</div><div class="line"> * Debugger PIN: 906-478-811</div></pre></td></tr></table></figure>
<p>在浏览器输入 127.0.0.1:5000，就会看见熟悉的“Hello world!”了。</p>
<h2 id="集成-celery"><a href="#集成-celery" class="headerlink" title="集成 celery"></a>集成 celery</h2><p>在 flask 中 celery 的简单使用很容易，不需要安装第三方插件。</p>
<h3 id="添加-celery-代码"><a href="#添加-celery-代码" class="headerlink" title="添加 celery 代码"></a>添加 celery 代码</h3><p>在 __init__.py 中添加我们的 celery 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line"></div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line">celery_app = Celery(</div><div class="line">	flask_app.name,</div><div class="line">	broker=<span class="string">"redis://localhost:6379/2"</span>,</div><div class="line">	backend=<span class="string">"redis://localhost:6379/3"</span>,</div><div class="line">	)</div><div class="line">celery_app.conf.update(flask_app.config)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure></p>
<p>其中 <code>broker</code> 中间人用 redis 的 2 号数据库，<code>backend</code> 结果存储在 redis 的 3 号数据库，当然你可以按自己需要选择其他数据库，不过 celery 官方推荐使用 RabbitMQ 和 Redis，如果使用其他数据库，官方不保证你会遇到什么 bug。</p>
<h3 id="添加-control-代码"><a href="#添加-control-代码" class="headerlink" title="添加 control 代码"></a>添加 control 代码</h3><p>新建 <code>control.py</code> 文件，并在 <code>control.py</code> 中添加我们的耗时操作任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># control.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> celery_app</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="meta">@celery_app.task</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_work</span><span class="params">(how_long=<span class="number">2</span>)</span>:</span></div><div class="line">	time.sleep(how_long)</div><div class="line">	print(<span class="string">"耗时任务已完成！"</span>)</div></pre></td></tr></table></figure>
<p>这里我们使用 <code>time.sleep()</code> 来模拟耗时任务。</p>
<h3 id="调用耗时任务"><a href="#调用耗时任务" class="headerlink" title="调用耗时任务"></a>调用耗时任务</h3><p>最后在我们的 view 视图中调用我们的耗时任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> control</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">"Hello world!"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/work/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></div><div class="line">	control.long_time_work.delay(<span class="number">5</span>)</div><div class="line">	<span class="keyword">return</span> <span class="string">"long time work!"</span></div></pre></td></tr></table></figure>
<h3 id="启动-celery"><a href="#启动-celery" class="headerlink" title="启动 celery"></a>启动 celery</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ celery -A app worker <span class="_">-l</span> info</div></pre></td></tr></table></figure>
<p>现在我们启动 flask 服务器，在浏览器中输入 <code>127.0.0.1:5000/work/</code>，我们发现页面会马上显示 <code>long time work</code>，不会阻塞 5 秒才返回响应。</p>
<p>5 秒之后，我们会在 celery 的终端看到任务完成打印的消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2017-08-20 12:37:35,528: INFO/MainProcess] Received task: app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1]  </div><div class="line">[2017-08-20 12:37:40,533: WARNING/ForkPoolWorker-4] 耗时任务已完成！</div><div class="line">[2017-08-20 12:37:40,540: INFO/ForkPoolWorker-4] Task app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1] succeeded <span class="keyword">in</span> 5.00878114400075s: None</div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开发环境&lt;br&gt;flask 0.12.2、celery 4.1.0、redis 3.2.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入虚拟环境，安装依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flask: pip install flask&lt;/li&gt;
&lt;li&gt;celery: pip install celery&lt;/li&gt;
&lt;li&gt;redis: sudo apt-get install redis-server&lt;/li&gt;
&lt;li&gt;redis Python驱动包：pip install redis&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="celery" scheme="https://yuanblq.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅓</title>
    <link href="https://yuanblq.github.io/2017/08/12/channel-part4/"/>
    <id>https://yuanblq.github.io/2017/08/12/channel-part4/</id>
    <published>2017-08-12T09:33:28.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始使用-Channels"><a href="#开始使用-Channels" class="headerlink" title="开始使用 Channels"></a>开始使用 Channels</h2><p>（确保你已经<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 Channels&nbsp;">&nbsp;安装了 Channels&nbsp;</a>）</p>
<p>我们先来写几个消费者。如果你还不了解，可以去看看<a href="/2017/08/06/channel-part2/" title="&nbsp;Channels 的概念&nbsp;">&nbsp;Channels 的概念&nbsp;</a>，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。</p>
<h2 id="第一个消费者"><a href="#第一个消费者" class="headerlink" title="第一个消费者"></a>第一个消费者</h2><p>当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ <code>http.request</code> channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 <code>runserver</code> 一样）</p>
<p>作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。</p>
<a id="more"></a>
<p>创建一个新项目，一个新 app，然后把这些代码添加到 app 的 <code>consumer.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="keyword">from</span> channels.handler <span class="keyword">import</span> AsgiHandler</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 生成标准的 HTTP response 响应 - 直接访问 ASGI 的 path 属性</span></div><div class="line">    response = HttpResponse(<span class="string">"Hello world! You asked for %s"</span> % message.content[<span class="string">'path'</span>])</div><div class="line">    <span class="comment"># 将 response 编码成 message 格式（ASGI）</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>我们发送的 message 必须是序列化的 JSON 对象，request 和 response 的 message 是 key-value 的键值对形式。你可以从 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI 规范</a>中查询更多细节，但你无需过多的关注；只需要知道有一个 <code>AsgiRequest</code> 类将 ASGI 转换成 Django 的 request 对象（上面已经用到了）。通常，当你使用普通的 views 视图时， 所有的事 Django 内置的代码都帮你做好了。</p>
<p>现在我们要再做些事，告诉 Django 这个消费者应该和哪个 <code>http.request</code> channel 绑定，而不是和 Django 的 view 视图系统绑定。这个需要在 settings 文件中配置，我们需要定义我们名为 <code>default</code> 的 channel 层以及它的路由。</p>
<p>channel 的路由配置和 URL 的路由配置有点像。channel 和 consumer 之间以字典的形式映射。比如像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># settings.py</span></div><div class="line">CHANNEL_LAYERS = &#123;</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgiref.inmemory.ChannelLayer"</span>,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"http.request"</span>, <span class="string">"myapp.consumers.http_consumer"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>这里大多数例子，使用的是“in memory” channel 层。方便刚开始使用 channel，但是无法实现跨进程的 channel 传输，而且只能用 <code>runserver</code>。在生产环境中，你需要选择其他的 backend 后端（后面将会讨论）。</p>
</blockquote>
<p>如你所见，这有点像 Django 的 <code>DATABASES</code> 配置，有一个名为 <code>default</code> 的 channel 层。每个层都需要一个 channel 层类、一些配置（如果该层需要的话）以及一个路由调度器，用来指向包含路由配置的列表。推荐你起名为 <code>routing.py</code> 并且放在你项目 <code>urls.py</code> 的旁边，但你也可以随便放在哪个地方，只要路径不错。</p>
<p>如果你用 <code>python manage.py runserver</code> 启动，然后在浏览器输入 <code>http://localhost:8000</code>，你会看见，一个 Django 页面，那就说明一切正常。如果你看不到响应，检查一下你是否正确<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 channels&nbsp;">&nbsp;安装了 channels&nbsp;</a>。</p>
<p>现在看起来没啥值得激动的地方，原生 HTTP 响应 Django 早就能做了。我们来试试 WebSocket，再做一个简单的聊天服务器～</p>
<p>我们先只做一个 echo 的简单服务器，将客户端发来的消息直接原样发回。虽然没啥用，不过用来入门 channel 还是不错的。</p>
<p>删除之前的 consumer 和 routing 路由 —— 现在开始，如果你不在 consumer 中特别指定去处理 <code>http.request</code> 那么，Django view 视图来处理 HTTP 请求。然后 consumer 来处理 WebSocket：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># ASGI WebSocket 包 —— 接收和发送消息的类型都有一个 “text” 键名</span></div><div class="line">    <span class="comment"># 对应他们的文本数据</span></div><div class="line">    message.reply_channel.send(&#123;</div><div class="line">        <span class="string">"text"</span>: message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>像下面，将它挂接到 <code>websocket.receive</code> channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_message</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们来看看都做了些什么。它和 <code>websocket.receive</code> channel 绑定，意味着当客户端发送一个 WebSocket 包的时候，它能收到一个 message。</p>
<p>当它收到这个 message 的时候，从中获取 <code>reply_channel</code> 属性，这是每个客户端都唯一的 response channel，然后通过 <code>send()</code> 方法把同样的内容发回给客户端。</p>
<p>运行 <code>runserver</code>，打开浏览器，进入该服务器的页面，在控制台输入以下代码来打开一个 WebSocket 连接，并发送一些数据（如果你使用的是 VM 或者类似的，你可能需要更改 socket 的地址）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该会立刻看见一个 “hello world” 的 alert。你的 message 在服务器绕了一圈又回来触发了 alert。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>现在，我们在一个真正的聊天服务器上实现我们的 echo 服务器，这样人们就可以互相聊天了。为了实现这个功能，我们需要用到 Groups，这是 Channels 的一个<a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">核心概念</a>，也是我们广播消息的基本方法。</p>
<p>为了实现这，我们要增加 <code>websocket.connect</code> 和 <code>websocket.disconnect</code> Channels 来往我们的 Groups 中添加或者移除客户端，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受进来的连接</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把他们加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>如果你重写了 connect，你需要通过 <code>accept: True</code> 来显式地接受 WebSocket 连接，当然，你也可以通过 <code>close: True</code> 来拒绝连接。</p>
</blockquote>
<p>当然，如果你读过<a href="/2017/08/06/channel-part2/" title="&nbsp;channels 概念&nbsp;">&nbsp;channels 概念&nbsp;</a>，你就知道如果添加到 groups 的 Channels 的 message 过期了，那么 Channels 也要过期（每个 Channel 的 message 都有一个过期时间，通常在 30 秒至 1 分钟，当然可以自己配置）。但是无论如何 <code>disconnect</code> 处理器都会调用。</p>
<blockquote>
<p><strong>注意：</strong><br>Channels 设计的前提是会失败的，它假设有一小部分的 message 会永远无法传送，所以所有的核心功能设计的时候都要考虑到当发送一个 message 的时候会无法传送，这样就不会使整个系统崩溃。</p>
<p>我们同样建议你也这么设计你的 app —— 不要期望 Channels 能 100% 可靠的帮你传送消息。查找每一个可能失败的地方，然后用自己用代码去处理 —— 可以是 retry 逻辑、处理部分内容或者不要同时做一些事。HTTP request 也是容易出错的，不然怎么会有人经常收到一个错误的页面！</p>
</blockquote>
<p>现在，我们来关心往 <code>chat</code> group 添加和移除 WebSocket；我们现在要做的就是 message 的发送。不像上面只是重复对话，我们要把它发送到整个 <code>Group</code> 中，也就意味着，所有添加到该 group 的客户端都能获取该消息。下边是所有的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 添加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.receive</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: <span class="string">"[user] %s"</span> % message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后，我们在路由 <code>routing.py</code> 中这么配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_add, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_add),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意，<code>http.request</code> 的路由不在这配置了 —— 如果我们不在这配，Django 将会以默认的 view 视图系统来路由 HTTP 请求，可能这就是你想要的。即使你在这配了 <code>http.request</code> 的路由，但是只匹配一部分的 path 或 method，那么其他不匹配的还是会由默认的处理器处理，也就是说还是会传到 URL 路由和 view 视图。</p>
<p>这些代码已经可以处理 chat 服务器了。现在运行 <code>runserver</code>，打开浏览器，在开发者控制台使用同样的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该能立刻看见一个“hello world” 的 alert，但这次，你可以再打开一个浏览器 tab 页，然后做同样的事，之后两个浏览器窗口都会显示 alert。任何发来的 message 都会由 <code>ws_message</code> 消费者发送到 <code>chat</code> group，然后你的浏览器 tab 页会在 connect 后加入到 <code>chat</code> group。</p>
<p>你可以在你的处理函数中加上一些 <code>print</code>，这样你或许能更理解是怎么调用的。你也可以使用 <code>pdb</code> 像普通的 Django 项目一样进行调试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始使用-Channels&quot;&gt;&lt;a href=&quot;#开始使用-Channels&quot; class=&quot;headerlink&quot; title=&quot;开始使用 Channels&quot;&gt;&lt;/a&gt;开始使用 Channels&lt;/h2&gt;&lt;p&gt;（确保你已经&lt;a href=&quot;/2017/08/07/channel-part3/&quot; title=&quot;&amp;nbsp;安装了 Channels&amp;nbsp;&quot;&gt;&amp;nbsp;安装了 Channels&amp;nbsp;&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;我们先来写几个消费者。如果你还不了解，可以去看看&lt;a href=&quot;/2017/08/06/channel-part2/&quot; title=&quot;&amp;nbsp;Channels 的概念&amp;nbsp;&quot;&gt;&amp;nbsp;Channels 的概念&amp;nbsp;&lt;/a&gt;，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。&lt;/p&gt;
&lt;h2 id=&quot;第一个消费者&quot;&gt;&lt;a href=&quot;#第一个消费者&quot; class=&quot;headerlink&quot; title=&quot;第一个消费者&quot;&gt;&lt;/a&gt;第一个消费者&lt;/h2&gt;&lt;p&gt;当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ &lt;code&gt;http.request&lt;/code&gt; channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 &lt;code&gt;runserver&lt;/code&gt; 一样）&lt;/p&gt;
&lt;p&gt;作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 3</title>
    <link href="https://yuanblq.github.io/2017/08/07/channel-part3/"/>
    <id>https://yuanblq.github.io/2017/08/07/channel-part3/</id>
    <published>2017-08-07T07:59:02.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接在 PyPI 上获取 Channels —— 安装，只需运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -U channels</div></pre></td></tr></table></figure>
<p>安装完之后，你需要把 <code>Channels</code> 添加到你 settings 的 <code>INSTALLED_APPS</code> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = [</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.sites'</span>,</div><div class="line">    ...</div><div class="line">    <span class="string">'channels'</span>,</div><div class="line">]</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>就这样！完成之后，<code>Channels</code> 会自己集成到 Django，并且接管 <code>runserver</code> 命令。详情见 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a>。</p>
<blockquote>
<p><strong>注意</strong><br>注意其他会替换/重载 <code>runserver</code> 命令的第三方 app。Channels 提供了一个独立的 <code>runserver</code> 命令，可能会引起冲突。有这么一个冲突的例子：<a href="https://github.com/evansd/whitenoise" target="_blank" rel="external">whitenoise</a> 的 <a href="https://github.com/evansd/whitenoise/issues/77" target="_blank" rel="external">whitenoise.runserver_nostatic</a>。为了解决这个问题，可以尝试把 <code>channels</code> 移到你 <code>INSTALLED——APPS</code> 的最上面，或者把其他冲突的 app 删了。</p>
</blockquote>
<h2 id="安装最新的开发版"><a href="#安装最新的开发版" class="headerlink" title="安装最新的开发版"></a>安装最新的开发版</h2><p>要想安装最新的开发版 Channels，克隆它的仓库，切换到仓库，更改仓库文件夹，然后安装到你的虚拟环境中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git@github.com:django/channels.git</div><div class="line">$ <span class="built_in">cd</span> channels</div><div class="line">$ &lt;activate your project’s virtual environment&gt;</div><div class="line">(environment) $ pip install <span class="_">-e</span> .  <span class="comment"># . 表示当前仓库</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;可以直接在 PyPI 上获取 Channels —— 安装，只需运行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install -U channels&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完之后，你需要把 &lt;code&gt;Channels&lt;/code&gt; 添加到你 settings 的 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 中：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;INSTALLED_APPS = [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.auth&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.contenttypes&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sessions&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sites&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;channels&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 2</title>
    <link href="https://yuanblq.github.io/2017/08/06/channel-part2/"/>
    <id>https://yuanblq.github.io/2017/08/06/channel-part2/</id>
    <published>2017-08-06T13:28:37.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channels-概念"><a href="#Channels-概念" class="headerlink" title="Channels 概念"></a>Channels 概念</h2><p>Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。</p>
<p>在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。</p>
<p>除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。</p>
<p>它将 Django 的运行模式从简单的 <code>response to request</code>请求响应，改变为 <code>event oriented</code>面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。</p>
<p>我们先来看看什么是 channels 吧。</p>
<a id="more"></a>
<h2 id="什么是-channel？"><a href="#什么是-channel？" class="headerlink" title="什么是 channel？"></a>什么是 channel？</h2><p>该系统的核心就是一个叫做 channel 的数据结构。什么是 channel？这是一个有序的、先进先出的、有时效的以及一次只能传递给一个监听器的队列。</p>
<p>你可以认为它就是个任务队列 —— 生产者将消息存入 channel，然后给监听该 channel 的一个消费者监听器。</p>
<p>“最多一次”假设，要么一个消费者获得该消息，要么就没人获得消息（假设 channel 实现崩溃了）。“至少一次”假设，通常一个消费者获得消息，但当崩溃的时候，不止一个消费者收到消息，这不是我们想要的。</p>
<p>还有其他一些限制 —— 消息必须是序列化类型，并在指定大小以内。不过在你使用高级用法之前，这些实现细节都不需要你担心。</p>
<p>channels 有一定的容量，所有生产者可以先往一个 channel 中写入大量信息，消费者可以之后再去消费这些队列消息。</p>
<p>如果你在 <a href="https://gobyexample.com/channels" target="_blank" rel="external">Go 语言中使用过 channels</a>：Go channels 和 Django 的差不多。主要的不同点是，Django 的 channels 是网络透明的，我们提供的 channel，消费者和不同进程或者不同服务器的生产者都可以通过网络访问。</p>
<p>在一个网络中，我们根据 channel 的唯一字符串名字来区分 channels —— 你可以把消息发送到，连接在同一 channel 后端的，来自任何服务器的任一已命名的 channel 上。如果两台不同的服务器都往 <code>http.request</code> channel 上写，那么他们写的就是同一个 channel。</p>
<h2 id="如何使用-channels？"><a href="#如何使用-channels？" class="headerlink" title="如何使用 channels？"></a>如何使用 channels？</h2><p>所以，Django 到底该如何使用 channels 呢？在 Django 中，你可以写一个函数来消费一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>然后在 channel routing 路由中给它指定一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">channel_routing = &#123;</div><div class="line">    <span class="string">"some-channel"</span>: <span class="string">"myapp.consumer.my_consumer"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说 channel 中的每一个 message，Django 都会通过消息对象来调用消费者函数（message 对象有 <code>content</code> 属性，是一个字典，还有一个 <code>channel</code> 属性，就是该消息所在的 channel）。</p>
<p>与传统的 request—response 模式不同，channels 将 Django 改为 worker 模式运行 —— 它监听消费者指定的所有 channels，当有消息来时，就运行相应的消费者函数。所以，不单单在绑定的 WSGI 服务器上运行单个进程，Django 运行了三个不同的层：</p>
<ul>
<li>interface servers，Django 和外部网络通信的层。包括一个 WSGI 适配器和一个独立的 WebSocket 服务器，具体细节看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#run-interface-servers" target="_blank" rel="external">Run interface servers</a>。</li>
<li>channel backend，是可插拔的 Python 代码和数据存储库（比如 Redis 或者共享的内存段）负责传输 messages。</li>
<li>workers，监听所有相关的 channels，当 message 准备好的时候，运行对应的消费者函数。</li>
</ul>
<p>这看起来可能比较简单，但这是设计的一部分。我们只是引入一个轻量的比 Django 视图更复杂、抽象的函数，而不是采用一个完整的异步框架。</p>
<p>一个 view 视图接受 request 参数，然后返回一个 response 响应；一个 consumer 消费者接受 channel message 参数，并可以向其他通道写消息。</p>
<p>现在，我们做一个通道来接受 request 请求（叫做 <code>http.request</code>），做一个给每个客户端 response 响应的通道（比如 <code>http.response.o4F2h2Fd</code>），response 响应通道是 request 消息的一个属性（<code>reply_channel</code>）。这样的话，一个 view 视图差不多就是一个 consumer 例子了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 message 中将 request 解码成一个 Request 对象</span></div><div class="line">    django_request = AsgiRequest(message)</div><div class="line">    <span class="comment"># 运行 view</span></div><div class="line">    django_response = view(django_request)</div><div class="line">    <span class="comment"># 将 response 转成 message 格式</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(django_response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p>实际上，这就是 channel 所干的活。interface 服务器将来自外部的连接（HTTP、WebSocket 等等）转换成 channel 中的 message，然后你写 worker 代码去处理这些消息。通常普通的 HTTP 由 Django view/template 内置的 consumer 处理，但你也可以重写添加功能。</p>
<p>然而，关键部分是你可以对任何事件做出响应。你可以触发模型保存、其他输入的 message 或者来自 view 和 form 的代码。解决推送形式的代码 —— 用 WebSocket 或者 HTTP 长轮询通知客户端以实时的方式改变。</p>
<h2 id="Channel-类型"><a href="#Channel-类型" class="headerlink" title="Channel 类型"></a>Channel 类型</h2><p>在这个模型中只要有两种使用方法。第一个也是最主要的一个，给消费者分发任务 —— 添加到 channel 中的消息，任何一个 worker 都能从中取出来给消费者。</p>
<p>第二种类型的 channel 是用来回复的。值得注意的是，这些只监听一个东西 —— interface server。每个回复通道都是独立命名的，当它的客户端结束时会路由回 interface server。</p>
<p>他们之间的差异不是很大 —— 他们都要遵守 channel 的核心定义。但是当扩展规模时就会有一些差异。很高兴，在服务器和工作群集中能随机负载均衡 —— 毕竟任一 worker 都可以处理 message —— 但是 response channel 要把 message 发送到他们监听的 channel 服务器中。</p>
<p>所以，channel 会分这两种类型，然后在名字中带有 <code>!</code> 的表示回复通道 —— 比如 <code>http.response!f5G3fE21f</code>。普通的 channel 没有这个字符，但是只能包含字母数字下划线，并且不能超过 200 个字符。</p>
<p>只是实现后端的话不需要懂 —— 毕竟只有在扩展的时候才会用到。更多关于扩展以及在写后端或 interface server 的时候如何处理 channel 类型的信息，请看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#scaling-up" target="_blank" rel="external">Scaling Up</a>。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>因为 channels 只接通一个接听器，他们不能进行广播。如果你想在一组客户端中随意发送消息，你需要去跟踪这些回复通道。</p>
<p>如果我有一个实时博客，当我保存了一个新的博客，然后我想推送时，我可以给 <code>post_save</code> 信号注册一个处理器，然后给一系列 channel （本处使用 Redis）发送更新消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">redis_conn = redis.Redis(<span class="string">"localhost"</span>, <span class="number">6379</span>)</div><div class="line"></div><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 循环所有的回复通道，然后发送更新消息</span></div><div class="line">    <span class="keyword">for</span> reply_channel <span class="keyword">in</span> redis_conn.smembers(<span class="string">"readers"</span>):</div><div class="line">        Channel(reply_channel).send(&#123;</div><div class="line">            <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">                <span class="string">"id"</span>: instance.id,</div><div class="line">                <span class="string">"content"</span>: instance.content</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到读者集合</span></div><div class="line">    redis_conn.sadd(<span class="string">"readers"</span>, message.reply_channel.name)</div></pre></td></tr></table></figure>
<p>尽管这能工作，但是有一个小问题 —— 当他们断开连接时，我们从没有把人从 <code>readers</code> 集合中删除。我们可以添加一个消费者去监听 <code>websocket.disconnect</code> 来完成这事，但是我们也需要设置过期时间，避免在发出 disconnect 信号前 interface server 突然退出或者断电。</p>
<p>因为 channel 的基本设计是无状态的，如果一个 interface server 消失，channel 服务器没有“关闭”一个通道这概念 —— 毕竟，通道只是用来传输消息的。</p>
<p>我们没必要关心客户端断开连接后有没有把消息发送给群组 —— 毕竟它都已经断开了。我们关心的是这些不存在的客户端是否会扰乱我们的 channel 后端（可能最终回复通道的名字会起冲突，并把消息发送给不是我们想要的客户端，尽管发生这个情况至少得到几周后）。</p>
<p>现在，我们可以回到上面的例子，并且增加过期集合以及跟踪过期时间，但是这个做的一个框架是什么样的？Channel 以一个叫做 Group 的核心概念来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"id"</span>: instance.id,</div><div class="line">            <span class="string">"content"</span>: instance.content</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到 reader group</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).add(message.reply_channel)</div><div class="line">    <span class="comment"># 接受 connection request 请求</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 reader group 移除</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>Group 不止拥有自己的 <code>send()</code> 方法，他还能自动管理 group 成员的过期事务 —— 当channel 由于非消费开始有过期消息时，我们将它从 group 中移除。当然你仍可以在 disconnect 的时候将它从 group 中移除；过期的代码只是为了防止由于某些原因 disconnect 消息不起作用。</p>
<p>Group 通常只对回复通道有用（包含 <code>!</code> 字符的那个），因为它们对于每个客户端都是唯一的，但如果你愿意的话也可以用于普通 channel。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>这只是高层视角下对 channel 和 group 的概览，以及你在一开始该如何考虑使用。记住，Django 虽然提供了一些通道，但你可以自定义自己的 consumer 和 channel。</p>
<p>有件事时 channel 无法做到的，就是保证传输。如果你需要确保任务完成，使用一个系统，在失败的时候重新尝试（比如 celery）或者用一个管理命令来检查是否完成，如果没有完成就重新提交消息（你自己的重试逻辑）。</p>
<p>在接下来的文档中，我们将覆盖更多关于 channel 的一些任务，但现在，我们继续 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a> 然后写一些代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Channels-概念&quot;&gt;&lt;a href=&quot;#Channels-概念&quot; class=&quot;headerlink&quot; title=&quot;Channels 概念&quot;&gt;&lt;/a&gt;Channels 概念&lt;/h2&gt;&lt;p&gt;Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。&lt;/p&gt;
&lt;p&gt;在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。&lt;/p&gt;
&lt;p&gt;除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。&lt;/p&gt;
&lt;p&gt;它将 Django 的运行模式从简单的 &lt;code&gt;response to request&lt;/code&gt;请求响应，改变为 &lt;code&gt;event oriented&lt;/code&gt;面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。&lt;/p&gt;
&lt;p&gt;我们先来看看什么是 channels 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 1</title>
    <link href="https://yuanblq.github.io/2017/08/04/channel-part1/"/>
    <id>https://yuanblq.github.io/2017/08/04/channel-part1/</id>
    <published>2017-08-04T11:22:14.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Channels？"><a href="#什么是-Channels？" class="headerlink" title="什么是 Channels？"></a>什么是 Channels？</h2><p>通过 Channels，给 Django 添加了一个新的<a href="http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels" target="_blank" rel="external">传输中间层</a>，通过该层，能实现两个重要的特性：</p>
<ul>
<li><a href="http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example" target="_blank" rel="external">像普通 view 视图一样</a>，处理 WebSocket</li>
<li>作为 Django 的一部分，在同样的服务器中，能运行后台任务</li>
</ul>
<p>当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。</p>
<a id="more"></a>
<h2 id="如何使用呢？"><a href="#如何使用呢？" class="headerlink" title="如何使用呢？"></a>如何使用呢？</h2><p>他将 Django 的处理过程分成了两类：</p>
<ul>
<li>一是处理 HTTP 和 WebSocket</li>
<li>另一个是运行 view 视图函数、websocket 处理器和后台任务（consumers 消费者）</li>
</ul>
<p>他们通过一个叫 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的协议通信。它和 WSGI 很相似，不过 ASGI 能兼容更多协议类型。</p>
<p>Channels 不会往你的 Django 代码中引入 asyncio、gevent 或者其他任何异步代码。你的所有业务逻辑都是以同步的方式运行在工作进程/线程。</p>
<h2 id="我要改变-Django-的运行方式吗？"><a href="#我要改变-Django-的运行方式吗？" class="headerlink" title="我要改变 Django 的运行方式吗？"></a>我要改变 Django 的运行方式吗？</h2><p><strong>不</strong>，所有的额外工作都完全是可选的。如果你愿意，你可以将运行在 WSGI 服务器下的 Django 更改为如下运行方式：</p>
<ul>
<li>一个 ASGI 服务器，你可能会选择 <a href="http://github.com/django/daphne/" target="_blank" rel="external">Daphne</a></li>
<li>Django 的工作服务器，通过 <code>manage.py runworker</code> 来使用</li>
<li>用来路由 ASGI 请求的东西，比如 Redis</li>
</ul>
<p>当你使用 Channels 时，如果默认把所有的 HTTP 请求都路由给 Django view 视图系统，那它就和之前几乎没有任何差异。</p>
<h2 id="Channels-还能给我什么惊喜？"><a href="#Channels-还能给我什么惊喜？" class="headerlink" title="Channels 还能给我什么惊喜？"></a>Channels 还能给我什么惊喜？</h2><p>还包括如下特性：</p>
<ul>
<li>同一时刻，支持上千个简单的 HTTP 长轮询</li>
<li>对于 websocket，提供完整的 session 和 auth 支持</li>
<li>对于 websocket，基于站点 cookie 自动完成用户登录</li>
<li>对于大量的触发事件，拥有内置 primitive 支持（聊天、实时博客…）</li>
<li>工作服务不停，浏览器暂停的零停机部署</li>
<li>基于 per-URL 的可选低级 HTTP 控制</li>
<li>可以扩展到其他协议或事件源（比如：WebRTC、原生 UDP、SMS）</li>
</ul>
<h2 id="能扩展吗？"><a href="#能扩展吗？" class="headerlink" title="能扩展吗？"></a>能扩展吗？</h2><p><strong>当然可以，</strong>你可以运行任意数量的协议服务（用于同时处理 HTTP 和 WebSocket）和工作服务（用来运行你的 Django 代码）来满足你的使用案例。</p>
<p>ASGI 规范这两个部件之间插入允许大量的不同功能特性的 channel 层。而且它被设计用来支持简单分片以及使用自己的协议和服务器运行单独的集群。</p>
<h2 id="为什么不采用我最喜欢的消息队列？"><a href="#为什么不采用我最喜欢的消息队列？" class="headerlink" title="为什么不采用我最喜欢的消息队列？"></a>为什么不采用我最喜欢的消息队列？</h2><p>Channel 的设计目的优先于低延迟（目标是几毫秒），并且超过保证传送的高吞吐量，这与某些消息队列设计不匹配。</p>
<p>一些像<a href="http://channels.readthedocs.io/en/latest/getting-started.html#enforcing-ordering" target="_blank" rel="external">保证消息顺序</a>的特性会降低性能，但它能使它更像个消息队列。</p>
<h2 id="我需要把我所有的代码都变成异步吗？"><a href="#我需要把我所有的代码都变成异步吗？" class="headerlink" title="我需要把我所有的代码都变成异步吗？"></a>我需要把我所有的代码都变成异步吗？</h2><p>不，如果没有任何 socket 或 事件循环阻塞，你的代码都可以同步运行。你也可以在一些 Django 的 view 视图或 channel 的 consumer 消费者函数中使用异步代码 —— 比如，并行获取大量 URL，但这不会影响整个站点的部署。</p>
<h2 id="Channel-支持哪些-Django-版本？"><a href="#Channel-支持哪些-Django-版本？" class="headerlink" title="Channel 支持哪些 Django 版本？"></a>Channel 支持哪些 Django 版本？</h2><p>你可以在 Django &gt;= 1.8 的版本上将 Channels 最为一个库来安装。另外，它可能需要一些额外的依赖，不过你都可以通过 <code>pip</code> 安装。</p>
<p>一开始的时候，Channels 并不在 Django 的核心功能中，不过自从 2016.9 月以后，它就成为了 Django 的官方项目。更多关于 Channels 被采纳为 官方项目的信息可以从 <a href="https://www.djangoproject.com/weblog/2016/sep/09/channels-adopted-official-django-project/" target="_blank" rel="external">Django blog</a> 中查询。</p>
<h2 id="接下来我该读什么？"><a href="#接下来我该读什么？" class="headerlink" title="接下来我该读什么？"></a>接下来我该读什么？</h2><p>首先阅读关于 <a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">Channel 的一些概念</a>，然后继续阅读我们的<a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">示例教程</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Channels？&quot;&gt;&lt;a href=&quot;#什么是-Channels？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Channels？&quot;&gt;&lt;/a&gt;什么是 Channels？&lt;/h2&gt;&lt;p&gt;通过 Channels，给 Django 添加了一个新的&lt;a href=&quot;http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels&quot;&gt;传输中间层&lt;/a&gt;，通过该层，能实现两个重要的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example&quot;&gt;像普通 view 视图一样&lt;/a&gt;，处理 WebSocket&lt;/li&gt;
&lt;li&gt;作为 Django 的一部分，在同样的服务器中，能运行后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part4</title>
    <link href="https://yuanblq.github.io/2017/07/31/asyncio4/"/>
    <id>https://yuanblq.github.io/2017/07/31/asyncio4/</id>
    <published>2017-07-31T07:08:14.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同线程的事件循环"><a href="#不同线程的事件循环" class="headerlink" title="不同线程的事件循环"></a>不同线程的事件循环</h2><p>通过前面的介绍，我们现在能在单线程中实现多协程的工作。</p>
<p>这节就说说怎么在多线程中管理协程。</p>
<p>对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work start --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(now() - start))</div></pre></td></tr></table></figure>
<pre><code>TIME: 0.0023021697998046875
More work start --&gt; 6
Finished more work 6
More work start --&gt; 3
Finished more work 3
</code></pre><p>可见，当前线程不会阻塞。新的线程会按顺序执行 <code>call_soon_threadsafe()</code> 方法中注册的函数，因为注册的方法不是协程，所以新开的线程大概会执行 6+3 s。</p>
<p>那么，多线程实现协程的过程大致也是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line">    </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    print(<span class="string">'&#123;&#125; Done after &#123;&#125;s'</span>.format(x, x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">6</span>), new_loop)</div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">3</span>), new_loop)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>TIME:  0.0006730556488037109
More work --&gt; 6
More work --&gt; 3
3 Done after 3s
6 Done after 6s
</code></pre><p>由于我们在子线程开启的是协程任务，所以子线程大概耗时 6s。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不同线程的事件循环&quot;&gt;&lt;a href=&quot;#不同线程的事件循环&quot; class=&quot;headerlink&quot; title=&quot;不同线程的事件循环&quot;&gt;&lt;/a&gt;不同线程的事件循环&lt;/h2&gt;&lt;p&gt;通过前面的介绍，我们现在能在单线程中实现多协程的工作。&lt;/p&gt;
&lt;p&gt;这节就说说怎么在多线程中管理协程。&lt;/p&gt;
&lt;p&gt;对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part3</title>
    <link href="https://yuanblq.github.io/2017/07/30/asyncio3/"/>
    <id>https://yuanblq.github.io/2017/07/30/asyncio3/</id>
    <published>2017-07-30T03:27:31.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="停止协程"><a href="#停止协程" class="headerlink" title="停止协程"></a>停止协程</h2><p><code>Future</code> 对象有几种状态：</p>
<ul>
<li>pending</li>
<li>running</li>
<li>done</li>
<li>cancelled</li>
</ul>
<p><code>Future</code> 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<h3 id="逐个停止"><a href="#逐个停止" class="headerlink" title="逐个停止"></a>逐个停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</div><div class="line">        print(task.cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;wait() running at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:355&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
True
True
True
TIME:  1.8798322677612305
</code></pre><p><code>True</code> 表示取消成功。</p>
<p>上述方法是逐个 <code>cancel</code>。也可以像之前提到的，把所有的 task 封装在一个函数中，这样，该函数就相当于是最外面的一个 task，那么可以对该函数处理：</p>
<h3 id="打包停止"><a href="#打包停止" class="headerlink" title="打包停止"></a>打包停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</div><div class="line">        print(<span class="string">'Task result: '</span>, task.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line">task = asyncio.ensure_future(main())</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(task)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    print(asyncio.gather(*asyncio.Task.all_tasks()).cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line">    </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;main() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:17&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
TIME:  0.649970531463623
</code></pre><p>到目前为止，我们已经能够简单地开启多个协程，管理多个协程，可是，如果一个协程耗时过长，那么整个线程依旧会阻塞，这时我们只有开启多线程或者多进程来实现并行操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;停止协程&quot;&gt;&lt;a href=&quot;#停止协程&quot; class=&quot;headerlink&quot; title=&quot;停止协程&quot;&gt;&lt;/a&gt;停止协程&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象有几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pending&lt;/li&gt;
&lt;li&gt;running&lt;/li&gt;
&lt;li&gt;done&lt;/li&gt;
&lt;li&gt;cancelled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part2</title>
    <link href="https://yuanblq.github.io/2017/07/29/asyncio2/"/>
    <id>https://yuanblq.github.io/2017/07/29/asyncio2/</id>
    <published>2017-07-29T01:14:37.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h2><p>要想使用 <code>asyncio</code> 实现异步，和 <code>gevent</code> 差不多，都需要相应的代码支持。<code>gevent</code> 是通过打上“猴子补丁”来实现的，而 <code>asyncio</code> 和 <code>yield from</code> 有着千丝万缕的关系，所以先实现就比较简单了。</p>
<p>你可以自己用 <code>yield from</code> 写个协程方法，要么就只能用用别人实现的协程模块。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment"># 完成一个任务打印一个</span></div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    task.add_done_callback(done_callback)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 将协程 task 任务列表添加到事件循环中</span></div><div class="line"><span class="comment"># 这两种方法都能实现添加事件循环</span></div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="comment"># loop.run_until_complete(asyncio.gather(*tasks))</span></div><div class="line"></div><div class="line"><span class="comment"># 最后一个任务完成的时候一起打印</span></div><div class="line"><span class="comment"># for task in tasks:</span></div><div class="line"><span class="comment">#     print("Task result: ", task.result())</span></div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Callback:  work 2 Done after 2s
Callback:  work 3 Done after 3s
Callback:  work 4 Done after 4s
TIME:  4.004777193069458
</code></pre><p>总计花了 4s 多点的时间，如果是同步的话，至少 9s。可见，我们通过 <code>asyncio</code> 实现了并发功能。</p>
<h2 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h2><p>在协程的嵌套中，如何处理协程返回的数据是件很灵活的事。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="comment"># dones, pendings = await asyncio.wait(tasks)</span></div><div class="line">    <span class="comment"># print(dones)</span></div><div class="line">    <span class="comment"># print(pendings)</span></div><div class="line">    <span class="comment"># for task in dones:</span></div><div class="line">    <span class="comment">#     print('Task result: ', task.result())</span></div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.0052490234375
</code></pre><p>在 <code>main()</code> 协程函数中，可以不直接处理结果，直接返回 <code>await</code> 内容，那么，<code>run_until_complete()</code> 将会接受返回的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">dones, pendings = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> done <span class="keyword">in</span> dones:</div><div class="line">    print(<span class="string">"Task result: "</span>, done.result())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 4 Done after 4s
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
TIME:  4.0036780834198
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(<span class="string">"Task result: "</span>, result)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.003807544708252
</code></pre><p>除此之外，还可以使用 asyncio 的 <code>as_completed()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</div><div class="line">        result = <span class="keyword">await</span> task</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.002615690231323
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步实现&quot;&gt;&lt;a href=&quot;#异步实现&quot; class=&quot;headerlink&quot; title=&quot;异步实现&quot;&gt;&lt;/a&gt;异步实现&lt;/h2&gt;&lt;p&gt;要想使用 &lt;code&gt;asyncio&lt;/code&gt; 实现异步，和 &lt;code&gt;gevent&lt;/code&gt; 差不多，都需要相应的代码支持。&lt;code&gt;gevent&lt;/code&gt; 是通过打上“猴子补丁”来实现的，而 &lt;code&gt;asyncio&lt;/code&gt; 和 &lt;code&gt;yield from&lt;/code&gt; 有着千丝万缕的关系，所以先实现就比较简单了。&lt;/p&gt;
&lt;p&gt;你可以自己用 &lt;code&gt;yield from&lt;/code&gt; 写个协程方法，要么就只能用用别人实现的协程模块。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part1</title>
    <link href="https://yuanblq.github.io/2017/07/28/asyncio1/"/>
    <id>https://yuanblq.github.io/2017/07/28/asyncio1/</id>
    <published>2017-07-28T04:59:48.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个协程"><a href="#创建一个协程" class="headerlink" title="创建一个协程"></a>创建一个协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"></div><div class="line"><span class="comment"># 定义协程函数</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">获取协程对象，协程对象的调用不会立刻执行函数</div><div class="line">协程对象需要注册到事件循环上，由事件循环调用</div><div class="line">"""</div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取事件循环对象</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 调用协程对象</span></div><div class="line">loop.run_until_complete(coroutine)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
TIME:  0.0010256767272949219
</code></pre><h2 id="创建一个-task"><a href="#创建一个-task" class="headerlink" title="创建一个 task"></a>创建一个 task</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">3</span>)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">ensure_future() 返回的也是 Furure 对象，</div><div class="line">内部同样是调用的 create_task()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">"""</div><div class="line">task = loop.create_task(coroutine)</div><div class="line"></div><div class="line">print(task)</div><div class="line">loop.run_until_complete(task)</div><div class="line">print(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt;&gt;
Waiting:  3
&lt;Task finished coro=&lt;do_some_work() done, defined at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt; result=None&gt;
TIME:  0.0009589195251464844
</code></pre><p>所谓 task 对象本质上是一个 <code>Future</code> 对象（是 <code>Future</code> 的子类）。<code>Future</code> 类保存了协程运行后的状态，用于未来获取协程的结果。</p>
<p>task 在加入事件循环之前是 pending 状态。执行完成之后为 finished 状态。</p>
<p><code>asyncio.ensure_future(coroutine)</code> 和 <code>loop.create_task(coroutine)</code> 都可以创建一个 task，<code>asyncio.ensure_future(coroutine)</code> 内部就是通过调用 <code>loop.create_task(coroutine)</code> 返回的 task 对象。</p>
<h2 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h2><p>我们修改一下 <code>do_some_work()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line">task.add_done_callback(done_callback)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  Done after 2s
TIME:  0.0015606880187988281
</code></pre><p><code>Future</code> 对象的 <code>add_done_callback()</code> 方法接受一个回调函数对象，并且会把自己也传过去。等 task 调用结束时，就可以通过 task 对象的 <code>result()</code> 方法获取调用返回值。</p>
<p>如果有这么一种需求，当回调的时候，我们还需要往回调函数传入多个参数。这种情况可以通过偏函数解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback_part</span><span class="params">(op, future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, op, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line">task.add_done_callback(functools.partial(done_callback_part, <span class="string">"other param"</span>))</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  other param Done after 2s
TIME:  0.00046443939208984375
</code></pre><h2 id="阻塞和-await"><a href="#阻塞和-await" class="headerlink" title="阻塞和 await"></a>阻塞和 await</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">"Task result: "</span>, task.result())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Task result:  Done after 2s
TIME:  2.0026657581329346
</code></pre><p>当 sleep 的时候，使用 <code>await</code> 让出控制权。即当程序执行到耗时操作时，使用 <code>await</code> 方法将协程的控制权让出，以便 <code>loop</code> 调用其他协程。</p>
<p>上面的例子都只有一个协程，所以看不出有什么效果。接下来我们就上多个协程瞧瞧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个协程&quot;&gt;&lt;a href=&quot;#创建一个协程&quot; class=&quot;headerlink&quot; title=&quot;创建一个协程&quot;&gt;&lt;/a&gt;创建一个协程&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; asyncio&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;now = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt;: time.time()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义协程函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_some_work&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Waiting: &#39;&lt;/span&gt;, x)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL-Redis</title>
    <link href="https://yuanblq.github.io/2017/07/26/Redis/"/>
    <id>https://yuanblq.github.io/2017/07/26/Redis/</id>
    <published>2017-07-26T06:18:49.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是键值对存储的，通过键存入的值会永久存储。<a href="http://try.redis.io/" target="_blank" rel="external">入门 Redis 最好的网站</a></p>
<h2 id="set-get"><a href="#set-get" class="headerlink" title="set / get"></a>set / get</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set name &quot;fido&quot;</div></pre></td></tr></table></figure>
<p><code>set</code> 设置键值对。然后就可以通过 <code>get</code> 键名来获取对应的键值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get name</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;fido&quot;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="del-incr-decr"><a href="#del-incr-decr" class="headerlink" title="del / incr / decr"></a>del / incr / decr</h2><p><code>del</code> : 通过键名删除对应的键值。<br><code>incr</code> : 自增键名所对应的键值（如果键名对应的键值不存在，自动设置对应的键值为 1）。<br><code>decr</code> : 自减键名所对应的键值（如果键名对应的键值不存在，自动设置对应的键值为 -1）。</p>
<p>像 <code>incr</code> 和 <code>decr</code> 这种操作明明可以通过一些简单的操作运算就能完成，为什么 Redis 还要提供这样的操作呢？</p>
<p>因为当同时操作同一个键名对应的键值时（所谓的并发），就可能会发生错误。所以像 <code>incr</code> 这种操作，在 Redis 中是 <code>atomic</code> 原子性操作，Redis 还有很多类似的操作。</p>
<h2 id="expire-ttl"><a href="#expire-ttl" class="headerlink" title="expire / ttl"></a>expire / ttl</h2><p><code>expire</code> : 设置键名的存活时间。<br><code>ttl</code> : 查询键名是否存活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) -1</div></pre></td></tr></table></figure>
<p><code>-1</code> 表示该键名永不过期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">expire name 120</div><div class="line">// 设置 name 的存活时间为 120 秒</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) 120</div></pre></td></tr></table></figure>
<p>如果 <code>ttl</code> 的键名没过期，则返回该键名还能存活的时间（秒）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 120s 后</div><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) -2</div></pre></td></tr></table></figure>
<p><code>-2</code> 表示对应的键名已过期 / 不存在。</p>
<h2 id="rpush-lpush-lrange-lpop-rpop-llen"><a href="#rpush-lpush-lrange-lpop-rpop-llen" class="headerlink" title="rpush / lpush / lrange / lpop / rpop / llen"></a>rpush / lpush / lrange / lpop / rpop / llen</h2><p>Redis 能够操作很多复杂的数据结构，比如列表：</p>
<p><code>rpush</code> : 在列表最后添加新值。<br><code>lrange</code> : 列表的切片操作。<br><code>lpop</code> : 删除列表起始值，并返回删除的值。<br><code>rpop</code> : 删除列表末尾值，并返回删除的值。<br><code>llen</code> : 返回列表长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpush friends &quot;Alice&quot;</div><div class="line">rpush friends &quot;Bob&quot;</div><div class="line">lpush friends &quot;Sam&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lrange friends 0 -1  =&gt;  1)&quot;Sam&quot; 2)&quot;Alice&quot; 3)&quot;Bob&quot;</div><div class="line">lrange friends 1 2  =&gt;  1)&quot;Alice&quot; 2)&quot;Bob&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lpop friends  =&gt;  &quot;Sam&quot;</div><div class="line">rpop friends  =&gt;  &quot;Bob&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">llen friends  =&gt;  1</div></pre></td></tr></table></figure>
<h2 id="sadd-srem-sismember-smembers-sunion"><a href="#sadd-srem-sismember-smembers-sunion" class="headerlink" title="sadd / srem / sismember / smembers / sunion"></a>sadd / srem / sismember / smembers / sunion</h2><p>在比如说，set 集合这个数据结构。集合除了无序，不重复外，其他与列表很像。</p>
<p><code>sadd</code> : 往集合中添加元素。<br><code>srem</code> : 从集合中删除元素。<br><code>sismember</code> : 测试所给的值是否在该集合中，返回 1 表示存在，0 表示不存在。<br><code>smembers</code> : 返回集合中所有元素的一个列表。<br><code>sunion</code> : 联合两个或很多个集合，并返回所有元素的一个列表。</p>
<h2 id="zadd-zrange"><a href="#zadd-zrange" class="headerlink" title="zadd / zrange"></a>zadd / zrange</h2><p>虽然集合在某些方面很便利，但是集合无法排序，所以 Redis 提供了一种有序的集合。</p>
<p>有序集合与一般的集合差别不大，只是在创建新值的时候需要制定该值相关的分数（用作排序依据）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ZADD hackers 1940 &quot;Alan Kay&quot;</div><div class="line">ZADD hackers 1906 &quot;Grace Hopper&quot;</div><div class="line">ZADD hackers 1953 &quot;Richard Stallman&quot;</div><div class="line">ZADD hackers 1965 &quot;Yukihiro Matsumoto&quot;</div><div class="line">ZADD hackers 1916 &quot;Claude Shannon&quot;</div><div class="line">ZADD hackers 1969 &quot;Linus Torvalds&quot;</div><div class="line">ZADD hackers 1957 &quot;Sophie Wilson&quot;</div><div class="line">ZADD hackers 1912 &quot;Alan Turing&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zrange hackers 2 4  =&gt;  1) &quot;Claude Shannon&quot;, 2) &quot;Alan Kay&quot;, 3) &quot;Richard Stallman&quot;</div></pre></td></tr></table></figure>
<p>切片的用法和列表很像。</p>
<h2 id="hset-hgetall-hget"><a href="#hset-hgetall-hget" class="headerlink" title="hset / hgetall / hget"></a>hset / hgetall / hget</h2><p>Redis 中有一中数据结构和字典和相似：<code>Hashes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hset user name &quot;John Smith&quot;</div><div class="line">hset user email &quot;john.smith@example.com&quot;</div><div class="line">hset user password &quot;s3cret&quot;</div></pre></td></tr></table></figure>
<p>通过 <code>hgetall</code> 获取所有的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hgetall user</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;John Smith&quot;</div><div class="line">3) &quot;email&quot;</div><div class="line">4) &quot;john.smith@example.com&quot;</div><div class="line">5) &quot;password&quot;</div><div class="line">6) &quot;s3cret&quot;</div></pre></td></tr></table></figure>
<p>或者通过 <code>hget</code> 获取单个字段的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hget user name  =&gt;  “John Smith&quot;</div></pre></td></tr></table></figure></p>
<p>hash 字段中的数字，也能像普通数字字段一样，能进行原子自增自减操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hset user visits 10</div><div class="line">hincrby user visits 1  =&gt;  11</div><div class="line">hdecrby user visits 2  =&gt;  9</div><div class="line">hdel user visits</div><div class="line">hincrby user visits 1  =&gt; 1</div></pre></td></tr></table></figure>
<pre><code>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是键值对存储的，通过键存入的值会永久存储。&lt;a href=&quot;http://try.redis.io/&quot;&gt;入门 Redis 最好的网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;set-get&quot;&gt;&lt;a href=&quot;#set-get&quot; class=&quot;headerlink&quot; title=&quot;set / get&quot;&gt;&lt;/a&gt;set / get&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;set name &amp;quot;fido&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt; 设置键值对。然后就可以通过 &lt;code&gt;get&lt;/code&gt; 键名来获取对应的键值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;get name&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot;fido&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL-MongoDB</title>
    <link href="https://yuanblq.github.io/2017/07/26/MongoDB/"/>
    <id>https://yuanblq.github.io/2017/07/26/MongoDB/</id>
    <published>2017-07-26T04:43:02.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="show-dbs-db-use-xx"><a href="#show-dbs-db-use-xx" class="headerlink" title="show dbs / db / use xx"></a>show dbs / db / use xx</h3><ul>
<li><code>show dbs</code> 显示当前所有数据库</li>
<li><code>db</code> 显示当前所选数据库</li>
<li><code>use xx</code> 选择 xx 数据库，如果当前没有该数据库，则自动创建</li>
</ul>
<h3 id="db-dropDatabase"><a href="#db-dropDatabase" class="headerlink" title="db.dropDatabase()"></a>db.dropDatabase()</h3><p>删除当前数据库</p>
<a id="more"></a>
<h2 id="集合和文档的操作"><a href="#集合和文档的操作" class="headerlink" title="集合和文档的操作"></a>集合和文档的操作</h2><h3 id="insert-save-update"><a href="#insert-save-update" class="headerlink" title="insert / save / update"></a>insert / save / update</h3><p><code>db.集合名字.insert(文档)</code><br>往该集合中插入一个文档，如果该集合不存在，会自动创建该集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.coll.insert(&#123;</div><div class="line">    name: &quot;Zhang&quot;,</div><div class="line">    age: 12,</div><div class="line">    addr: [&quot;beijng&quot;, &quot;tianjing&quot;],</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>save()</code> 方法：</p>
<ul>
<li>如果不指定 <code>_id</code> 字段，则和 <code>insert()</code> 方法一样</li>
<li>如果指定 <code>_id</code> 字段，则更新该文档的数据</li>
</ul>
<p><code>update()</code> 语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.coll.update(</div><div class="line">    &lt;query&gt;,</div><div class="line">    &lt;update&gt;,</div><div class="line">    &#123;</div><div class="line">        upsert: &lt;boolean&gt;,</div><div class="line">        multi: &lt;boolean&gt;,</div><div class="line">        writeConcern: &lt;document&gt;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li><code>query</code>：update 的查询条件，类似 sql update 中的 where</li>
<li><code>update</code>：update 的对象，类似 sql update 中的 set</li>
<li><code>upsert</code>：可选（默认 false），如果 update 的记录不存在是否将其新增进去</li>
<li><code>multi</code>：可选（默认 false），有相同的记录是否全部找出来</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
<p>比如我们通过 update() 方法更新上面的姓名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.coll.update(</div><div class="line">    &#123;&quot;name&quot;: &quot;Zhang&quot;&#125;,</div><div class="line">    &#123;$set: &#123;&quot;name&quot;: &quot;Li&quot;&#125;&#125;,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>更多实例：</p>
<p>只更新第一条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; );</div></pre></td></tr></table></figure></p>
<p>全部更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true );</div></pre></td></tr></table></figure></p>
<p>只添加第一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false );</div></pre></td></tr></table></figure></p>
<p>全部添加加进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true );</div></pre></td></tr></table></figure></p>
<p>全部更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true );</div></pre></td></tr></table></figure></p>
<p>只更新第一条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false );</div></pre></td></tr></table></figure></p>
<h3 id="find-pretty"><a href="#find-pretty" class="headerlink" title="find / pretty"></a>find / pretty</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.find()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;), &quot;name&quot; : &quot;Zhang&quot;, &quot;age&quot; : 12, &quot;addr&quot; : [ &quot;beijng&quot;, &quot;tianjing&quot; ] &#125;</div></pre></td></tr></table></figure>
<p>在 <code>find()</code> 方法后面加上 <code>pretty()</code> 则以格式化的形式，显示所查询的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find().pretty()</div><div class="line">&#123;</div><div class="line">	&quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;),</div><div class="line">	&quot;name&quot; : &quot;Zhang&quot;,</div><div class="line">	&quot;age&quot; : 12,</div><div class="line">	&quot;addr&quot; : [</div><div class="line">		&quot;beijng&quot;, </div><div class="line">        &quot;tianjing&quot;</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove()</code> 方法的基本语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.coll.remove(</div><div class="line">    &lt;query&gt;,</div><div class="line">    &#123;</div><div class="line">        justOne: &lt;boolean&gt;,</div><div class="line">        writeConcern: &lt;document&gt;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li><code>query</code>：可选，删除文档的条件</li>
<li><code>justOne</code>：可选，如果设为 true，则只删除一个文档</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
<p>我们再插入一个文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.coll.insert(&#123;</div><div class="line">    name: &quot;Wang&quot;,</div><div class="line">    age: 25,</div><div class="line">    addr: [&quot;henan&quot;, &quot;hunan&quot;],</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>使用 <code>find()</code> 查询数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;), &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 12, &quot;addr&quot; : [ &quot;beijng&quot;, &quot;tianjing&quot; ] &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59930244e81188c3e5ce8c73&quot;), &quot;name&quot; : &quot;Wang&quot;, &quot;age&quot; : 25, &quot;addr&quot; : [ &quot;henan&quot;, &quot;hunan&quot; ] &#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们移除 name 为 Zhang 的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.coll.remove(</div><div class="line">    &#123;&quot;name&quot;: &quot;zhang&quot;&#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>现在数据文档只剩下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59930244e81188c3e5ce8c73&quot;), &quot;name&quot; : &quot;Wang&quot;, &quot;age&quot; : 25, &quot;addr&quot; : [ &quot;henan&quot;, &quot;hunan&quot; ] &#125;</div></pre></td></tr></table></figure></p>
<h2 id="MongoDB-与-RDBMS-where-语句比较"><a href="#MongoDB-与-RDBMS-where-语句比较" class="headerlink" title="MongoDB 与 RDBMS where 语句比较"></a>MongoDB 与 RDBMS where 语句比较</h2><table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">范例</th>
<th style="text-align:center">RDBMS中的类似语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: &lt;value&gt;}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;name&quot;: &quot;zhang&quot;})</code></td>
<td style="text-align:center"><code>where by = &quot;zhang&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">小于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$lt: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$lt: 18}})</code></td>
<td style="text-align:center"><code>where age &lt; 18</code></td>
</tr>
<tr>
<td style="text-align:center">小于或等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$lte: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$lte: 18}})</code></td>
<td style="text-align:center"><code>where age &lt;= 18</code></td>
</tr>
<tr>
<td style="text-align:center">大于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$gt: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$gt: 18}})</code></td>
<td style="text-align:center"><code>where age &gt; 18</code></td>
</tr>
<tr>
<td style="text-align:center">大于或等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$gte: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$gte: 18}})</code></td>
<td style="text-align:center"><code>where age &gt;= 18</code></td>
</tr>
<tr>
<td style="text-align:center">不等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$ne: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$ne: 18}})</code></td>
<td style="text-align:center"><code>where age != 18</code></td>
</tr>
</tbody>
</table>
<h2 id="MongoDB-and-条件"><a href="#MongoDB-and-条件" class="headerlink" title="MongoDB and 条件"></a>MongoDB and 条件</h2><p>MongoDB 的 <code>find()</code> 方法可以传入多个键，每个键以逗号分隔：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</div></pre></td></tr></table></figure></p>
<h2 id="MongoDB-or-条件"><a href="#MongoDB-or-条件" class="headerlink" title="MongoDB or 条件"></a>MongoDB or 条件</h2><p>MongoDB or 条件使用了关键字 <code>$or</code>，语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.coll.find(&#123;$or: [&#123;key1: value1&#125;, &#123;key2: value2&#125;]&#125;).pretty()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h2&gt;&lt;h3 id=&quot;show-dbs-db-use-xx&quot;&gt;&lt;a href=&quot;#show-dbs-db-use-xx&quot; class=&quot;headerlink&quot; title=&quot;show dbs / db / use xx&quot;&gt;&lt;/a&gt;show dbs / db / use xx&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show dbs&lt;/code&gt; 显示当前所有数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db&lt;/code&gt; 显示当前所选数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use xx&lt;/code&gt; 选择 xx 数据库，如果当前没有该数据库，则自动创建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;db-dropDatabase&quot;&gt;&lt;a href=&quot;#db-dropDatabase&quot; class=&quot;headerlink&quot; title=&quot;db.dropDatabase()&quot;&gt;&lt;/a&gt;db.dropDatabase()&lt;/h3&gt;&lt;p&gt;删除当前数据库&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="MongoDB" scheme="https://yuanblq.github.io/tags/MongoDB/"/>
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-归并排序</title>
    <link href="https://yuanblq.github.io/2017/07/16/merger-sort/"/>
    <id>https://yuanblq.github.io/2017/07/16/merger-sort/</id>
    <published>2017-07-16T11:18:30.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>有很多算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决相关的若干子问题。</p>
<p>这是典型的分治法思想：将原问题分解为几个规模较小，但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
<a id="more"></a>
<p>归并排序算法完全遵循分治模式。直观上操作如下：</p>
<ul>
<li><strong>分解：</strong>分解待排序的 n 个元素的序列成各具 n/2 个元素的 2 个子序列</li>
<li><strong>解决：</strong>使用归并排序递归地排序 2 个子序列</li>
<li><strong>合并：</strong>合并两个已排序的子序列以产生已排序的答案</li>
</ul>
<p>层层往下分解的时候，当待排序的序列长度为 1 时，递归“开始回升”，这种情况下不要做任何工作，因为长度为 1 的每个序列都已排好序。</p>
<p>归并算法的关键操作是“合并”步骤中，两个已排序序列的合并。</p>
<p>回到插入排序中我们所举的扑克牌的例子，假设桌面上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶上。</p>
<p>我们希望把这两堆牌合并成单一的排好序的输出堆。我们可以这么做：</p>
<p>在牌面朝上的两堆牌的顶上选取较小的一张，将该牌从其堆中移开，并将牌面向下地放置到最终的输出堆。重复这个步骤，直到一个输出堆为空，这时，我们只需将剩余的一堆牌朝下地放置到输出堆。</p>
<p>因为我们之比较顶上的两张牌，所以合并步骤只需 O(n) 的时间。</p>
<p>下面以伪代码的形式实现上面的思想：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A: 数组  p、q、r是数组的下表，满足 p &lt;= q &lt; r</span></div><div class="line">MERAGE(A, p, q, r)</div><div class="line">n1 = q - p + <span class="number">1</span></div><div class="line">n2 = r - q</div><div class="line"><span class="comment"># let L[1, n1+1] and R[1, n2+1] be new arrays</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1):</div><div class="line">    L[i] = A[p+i<span class="number">-1</span>]</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2):</div><div class="line">    R[j] = A[q+j]</div><div class="line">L[n1+<span class="number">1</span>] = ∞</div><div class="line">R[n2+<span class="number">1</span>] = ∞</div><div class="line">i = <span class="number">1</span></div><div class="line">j = <span class="number">1</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(p, r):</div><div class="line">    <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">        A[k] = L[i]</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        A[k] = R[j]</div><div class="line">        j += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>下面为两个已排好序的列表，进行合并操作的示意图：</p>
<p><img src="/2017/07/16/merger-sort/2-3.png" alt="合并示意图"></p>
<p>然后我们把这个合并操作作为归并算法中的一个子程序来用。</p>
<p>下面过程中 <code>merger-sort(A, p, r)</code> 排序子数组 A[p..r] 中的元素。若 p &gt;= r，则该子数组最多有一个元素，所以已经排好序。否则，分解步骤简单地计算一个下标 q，将 A[p..r] 分成两个子数组 A[p..q] 和 A[q+1..r]，前者包含 n/2 个元素，后者包含 n/2 个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># merger-sort(A, p, r)</span></div><div class="line"><span class="keyword">if</span> p &lt; r:</div><div class="line">    q = (p+r) / <span class="number">2</span></div><div class="line">    <span class="comment"># 对这两数组进行归并排序</span></div><div class="line">    merger-sort(A, p, q)</div><div class="line">    merger-sort(A, q+<span class="number">1</span>, r)</div><div class="line">    <span class="comment"># 将排好序的两个数组合并</span></div><div class="line">    merger(A, p, q, r)</div></pre></td></tr></table></figure>
<p>以下是 Python 实现的完整归并算法，仅供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merger</span><span class="params">(ls, rs)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    用于合并两个列表</div><div class="line">    '''</div><div class="line">    B = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ls:</div><div class="line">            B.extend(rs)</div><div class="line">            <span class="keyword">return</span> B</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rs:</div><div class="line">            B.extend(ls)</div><div class="line">            <span class="keyword">return</span> B</div><div class="line">        <span class="keyword">if</span> ls[<span class="number">0</span>] &lt; rs[<span class="number">0</span>]:</div><div class="line">            B.append(ls.pop(<span class="number">0</span>))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            B.append(rs.pop(<span class="number">0</span>))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merger_sort</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    归并排序</div><div class="line">    '''</div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> A</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        mid = length // <span class="number">2</span></div><div class="line">    La = merger_sort(A[:mid])</div><div class="line">    Ra = merger_sort(A[mid:])</div><div class="line">    <span class="keyword">return</span> merger(La, Ra)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>]</div><div class="line">print(merger_sort(a))</div></pre></td></tr></table></figure>
<pre><code>[0, 1, 2, 3, 4, 6, 7, 7, 9]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;有很多算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决相关的若干子问题。&lt;/p&gt;
&lt;p&gt;这是典型的分治法思想：将原问题分解为几个规模较小，但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。&lt;/p&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Algorithms" scheme="https://yuanblq.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-插入排序</title>
    <link href="https://yuanblq.github.io/2017/07/03/insertion-sort/"/>
    <id>https://yuanblq.github.io/2017/07/03/insertion-sort/</id>
    <published>2017-07-02T17:15:11.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对于少量元素的排序，插入排序算是一个比较有效的算法。</p>
<p>它的执行流程和打扑克摸牌时候的插牌差不多。</p>
<p><img src="/2017/07/03/insertion-sort/2-1.png" alt="使用插入排序来排序手中扑克牌"></p>
<p>打扑克插牌的时候，首先手上没有牌，从桌上扣着的牌里不断抓取。每抓一张牌，都会与手中已有的牌进行比对，然后插入合适的位置。</p>
<a id="more"></a>
<p>上面的流程，可以用 Python 的伪代码这么表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A 为总共可以抓取的扑克牌数，四人斗地主的话，即 25 张牌</span></div><div class="line"><span class="comment"># 因为从第 2 次抓牌开始，才算进行真正的排序</span></div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">2</span>, len(A)]:</div><div class="line">    <span class="comment"># poke 为当前抓取的牌</span></div><div class="line">    poke = A[j]</div><div class="line">    <span class="comment"># 把当前抓到的牌插入之前已经排序好的牌中</span></div><div class="line">    <span class="comment"># 即，将 A[j] 插在 A[1..j-1] 的合适位置</span></div><div class="line">    <span class="comment"># 假设从小到大排序</span></div><div class="line">    <span class="comment"># 从当前牌的最后一张开始比对，如果比当前牌大，就调个个</span></div><div class="line">    i = j - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; poke:</div><div class="line">        A[i+<span class="number">1</span>] = A[i]</div><div class="line">        i = i - <span class="number">1</span></div><div class="line">    <span class="comment"># 真正的插入操作 =&gt; 将抓取的牌，插在合适的位置</span></div><div class="line">    A[i+<span class="number">1</span>] = poke</div></pre></td></tr></table></figure></p>
<p>在 for 循环中，每次迭代开始的时候，A[1, j-1] 总是已经排好序的牌，这个特性叫做循环不变式。</p>
<p>下图表明了对于 A=[5, 2, 4, 6, 1, 3] 该算法如何工作的：</p>
<p><img src="/2017/07/03/insertion-sort/2-2.png" alt="插入排序工作原理"></p>
<p>循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：</p>
<ul>
<li><strong>初始化：</strong>循环的第一次迭代之前，它为真。</li>
<li><strong>保持：</strong>如果循环在某次开始前它为真，那么下次迭代开始之前，他也为真。</li>
<li><strong>终止：</strong>在循环结束的时候，不变式所提供的特性仍未改变，该特性有助于证明算法是正确的。</li>
</ul>
<p>以下是用 Python 完整实现的代码，仅供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>]</div><div class="line">A</div></pre></td></tr></table></figure>
<pre><code>[5, 2, 4, 6, 1, 3]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort1</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</div><div class="line">        poke = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; poke:</div><div class="line">            A[i], A[i+<span class="number">1</span>] = A[i+<span class="number">1</span>], A[i]</div><div class="line">            i -= <span class="number">1</span></div><div class="line">        A[i+<span class="number">1</span>] = poke</div><div class="line">    <span class="keyword">return</span> A</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(insertion_sort1(A))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre><p>如果将插入数据和搜索数据合并到一起操作，那么代码就变成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort2</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</div><div class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] &gt; A[i]:</div><div class="line">            A[i<span class="number">-1</span>], A[i] = A[i], A[i<span class="number">-1</span>]</div><div class="line">            i -= <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> A</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(insertion_sort2(A))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;对于少量元素的排序，插入排序算是一个比较有效的算法。&lt;/p&gt;
&lt;p&gt;它的执行流程和打扑克摸牌时候的插牌差不多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/07/03/insertion-sort/2-1.png&quot; alt=&quot;使用插入排序来排序手中扑克牌&quot;&gt;&lt;/p&gt;
&lt;p&gt;打扑克插牌的时候，首先手上没有牌，从桌上扣着的牌里不断抓取。每抓一张牌，都会与手中已有的牌进行比对，然后插入合适的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Algorithms" scheme="https://yuanblq.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>名人的颜值有多高？</title>
    <link href="https://yuanblq.github.io/2017/06/22/%E5%90%8D%E4%BA%BA%E7%9A%84%E9%A2%9C%E5%80%BC%E6%9C%89%E5%A4%9A%E9%AB%98%EF%BC%9F/"/>
    <id>https://yuanblq.github.io/2017/06/22/名人的颜值有多高？/</id>
    <published>2017-06-22T14:22:37.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>玩弄微软小冰的时候发现有个颜值查询功能，作为一枚颜值正无穷的帅比简直高处不胜寒。<br>后来突发奇想：是不是要想被人民群众记住，不仅仅要有才华，而且颜值也必须得高？</p>
<a id="more"></a>
<p>通过抓取百度百科里面的500多位艺术家信息，传给微软小冰评分后得出如下的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">(&apos;安德里亚·阿诺德&apos;, &apos;9.5&apos;), (&apos;许翰英&apos;, &apos;9.4&apos;), (&apos;李国静&apos;, &apos;8.9&apos;), (&apos;让·维果&apos;, &apos;8.8&apos;),</div><div class="line"> (&apos;斯潘塞·图尼克&apos;, &apos;8.7&apos;), (&apos;缪晓铮&apos;, &apos;8.6&apos;), (&apos;叶福海&apos;, &apos;8.5&apos;), (&apos;李吉瑞&apos;, &apos;8.5&apos;),</div><div class="line"> (&apos;刘翠霞&apos;, &apos;8.5&apos;), (&apos;亨利·金&apos;, &apos;8.4&apos;), (&apos;谢冬雪&apos;, &apos;8.4&apos;), (&apos;孟科娟&apos;, &apos;8.3&apos;),</div><div class="line"> (&apos;白淑贤&apos;, &apos;8.3&apos;), (&apos;King Crimson&apos;, &apos;8.3&apos;), (&apos;魏景山&apos;, &apos;8.2&apos;), (&apos;李壬林&apos;, &apos;8.2&apos;),</div><div class="line"> (&apos;赵庭景美&apos;, &apos;8.1&apos;), (&apos;侯宗辰&apos;, &apos;8.1&apos;), (&apos;章遏云&apos;, &apos;8.1&apos;), (&apos;安波&apos;, &apos;8.0&apos;),</div><div class="line"> (&apos;黎灼灼&apos;, &apos;8.0&apos;), (&apos;杜吉刚&apos;, &apos;8.0&apos;), (&apos;王少舫&apos;, &apos;8.0&apos;), (&apos;张映哲&apos;, &apos;8.0&apos;),</div><div class="line"> (&apos;玛丽·布莱尔&apos;, &apos;7.9&apos;), (&apos;赫伯特·克格尔&apos;, &apos;7.9&apos;), (&apos;路易·德·菲耐斯&apos;, &apos;7.9&apos;), (&apos;张伐&apos;, &apos;7.8&apos;),</div><div class="line"> (&apos;朱端钧&apos;, &apos;7.8&apos;), (&apos;王泉奎&apos;, &apos;7.8&apos;), (&apos;朱利安·施纳贝尔&apos;, &apos;7.8&apos;), (&apos;石筱英&apos;, &apos;7.7&apos;),</div><div class="line"> (&apos;沈冠初&apos;, &apos;7.7&apos;), (&apos;潘亚文&apos;, &apos;7.7&apos;), (&apos;买鸿钧&apos;, &apos;7.7&apos;), (&apos;启骧&apos;, &apos;7.7&apos;),</div><div class="line"> (&apos;刘令华&apos;, &apos;7.6&apos;), (&apos;张荣培&apos;, &apos;7.6&apos;), (&apos;林忠&apos;, &apos;7.6&apos;), (&apos;胡安·格里斯&apos;, &apos;7.6&apos;),</div><div class="line"> (&apos;于万增&apos;, &apos;7.6&apos;), (&apos;邱霁&apos;, &apos;7.6&apos;), (&apos;王梦云&apos;, &apos;7.5&apos;), (&apos;贾堂霞&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;曾妮&apos;, &apos;7.5&apos;), (&apos;詹泽&apos;, &apos;7.5&apos;), (&apos;刘中华&apos;, &apos;7.5&apos;), (&apos;郑硕希&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;丁辰&apos;, &apos;7.5&apos;), (&apos;庄学本&apos;, &apos;7.5&apos;), (&apos;沙蒙&apos;, &apos;7.5&apos;), (&apos;史蒂芬·戴德利&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;江其虎&apos;, &apos;7.5&apos;), (&apos;张书范&apos;, &apos;7.5&apos;), (&apos;康斯特布尔&apos;, &apos;7.5&apos;), (&apos;钱杏邨&apos;, &apos;7.4&apos;),</div><div class="line"> (&apos;李帆&apos;, &apos;7.4&apos;), (&apos;陆小雅&apos;, &apos;7.4&apos;), (&apos;陈富瑞&apos;, &apos;7.4&apos;), (&apos;万俊彦&apos;, &apos;7.3&apos;),</div><div class="line"> (&apos;李雪峰&apos;, &apos;7.3&apos;), (&apos;胡仙&apos;, &apos;7.3&apos;), (&apos;武兆堤&apos;, &apos;7.3&apos;), (&apos;庚斯博罗&apos;, &apos;7.3&apos;),</div><div class="line"> (&apos;郑天任&apos;, &apos;7.2&apos;), (&apos;新罗山人&apos;, &apos;7.2&apos;), (&apos;让·奥诺雷·弗拉贡纳尔&apos;, &apos;7.2&apos;), (&apos;倪华&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;吴晓明&apos;, &apos;7.2&apos;), (&apos;汪燕燕&apos;, &apos;7.2&apos;), (&apos;林景亮&apos;, &apos;7.2&apos;), (&apos;朱桂芳&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;龙行&apos;, &apos;7.2&apos;), (&apos;丁力&apos;, &apos;7.2&apos;), (&apos;海兹&apos;, &apos;7.2&apos;), (&apos;柳新生&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;李瑞芳&apos;, &apos;7.2&apos;), (&apos;王凤卿&apos;, &apos;7.2&apos;), (&apos;阮兆辉&apos;, &apos;7.2&apos;), (&apos;吴宗锡&apos;, &apos;7.1&apos;),</div><div class="line"> (&apos;刘双印&apos;, &apos;7.1&apos;), (&apos;陈炳熙&apos;, &apos;7.1&apos;), (&apos;普皮·阿瓦蒂&apos;, &apos;7.1&apos;), (&apos;潘璟琍&apos;, &apos;7.1&apos;),</div><div class="line"> (&apos;曾山东&apos;, &apos;7.1&apos;), (&apos;邹为瑞&apos;, &apos;7.1&apos;), (&apos;李素雅&apos;, &apos;7.0&apos;), (&apos;卡尔·德莱叶&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;周锦堂&apos;, &apos;7.0&apos;), (&apos;罗伯特·劳森伯格&apos;, &apos;7.0&apos;), (&apos;侯永奎&apos;, &apos;7.0&apos;), (&apos;夏川&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;郭惠兰&apos;, &apos;7.0&apos;), (&apos;尼克·德雷克&apos;, &apos;7.0&apos;), (&apos;亚历山大·康斯坦丁诺维奇·格拉祖诺夫&apos;, &apos;7.0&apos;), (&apos;胡海涛&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;瞿同祖&apos;, &apos;7.0&apos;), (&apos;许磊然&apos;, &apos;7.0&apos;), (&apos;陶白莉&apos;, &apos;7.0&apos;), (&apos;蔡龙云&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;朱崇懋&apos;, &apos;7.0&apos;), (&apos;费之雄&apos;, &apos;7.0&apos;), (&apos;齐花坦&apos;, &apos;7.0&apos;), (&apos;辛沪光&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;黄虎威&apos;, &apos;6.9&apos;), (&apos;戈雅&apos;, &apos;6.9&apos;), (&apos;陈士和&apos;, &apos;6.9&apos;), (&apos;李东风&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;黄庆云&apos;, &apos;6.9&apos;), (&apos;刘江川&apos;, &apos;6.9&apos;), (&apos;刘广迎&apos;, &apos;6.9&apos;), (&apos;戴月琴&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;田纬钤&apos;, &apos;6.9&apos;), (&apos;杨和平&apos;, &apos;6.9&apos;), (&apos;马桂芬&apos;, &apos;6.9&apos;), (&apos;陈一&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;赵维莉&apos;, &apos;6.9&apos;), (&apos;杨隆寿&apos;, &apos;6.9&apos;), (&apos;黄准&apos;, &apos;6.9&apos;), (&apos;于俊波&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;李绪洪&apos;, &apos;6.9&apos;), (&apos;钟荣&apos;, &apos;6.9&apos;), (&apos;李家载&apos;, &apos;6.9&apos;), (&apos;拉斐尔·圣齐奥&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;佟长江&apos;, &apos;6.9&apos;), (&apos;尼古拉斯·卡洛维奇·梅特纳&apos;, &apos;6.9&apos;), (&apos;程玉菁&apos;, &apos;6.9&apos;), (&apos;查国钧&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;金开诚&apos;, &apos;6.8&apos;), (&apos;爱杜尔·马奈&apos;, &apos;6.8&apos;), (&apos;李延洲&apos;, &apos;6.8&apos;), (&apos;梁京武&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;尚游&apos;, &apos;6.8&apos;), (&apos;孙正阳&apos;, &apos;6.8&apos;), (&apos;康成元&apos;, &apos;6.8&apos;), (&apos;张少华&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;阿尔希波夫&apos;, &apos;6.8&apos;), (&apos;范雪朋&apos;, &apos;6.8&apos;), (&apos;梅熹&apos;, &apos;6.8&apos;), (&apos;胡朋&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;孟令云&apos;, &apos;6.8&apos;), (&apos;林耀光&apos;, &apos;6.8&apos;), (&apos;夏星&apos;, &apos;6.8&apos;), (&apos;徐正濂&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;宗其香&apos;, &apos;6.7&apos;), (&apos;张藜&apos;, &apos;6.7&apos;), (&apos;郑在石&apos;, &apos;6.7&apos;), (&apos;何迟&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;贯大元&apos;, &apos;6.7&apos;), (&apos;牟炫甫&apos;, &apos;6.7&apos;), (&apos;曹致友&apos;, &apos;6.7&apos;), (&apos;王开方&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;孙恩道&apos;, &apos;6.7&apos;), (&apos;马克辛&apos;, &apos;6.7&apos;), (&apos;孙佰钧&apos;, &apos;6.7&apos;), (&apos;康丁斯基&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;娄际成&apos;, &apos;6.7&apos;), (&apos;区志航&apos;, &apos;6.7&apos;), (&apos;刘云厚&apos;, &apos;6.7&apos;), (&apos;岑范&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;赵汝平&apos;, &apos;6.6&apos;), (&apos;佩佩·罗梅罗&apos;, &apos;6.6&apos;), (&apos;维拉斯奎兹&apos;, &apos;6.6&apos;), (&apos;雨农&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;吴兆南&apos;, &apos;6.6&apos;), (&apos;风雨同仁堂&apos;, &apos;6.6&apos;), (&apos;施本铭&apos;, &apos;6.6&apos;), (&apos;郝寿臣&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;赵开坤&apos;, &apos;6.6&apos;), (&apos;杭子和&apos;, &apos;6.6&apos;), (&apos;雅克·塔蒂&apos;, &apos;6.6&apos;), (&apos;尤金·奥曼迪&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;汪更新&apos;, &apos;6.6&apos;), (&apos;秦咏诚&apos;, &apos;6.6&apos;), (&apos;夏之秋&apos;, &apos;6.6&apos;), (&apos;洪磊&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;韩文中&apos;, &apos;6.6&apos;), (&apos;樊其辉&apos;, &apos;6.6&apos;), (&apos;张咏梅&apos;, &apos;6.6&apos;), (&apos;吴钊&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;冯梦波&apos;, &apos;6.6&apos;), (&apos;秦斌&apos;, &apos;6.6&apos;), (&apos;马云涛&apos;, &apos;6.5&apos;), (&apos;德弗乍克&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;旺忘望&apos;, &apos;6.5&apos;), (&apos;吴膺群&apos;, &apos;6.5&apos;), (&apos;李金凤&apos;, &apos;6.5&apos;), (&apos;廖辅叔&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;钟知一&apos;, &apos;6.5&apos;), (&apos;格哈德·里希特&apos;, &apos;6.5&apos;), (&apos;远藤实&apos;, &apos;6.5&apos;), (&apos;高保成&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;冯欣蕊&apos;, &apos;6.5&apos;), (&apos;萧盛萱&apos;, &apos;6.5&apos;), (&apos;甘特·萨克斯&apos;, &apos;6.5&apos;), (&apos;丁士青&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;张天志&apos;, &apos;6.5&apos;), (&apos;程熙&apos;, &apos;6.5&apos;), (&apos;艾伦·李&apos;, &apos;6.5&apos;), (&apos;梁小鸾&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;杨成兴&apos;, &apos;6.5&apos;), (&apos;爱德华·霍珀&apos;, &apos;6.5&apos;), (&apos;江和平&apos;, &apos;6.5&apos;), (&apos;李京盛&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;罗品超&apos;, &apos;6.4&apos;), (&apos;吴子复&apos;, &apos;6.4&apos;), (&apos;冷冰&apos;, &apos;6.4&apos;), (&apos;简庆福&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;罗伟&apos;, &apos;6.4&apos;), (&apos;曾竹韶&apos;, &apos;6.4&apos;), (&apos;蒲伯英&apos;, &apos;6.4&apos;), (&apos;马俊子&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;王晋元&apos;, &apos;6.4&apos;), (&apos;石少华&apos;, &apos;6.4&apos;), (&apos;王苏娅&apos;, &apos;6.4&apos;), (&apos;宋文元&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;张佩&apos;, &apos;6.4&apos;), (&apos;吴子熊&apos;, &apos;6.4&apos;), (&apos;韩中杰&apos;, &apos;6.3&apos;), (&apos;迭戈·里维拉&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;清冈纯子&apos;, &apos;6.3&apos;), (&apos;潘利国&apos;, &apos;6.3&apos;), (&apos;吕品昌&apos;, &apos;6.3&apos;), (&apos;黄绍芬&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;路易·卢米埃尔&apos;, &apos;6.3&apos;), (&apos;蒋碧微&apos;, &apos;6.3&apos;), (&apos;王西彦&apos;, &apos;6.3&apos;), (&apos;周正荣&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;李林峰&apos;, &apos;6.3&apos;), (&apos;雷开元&apos;, &apos;6.3&apos;), (&apos;华兰&apos;, &apos;6.3&apos;), (&apos;侯一波&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;陈云岗&apos;, &apos;6.2&apos;), (&apos;刘育熙&apos;, &apos;6.2&apos;), (&apos;杨振雄&apos;, &apos;6.2&apos;), (&apos;黄丰&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;陈锦芳&apos;, &apos;6.2&apos;), (&apos;谭建勋&apos;, &apos;6.2&apos;), (&apos;邱丽莉&apos;, &apos;6.2&apos;), (&apos;陈望衡&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;伦布兰特&apos;, &apos;6.2&apos;), (&apos;王向阳&apos;, &apos;6.2&apos;), (&apos;埃里克·罗麦尔&apos;, &apos;6.2&apos;), (&apos;于光华&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;唐柯&apos;, &apos;6.1&apos;), (&apos;张方明&apos;, &apos;6.1&apos;), (&apos;程继先&apos;, &apos;6.1&apos;), (&apos;叶楠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;解国平&apos;, &apos;6.1&apos;), (&apos;田春鸟&apos;, &apos;6.1&apos;), (&apos;陈云诰&apos;, &apos;6.1&apos;), (&apos;朱仲禄&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;汝龙&apos;, &apos;6.1&apos;), (&apos;燕守谷&apos;, &apos;6.1&apos;), (&apos;史晶歆&apos;, &apos;6.1&apos;), (&apos;丁荫楠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;王舜来&apos;, &apos;6.1&apos;), (&apos;袁一灵&apos;, &apos;6.1&apos;), (&apos;陈笑风&apos;, &apos;6.1&apos;), (&apos;赵建忠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;刘金彪&apos;, &apos;6.1&apos;), (&apos;许幸之&apos;, &apos;6.1&apos;), (&apos;林子杰&apos;, &apos;6.0&apos;), (&apos;马少宣&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;阿道夫·门采尔&apos;, &apos;6.0&apos;), (&apos;鲜灵霞&apos;, &apos;6.0&apos;), (&apos;崔占一&apos;, &apos;6.0&apos;), (&apos;叶竹盛&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;王沂暖&apos;, &apos;6.0&apos;), (&apos;王天华&apos;, &apos;6.0&apos;), (&apos;薛建波&apos;, &apos;6.0&apos;), (&apos;温可铮&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;黄荣&apos;, &apos;5.9&apos;), (&apos;张安邦&apos;, &apos;5.9&apos;), (&apos;景荣庆&apos;, &apos;5.9&apos;), (&apos;周来&apos;, &apos;5.9&apos;),</div><div class="line"> (&apos;马明&apos;, &apos;5.9&apos;), (&apos;魏光庆&apos;, &apos;5.9&apos;), (&apos;司徒安&apos;, &apos;5.9&apos;), (&apos;路易齐·波凯里尼&apos;, &apos;5.9&apos;),</div><div class="line"> (&apos;张子康&apos;, &apos;5.9&apos;), (&apos;侯长喜&apos;, &apos;5.8&apos;), (&apos;曾俊逸&apos;, &apos;5.8&apos;), (&apos;魏荣元&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;杨志淳&apos;, &apos;5.8&apos;), (&apos;李苦寒&apos;, &apos;5.8&apos;), (&apos;彭薇&apos;, &apos;5.8&apos;), (&apos;赵焕章&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;郭春山&apos;, &apos;5.8&apos;), (&apos;埃米尔·库斯图里卡&apos;, &apos;5.8&apos;), (&apos;胡文&apos;, &apos;5.8&apos;), (&apos;朱宪民&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;陈亚莲&apos;, &apos;5.7&apos;), (&apos;吴志辉&apos;, &apos;5.7&apos;), (&apos;张广志&apos;, &apos;5.7&apos;), (&apos;土登&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;李晓梅&apos;, &apos;5.7&apos;), (&apos;刘正亮&apos;, &apos;5.7&apos;), (&apos;李味青&apos;, &apos;5.7&apos;), (&apos;小岚云&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;刘文清&apos;, &apos;5.7&apos;), (&apos;李志明&apos;, &apos;5.7&apos;), (&apos;张越男&apos;, &apos;5.7&apos;), (&apos;细江英公&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;赵大地&apos;, &apos;5.7&apos;), (&apos;周中华&apos;, &apos;5.6&apos;), (&apos;黄里&apos;, &apos;5.6&apos;), (&apos;吴国松&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;陈志清&apos;, &apos;5.6&apos;), (&apos;赵和平&apos;, &apos;5.6&apos;), (&apos;杨希雪&apos;, &apos;5.6&apos;), (&apos;严雪亭&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;许娜&apos;, &apos;5.6&apos;), (&apos;清水裕子&apos;, &apos;5.6&apos;), (&apos;袁克平&apos;, &apos;5.6&apos;), (&apos;钱妙花&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;卢雅文&apos;, &apos;5.5&apos;), (&apos;萧润德&apos;, &apos;5.5&apos;), (&apos;袁淑梅&apos;, &apos;5.5&apos;), (&apos;李荣威&apos;, &apos;5.5&apos;),</div><div class="line"> (&apos;黄汉&apos;, &apos;5.4&apos;), (&apos;俞金喜&apos;, &apos;5.4&apos;), (&apos;周企何&apos;, &apos;5.4&apos;), (&apos;黄鹤&apos;, &apos;5.3&apos;),</div><div class="line"> (&apos;张松林&apos;, &apos;5.3&apos;), (&apos;杨少斌&apos;, &apos;5.2&apos;), (&apos;沈西蒙&apos;, &apos;5.2&apos;), (&apos;侯月秋&apos;, &apos;5.2&apos;),</div><div class="line"> (&apos;徐小香&apos;, &apos;5.2&apos;), (&apos;李鑫荃&apos;, &apos;5.2&apos;), (&apos;刘改鱼&apos;, &apos;5.2&apos;), (&apos;姬鹤武&apos;, &apos;5.2&apos;),</div><div class="line"> (&apos;李岱江&apos;, &apos;5.2&apos;), (&apos;水禾田&apos;, &apos;5.1&apos;), (&apos;姚金芬&apos;, &apos;5.1&apos;), (&apos;兹德齐斯洛·贝克辛斯基&apos;, &apos;5.1&apos;),</div><div class="line"> (&apos;李开敏&apos;, &apos;5.0&apos;), (&apos;乔慷慨&apos;, &apos;5.0&apos;), (&apos;时宜&apos;, &apos;5.0&apos;), (&apos;李克寒&apos;, &apos;5.0&apos;),</div><div class="line"> (&apos;欧有才&apos;, &apos;4.9&apos;), (&apos;张义潜&apos;, &apos;4.9&apos;), (&apos;白沉&apos;, &apos;4.9&apos;), (&apos;张猛&apos;, &apos;4.9&apos;),</div><div class="line"> (&apos;荷加斯&apos;, &apos;4.9&apos;), (&apos;尤无曲&apos;, &apos;4.9&apos;), (&apos;刘福安&apos;, &apos;4.9&apos;), (&apos;刘延广&apos;, &apos;4.8&apos;),</div><div class="line"> (&apos;吴养木&apos;, &apos;4.8&apos;), (&apos;靳景祥&apos;, &apos;4.8&apos;), (&apos;田桂凤&apos;, &apos;4.8&apos;), (&apos;李洲&apos;, &apos;4.7&apos;),</div><div class="line"> (&apos;陈永玲&apos;, &apos;4.7&apos;), (&apos;尹小芳&apos;, &apos;3.9&apos;), (&apos;黄泉福&apos;, &apos;3.4&apos;), (&apos;胡晓平&apos;, &apos;2.1&apos;),</div><div class="line"> (&apos;筱桂花&apos;, &apos;2.0&apos;)</div></pre></td></tr></table></figure>
<p>在小冰眼里</p>
<p>长得最好看的是这样的：<br><img src="/2017/06/22/名人的颜值有多高？/640.png" alt="png"></p>
<p>还有这样的:<br><img src="/2017/06/22/名人的颜值有多高？/650.png" alt="png"></p>
<p>颜值低的是这样的<br><img src="/2017/06/22/名人的颜值有多高？/660.png" alt="png"></p>
<p>显然，小冰的识别系统是有问题的。巨硬爸爸还需努力啊！</p>
<p>最后简单总结一下：颜值5.0分以下的只占了4%，虽说小冰的识别系统有些地方还需改善，但是对于正常的图片来说，识别率还是很靠谱的。嗯，现实就是这么“残酷”，一直都是“看脸”的时代。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩弄微软小冰的时候发现有个颜值查询功能，作为一枚颜值正无穷的帅比简直高处不胜寒。&lt;br&gt;后来突发奇想：是不是要想被人民群众记住，不仅仅要有才华，而且颜值也必须得高？&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://yuanblq.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
