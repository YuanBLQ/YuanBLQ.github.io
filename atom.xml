<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YuanBLQ</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanblq.github.io/"/>
  <updated>2017-06-29T09:00:21.906Z</updated>
  <id>https://yuanblq.github.io/</id>
  
  <author>
    <name>Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python 版本控制神器</title>
    <link href="https://yuanblq.github.io/2017/05/27/python-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%A5%9E%E5%99%A8/"/>
    <id>https://yuanblq.github.io/2017/05/27/python-版本控制神器/</id>
    <published>2017-05-27T08:26:32.000Z</published>
    <updated>2017-06-29T09:00:21.906Z</updated>
    
    <content type="html"><![CDATA[<p>由于 python 拥有众多的版本，以及不同模块也有不同的版本。如果每个版本之间相互都不兼容那也就无所谓什么版本控制了，可是同一机器上各个版本的 python 可以相互兼容并存，而且同一模块不同版本有时需要的 python 版本是不相同的，所以 python 的版本控制显得尤为重要。</p>
<p><code>pyenv</code> 是个 shell 脚本，能够轻松得实现各个不同版本 python 的相互间切换，而且各个版本的 python 切换不限于全局切换，甚至不同文件夹都可以拥有不同的 python 版本。</p>
<a id="more"></a>
<p>下面我们就来看看如何使用 <code>pyenv</code>。</p>
<h2 id="管理-python-版本"><a href="#管理-python-版本" class="headerlink" title="管理 python 版本"></a>管理 python 版本</h2><p>如果你既需要使用 <code>python2</code>，也需要使用 <code>python3</code>，<code>pyenv</code> 将是一个很高效的 python 版本管理工具。</p>
<p>由于 <code>pyenv</code> 是脚本插件，所以只能在类 UNIX 系统上使用。所以，如果你想在 windows 上安装，那就点击左上角去隔壁 <code>virtualenv</code> 瞧瞧。</p>
<h3 id="安装-pyenv（Ubuntu）"><a href="#安装-pyenv（Ubuntu）" class="headerlink" title="安装 pyenv（Ubuntu）"></a>安装 pyenv（Ubuntu）</h3><ol>
<li><p><strong>确定你想把 <code>pyenv</code> 安装在哪。</strong>推荐安装在 <code>$HOME/.pyenv</code>，但你也可以安装在任意位置。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/pyenv/pyenv.git ~/.pyenv</div></pre></td></tr></table></figure>
</li>
<li><p><strong>定义你 <code>PYENV_ROOT</code> 的环境变量</strong>来指定你把 pyenv 仓库克隆到了哪，并把 <code>$PYENV_ROOT/bin</code> 添加到你的 <code>$PATH</code> 中，这样就能在命令行使用 <code>pyenv</code> 命令。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrc</div><div class="line">$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p><strong>设置启动 shell 时自动加载 pyenv 脚本。</strong>在 shell 配置文件的最后面加上 <code>eval &quot;$(pyenv init -)&quot;</code>。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p><strong>重启 shell，使脚本生效。</strong>  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ exec $SHELL</div></pre></td></tr></table></figure>
</li>
<li><p><strong>安装不同的 python 版本到 <code>$(pyenv root)/versions</code> 文件夹。</strong><br> 在 <code>pyenv</code> 安装之前的所有 python 版本都归为 <code>system</code> 版本。 （可以用 <code>pyenv versions</code> 查看当前安装的 python 版本）<br> 在安装 python 之前，可以使用 <code>pyenv install -l</code> 查看当前可以安装哪些 python 版本。<br> 然后使用 <code>pyenv install 选择的版本</code> 来安装你所选择的 python 版本。比如 <code>pyenv install 3.6.1</code> 安装 python 官网的版本。  </p>
</li>
</ol>
<h3 id="使用-git-更新-pyenv"><a href="#使用-git-更新-pyenv" class="headerlink" title="使用 git 更新 pyenv"></a>使用 git 更新 pyenv</h3><p>如果你是按照上面的方法安装的 <code>pyenv</code>，那你可以使用 git 来更新。</p>
<h4 id="更新为最新的开发版"><a href="#更新为最新的开发版" class="headerlink" title="更新为最新的开发版"></a>更新为最新的开发版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $(pyenv root)</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<h4 id="更新为指定的版本"><a href="#更新为指定的版本" class="headerlink" title="更新为指定的版本"></a>更新为指定的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd $(pyenv root)</div><div class="line">$ git fetch</div><div class="line">$ git tag</div><div class="line">v0.1.0</div><div class="line">$ git checkout v0.1.0</div></pre></td></tr></table></figure>
<h3 id="pyenv-的基本操作命令"><a href="#pyenv-的基本操作命令" class="headerlink" title="pyenv 的基本操作命令"></a>pyenv 的基本操作命令</h3><ul>
<li><code>pyenv versions</code> 查看当前已安装的 python 版本</li>
<li><code>pyenv install ...</code> 安装指定版本的 python</li>
<li><code>pyenv global python版本</code> 切换全局 python 版本</li>
<li><code>pyenv local python版本</code> 切换当前文件夹下的 python 版本</li>
<li><code>pyenv shell python版本</code> 切换当前 shell 中的 python 版本</li>
<li><code>pyenv version</code> 查看当前使用的 python 版本</li>
</ul>
<h3 id="卸载-pyenv"><a href="#卸载-pyenv" class="headerlink" title="卸载 pyenv"></a>卸载 pyenv</h3><ul>
<li>如果你只是想禁用 <code>pyenv</code>，那么把 <code>pyenv init</code> 从 shell 的配置文件中移除，然后重启 shell 就行了（移除后 <code>pyenv</code> 命令仍然能使用，但是版本切换命令不会生效）。  </li>
<li>完整卸载 pyenv。执行上一步，然后把 pyenv 的根目录删除即可全部删除 pyenv（通过 <code>pyenv install ...</code> 安装的 python 版本都会删除）。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf $(pyenv root)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="卸载-pyenv-安装的-python-版本"><a href="#卸载-pyenv-安装的-python-版本" class="headerlink" title="卸载 pyenv 安装的 python 版本"></a>卸载 pyenv 安装的 python 版本</h3><ul>
<li>使用 <code>pyenv uninstall ...</code> 命令。  </li>
<li>直接删除 <code>versions</code> 文件夹下的对应 python 版本文件夹。  </li>
</ul>
<h3 id="pyenv-其他操作命令"><a href="#pyenv-其他操作命令" class="headerlink" title="pyenv 其他操作命令"></a>pyenv 其他操作命令</h3><p>参见 <a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" target="_blank" rel="external">commands.md</a></p>
<p><br><br><br></p>
<h2 id="管理-python-模块版本"><a href="#管理-python-模块版本" class="headerlink" title="管理 python 模块版本"></a>管理 python 模块版本</h2><p>使用 <code>virtualenv</code> 和 <code>virtualenvwrapper</code> 管理 python 虚拟环境，每次都需要手动激活或退出。对于懒癌晚期患者，<code>pyenv-virtual</code> 的自动激活和退出虚拟环境功能简直不能再赞。另外搭配 <code>pyenv</code> 食用效果更佳。</p>
<h3 id="安装-pyenv-virtualenv（Ubuntu）"><a href="#安装-pyenv-virtualenv（Ubuntu）" class="headerlink" title="安装 pyenv-virtualenv（Ubuntu）"></a>安装 pyenv-virtualenv（Ubuntu）</h3><p>由于 <code>pyenv-virtualenv</code> 是 <code>pyenv</code> 的一个插件，所以安装之前需要先安装 <code>pyenv</code>。</p>
<p><strong>注意：</strong>如果 <code>pyenv</code> 的安装目录不是 <code>$HOME/.pyenv</code> 需要确保克隆下来的仓库位于你所安装的 <code>pyenv</code> 目录下的 <code>plugin</code> 文件夹下。</p>
<p>接下来就可以执行安装步骤了：</p>
<ol>
<li>克隆 <code>pyenv-virtual</code> 仓库到 <code>plugin</code> 文件夹下。</li>
<li><p>（可选/重点）添加 <code>pyenv virtualenv-init</code> 到你的 shell 配置文件中，这样进入指定文件夹自动进入虚拟环境，离开文件夹退出虚拟环境。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;eval &quot;$(pyenv virtualenv-init -)&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>重启 shell。</p>
</li>
</ol>
<h3 id="创建-pyenv-virtualenv-虚拟环境"><a href="#创建-pyenv-virtualenv-虚拟环境" class="headerlink" title="创建 pyenv-virtualenv 虚拟环境"></a>创建 pyenv-virtualenv 虚拟环境</h3><ul>
<li><code>pyenv virtualenv 指定python版本 虚拟环境名字</code></li>
<li><code>pyenv virtualenv 虚拟环境名字</code></li>
</ul>
<p>如果不指定 python 版本，则默认使用当前 <code>pyenv version</code> 的 python 版本。</p>
<p>创建的虚拟环境位于 <code>$(pyenv root)/versions/</code> 下的指定 python 版本的文件夹中 <code>envs/</code> 文件夹下。</p>
<h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><ul>
<li>自动激活/退出</li>
<li>手动激活/退出</li>
</ul>
<p>自动激活环境：</p>
<ul>
<li>在 <code>.bashrc</code> 文件的最后添加 <code>eval &quot;$(pyenv virtualenv-init -)&quot;</code>，然后在 shell 中输入 <code>exec &quot;$SHELL&quot;</code> 重启 shell，或者手动重启 shell。</li>
<li>在想要激活虚拟环境的文件夹中新建 <code>.python-version</code> 文件，并写入虚拟环境的名字（<code>pyenv local python版本</code> 该命令也是通过创建该文件来达到进入该文件夹后自动使用指定 python 版本的目的）。</li>
<li>以后进入该的文件夹就会自动激活虚拟环境，离开该文件夹就会退出虚拟环境。</li>
</ul>
<p>手动激活环境：</p>
<ul>
<li><code>pyenv activate 虚拟环境名字</code> 激活虚拟环境。</li>
<li><code>pyenv deactivate</code> 退出虚拟环境。</li>
</ul>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p>有 2 种方法：  </p>
<ol>
<li>删除 <code>$(pyenv root)/versions</code> 和 <code>$(pyenv root)/versions/{version}/envs</code> 的相关文件夹即可。  </li>
<li>命令行运行 <code>pyenv uninstall 虚拟环境的名字</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 python 拥有众多的版本，以及不同模块也有不同的版本。如果每个版本之间相互都不兼容那也就无所谓什么版本控制了，可是同一机器上各个版本的 python 可以相互兼容并存，而且同一模块不同版本有时需要的 python 版本是不相同的，所以 python 的版本控制显得尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pyenv&lt;/code&gt; 是个 shell 脚本，能够轻松得实现各个不同版本 python 的相互间切换，而且各个版本的 python 切换不限于全局切换，甚至不同文件夹都可以拥有不同的 python 版本。&lt;/p&gt;
    
    </summary>
    
      <category term="document" scheme="https://yuanblq.github.io/categories/document/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>itertools 模块解析</title>
    <link href="https://yuanblq.github.io/2017/05/21/itertools%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/"/>
    <id>https://yuanblq.github.io/2017/05/21/itertools模块解析/</id>
    <published>2017-05-21T11:32:55.000Z</published>
    <updated>2017-05-20T16:39:37.522Z</updated>
    
    <content type="html"><![CDATA[<p>python 的内建模块 <code>itertools</code> 提供了非常有用的用于操作可迭代对象的函数.<br>通过这些函数, 我们能更好更快的解决许多有关可迭代对象的问题.<br>对于这些函数, 大体分成三类来描述 :  </p>
<ul>
<li>组合产生器</li>
<li>无限迭代器</li>
<li>有限迭代器</li>
</ul>
<a id="more"></a>
<h2 id="组合产生器"><a href="#组合产生器" class="headerlink" title="组合产生器"></a>组合产生器</h2><h3 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h3><p><code>itertools.combinations</code> 允许你从一个可迭代对象中创建一个迭代器, 迭代中的元素长度相同.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</div><div class="line">c = combinations(<span class="string">'ABC'</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;C&apos;)
</code></pre><p>运行上面的代码可见, <code>combinations()</code> 将一个可迭代对象重新组合成指定的几个元素长度, 并且是以元祖的方式返回.</p>
<p><strong>需要注意的是, 组合的元素是不重复的.</strong></p>
<p>通过 <code>join()</code> 方法, 可以将元祖内的元祖进行拼凑.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> combinations(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(<span class="string">''</span>.join(i))</div></pre></td></tr></table></figure>
<pre><code>AB
AC
BC
</code></pre><h3 id="combinations-with-replacement"><a href="#combinations-with-replacement" class="headerlink" title="combinations_with_replacement"></a>combinations_with_replacement</h3><p><code>combinations_with_replacement</code> 和 <code>combinations</code> 类似, 只不过它会创建重复的元素.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;A&apos;)
(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;B&apos;)
(&apos;B&apos;, &apos;C&apos;)
(&apos;C&apos;, &apos;C&apos;)
</code></pre><p><strong>但是, 创建出来的组合是没有顺序的, 即 <code>AB</code> 和 <code>BA</code> 视为同一组合.</strong></p>
<h3 id="product"><a href="#product" class="headerlink" title="product"></a>product</h3><p><code>product</code> 迭代器从一系列的输入中创建笛卡儿积 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</div><div class="line">l = [(<span class="string">'A'</span>, <span class="string">'B'</span>), [<span class="number">1</span>, <span class="number">2</span>], (<span class="string">'w'</span>,)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> product(*l):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, 1, &apos;w&apos;)
(&apos;A&apos;, 2, &apos;w&apos;)
(&apos;B&apos;, 1, &apos;w&apos;)
(&apos;B&apos;, 2, &apos;w&apos;)
</code></pre><p>同样, 也是以元祖的形式返回.</p>
<h3 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h3><p><code>permutations</code> 和 <code>combinations</code> 很像, 只不过, <code>permutations</code> 是有排列顺序的, 即 <code>AB</code> 和 <code>BA</code> 是两个不同的组合.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> permutations(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;A&apos;)
(&apos;B&apos;, &apos;C&apos;)
(&apos;C&apos;, &apos;A&apos;)
(&apos;C&apos;, &apos;B&apos;)
</code></pre><p><strong>另外, <code>permutations</code> 同样是不会重复元素的.</strong></p>
<h2 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h2><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count(start=0, step=1)</code>, count 迭代器从起始值开始, 按一定的步长, 生成一个能产生无限长度的迭代器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(start=<span class="number">10</span>, step=<span class="number">3</span>):</div><div class="line">    <span class="keyword">if</span> i == <span class="number">25</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>10
13
16
19
22
</code></pre><h3 id="islice"><a href="#islice" class="headerlink" title="islice"></a>islice</h3><p>一般无限迭代器可以和 <code>islice</code> 配合使用, 它能使无限迭代器在指定的次数后停止.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice(count(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>3
7
11
15
19
</code></pre><p><code>islice</code> 可以接受三个参数, 即 start, stop, step, 也可以只接收两个, 即 start, stop, 甚至也可以只接受一个参数, 即 stop.</p>
<h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle([<span class="number">1</span>,<span class="number">2</span>]):</div><div class="line">    <span class="keyword">if</span> count &gt; <span class="number">5</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(i)</div><div class="line">    count += <span class="number">1</span></div></pre></td></tr></table></figure>
<pre><code>1
2
1
2
1
2
</code></pre><p><code>cycle</code> 接收一个参数, 它能生成接收参数的无限循环迭代器.</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code> 能够指定循环的次数, 但是它不像 <code>cycle</code> 能循环接受的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> repeat</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> repeat([<span class="number">1</span> ,<span class="number">2</span>], <span class="number">5</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>[1, 2]
[1, 2]
[1, 2]
[1, 2]
[1, 2]
</code></pre><h2 id="有限迭代器"><a href="#有限迭代器" class="headerlink" title="有限迭代器"></a>有限迭代器</h2><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p><code>accumulate</code> (Python3 中提供) 默认返回累加之和, 也可以传入自定义的函数.</p>
<p>例如, 传递 0-9 这个序列, 它会一次相加, 第一次是 0, 第二次是 0+1, 等等 …</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div><div class="line">list(accumulate(range(<span class="number">9</span>)))</div></pre></td></tr></table></figure>
<pre><code>[0, 1, 3, 6, 10, 15, 21, 28, 36]
</code></pre><p>我们也可以传入自定义的函数 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line">list(accumulate(range(<span class="number">1</span>,<span class="number">5</span>), <span class="keyword">lambda</span> x,y : x*y))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 6, 24]
</code></pre><h3 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my_list = [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</div><div class="line">numbers = range(<span class="number">3</span>)</div><div class="line">cmd = (<span class="string">'ls'</span>, <span class="string">'/home'</span>)</div><div class="line">my_list.extend(numbers)</div><div class="line">my_list.extend(cmd)</div><div class="line">print(my_list)</div></pre></td></tr></table></figure>
<pre><code>[&apos;foo&apos;, &apos;bar&apos;, 0, 1, 2, &apos;ls&apos;, &apos;/home&apos;]
</code></pre><p>如上述代码, 我们能把多个可迭代对象进行融合, 但是 <code>extend()</code> 方法只能接受一个参数, 而且融合后是个列表, 如果数据量比较大, 那么会非常占用内存.</p>
<p>通过 <code>chain</code> 能完成多个可迭代对象的融合, 而且融合后是一个迭代器 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</div><div class="line">s = <span class="string">'abc'</span></div><div class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">t = (<span class="string">'q'</span>, <span class="string">'w'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain(s, l, t):</div><div class="line">    print(i, end=<span class="string">''</span>)</div></pre></td></tr></table></figure>
<pre><code>abc123qwer
</code></pre><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p><code>compress</code> 接收两个可迭代对象, 并通过第二个可迭代对象对第一个可迭代对象进行过滤 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</div><div class="line">letters = <span class="string">'ABCDEFG'</span></div><div class="line">bools = [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">''</span>, <span class="keyword">True</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> compress(letters, bools):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>A
C
E
</code></pre><h3 id="dropwhile"><a href="#dropwhile" class="headerlink" title="dropwhile"></a>dropwhile</h3><p>从字面意思可以看出, 该迭代器是 : 一直丢弃, 直到 (不满足条件为止) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> x : x &lt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>8
10
5
3
1
</code></pre><h3 id="takewhile"><a href="#takewhile" class="headerlink" title="takewhile"></a>takewhile</h3><p><code>takewhile</code> 与 <code>dropwhile</code> 相反 : 一直返回, 直到(满足条件为止) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> takewhile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> takewhile(<span class="keyword">lambda</span> x:x &lt; <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
2
1
</code></pre><h3 id="filterfalse"><a href="#filterfalse" class="headerlink" title="filterfalse"></a>filterfalse</h3><p><code>filterfalse</code> (Python2 是 ifilterfalse), 仅仅返回不满足条件的值 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> filterfalse</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filterfalse(<span class="keyword">lambda</span> x : x&gt;<span class="number">3</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
3
2
1
</code></pre><h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</div><div class="line">vehicles = [(<span class="string">'Ford'</span>, <span class="string">'Taurus'</span>), (<span class="string">'Dodge'</span>, <span class="string">'Durango'</span>), (<span class="string">'Chevrolet'</span>, <span class="string">'Cobalt'</span>),</div><div class="line">           (<span class="string">'Ford'</span>, <span class="string">'F150'</span>), (<span class="string">'Dodge'</span>, <span class="string">'Charger'</span>), (<span class="string">'Ford'</span>, <span class="string">'GT'</span>)]</div><div class="line"><span class="keyword">for</span> group_name, sub_group <span class="keyword">in</span> groupby(sorted(vehicles), <span class="keyword">lambda</span> group : group[<span class="number">0</span>]):</div><div class="line">    print(group_name)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sub_group:</div><div class="line">        print(i)</div></pre></td></tr></table></figure>
<pre><code>Chevrolet
(&apos;Chevrolet&apos;, &apos;Cobalt&apos;)
Dodge
(&apos;Dodge&apos;, &apos;Charger&apos;)
(&apos;Dodge&apos;, &apos;Durango&apos;)
Ford
(&apos;Ford&apos;, &apos;F150&apos;)
(&apos;Ford&apos;, &apos;GT&apos;)
(&apos;Ford&apos;, &apos;Taurus&apos;)
</code></pre><p>在传入 <code>groupby</code> 之前, 一般先对数据进行排序, 使数据更加密集, 并且能让 <code>groupby</code> 正确的将元素聚集在一起.</p>
<p><code>groupby</code> 接收两个参数, 第一个是可迭代对象, 第二个是 keyfunc 函数. keyfunc 函数用来定义以什么为标准, 进行分组.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key, sub_group <span class="keyword">in</span> groupby(<span class="string">'AaBbBaBCCC'</span>, <span class="keyword">lambda</span> x : x.upper()):</div><div class="line">    print(key, list(sub_group))</div></pre></td></tr></table></figure>
<pre><code>A [&apos;A&apos;, &apos;a&apos;]
B [&apos;B&apos;, &apos;b&apos;, &apos;B&apos;]
A [&apos;a&apos;]
B [&apos;B&apos;]
C [&apos;C&apos;, &apos;C&apos;, &apos;C&apos;]
</code></pre><p>当数据排序不够密集时, 就会出现上面数据分类不够紧凑的问题, 所以在分组前, 一般现对数据进行排序处理.</p>
<h3 id="starmap"><a href="#starmap" class="headerlink" title="starmap"></a>starmap</h3><p><code>starmap</code> 使用传入的函数和可迭代对象进行计算, 返回一个新的迭代器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> starmap</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> starmap(<span class="keyword">lambda</span> x,y: x+y, [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>), [<span class="string">'a'</span>, <span class="string">'b'</span>]]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>3
7
ab
</code></pre><p><code>starmap</code> 和 <code>map</code> 的区别在于, 传入的函数分别为 func(a, b) 和 func(*c)</p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</div><div class="line">data = <span class="string">'ABCDE'</span></div><div class="line">iter1, iter2 = tee(data)</div><div class="line">print(list(iter1))</div><div class="line">print(list(iter2))</div></pre></td></tr></table></figure>
<pre><code>[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</div><div class="line">data = <span class="string">'ABCDE'</span></div><div class="line">iter1, iter2, iter3 = tee(data, <span class="number">3</span>)</div><div class="line">print(list(iter1))</div><div class="line">print(list(iter2))</div><div class="line">print(list(iter3))</div></pre></td></tr></table></figure>
<pre><code>[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
</code></pre><p>相当于复制, 默认复制 2 个.</p>
<h3 id="zip-longest"><a href="#zip-longest" class="headerlink" title="zip_longest"></a>zip_longest</h3><p><code>zip_longest</code> (Python3 支持) 可以用来将两个可迭代对象打包在一起, 如果两个对象长度一部样, 可以传入 <code>fillvalue</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(<span class="string">'abc'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], fillvalue=<span class="string">'哈'</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;a&apos;, 1)
(&apos;b&apos;, 2)
(&apos;c&apos;, 3)
(&apos;哈&apos;, 4)
(&apos;哈&apos;, 5)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 的内建模块 &lt;code&gt;itertools&lt;/code&gt; 提供了非常有用的用于操作可迭代对象的函数.&lt;br&gt;通过这些函数, 我们能更好更快的解决许多有关可迭代对象的问题.&lt;br&gt;对于这些函数, 大体分成三类来描述 :  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合产生器&lt;/li&gt;
&lt;li&gt;无限迭代器&lt;/li&gt;
&lt;li&gt;有限迭代器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>从输入url到显示页面发生了什么</title>
    <link href="https://yuanblq.github.io/2017/05/14/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://yuanblq.github.io/2017/05/14/从输入url到显示页面发生了什么/</id>
    <published>2017-05-14T09:59:04.000Z</published>
    <updated>2017-05-20T16:27:56.006Z</updated>
    
    <content type="html"><![CDATA[<p><strong>当我们在浏览器的地址栏输入访问的 URL，然后回车，到浏览器显示对应的页面。这期间，到底发生了什么？</strong>  </p>
<p>以下，我大概按如这几部分来探索关于浏览器是怎么呈现出我们想要的页面：  </p>
<ul>
<li>输入 url</li>
<li>解析域名</li>
<li>建立连接</li>
<li>发起请求</li>
<li>响应请求</li>
<li>渲染页面</li>
<li>断开连接</li>
</ul>
<a id="more"></a>
<h2 id="输入-url"><a href="#输入-url" class="headerlink" title="输入 url"></a>输入 url</h2><p>在一个网络中，不同计算机拥有的 ip 地址都是唯一的。提供网页的服务器也是一台计算机，所以同样拥有唯一的一个 ip。  </p>
<p>比如百度的某一台服务器 ip 为 111.13.101.208，你完全可以通过 111.13.101.208:80 去访问百度的首页。但如果你还想访问腾讯、淘宝等其他网站呢？  </p>
<p>显然以 ip 方式去访问一个网站是很费劲的。就像我们说天安门在哪的时候不会说天安门在经纬多少多少度一样，而是以人话说在北京哪哪哪。  </p>
<p>所以，我们同样以别名的方式去记住每一个网站。而这就是 DNS 服务器干的活。  </p>
<p>我们在浏览器输入的是一个，人能够轻松记住的域名网址。当我们回车的时候 DNS 服务器就会去找该域名网址在网络中对应的 ip 地址，称之为解析域名。  </p>
<h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>一般来说，浏览器会先从本地的 hosts 文件中查找该域名对应的 ip 地址。  </p>
<p>没有的话再从网络运营商的 DNS 服务器中请求解析，如果没有就再以递归的方式往下不断请求 DNS 解析。找到之后，再一层层返回到你的电脑。  </p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>浏览器拿到 ip 地址之后，会以一个随机端口（1024-65535）向服务器 web 程序的 80/443 端口发起 TCP 连接请求，即所谓的三次握手，如下图所示：<br><img src="/2017/05/14/从输入url到显示页面发生了什么/三次握手.PNG" alt="PNG">  </p>
<h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><p>TCP 连接建立完成之后，浏览器就会向服务器发起 http request header 请求。  </p>
<p>一般为 GET 和 POST 两种请求。  </p>
<p>一个简单的 GET 请求的 request header 包含：</p>
<ul>
<li>请求行：HTTP/1.1 / GET</li>
<li>请求头：’User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0’, …</li>
<li>请求体：?key1=value1&amp;key2=value2…</li>
</ul>
<p>请求头和请求体的最后一行之间有两个 ‘\r\n’，用于告诉服务器没有其他请求头了。（POST 方式的请求信息一般不放在请求体，而是通过表单提交）  </p>
<h2 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h2><p>服务器接收到浏览器的请求之后，根据其响应内容会给浏览器相应的响应，服务器的 HTTP 响应同样也分为，响应行、响应头、响应体。  </p>
<h2 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h2><p>浏览器拿到服务器返回的响应数据后，根据其内容在把它渲染出来。</p>
<h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p>当我们在浏览器关闭正在访问的页面的时候，浏览器会发送断开连接的请求，及四次挥手过程，如下图所示：<br><img src="/2017/05/14/从输入url到显示页面发生了什么/四次挥手.PNG" alt="PNG">  </p>
<p>以上基本就是一个简单的从输入 url 到浏览器显示最终页面，期间所发生的一些事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;当我们在浏览器的地址栏输入访问的 URL，然后回车，到浏览器显示对应的页面。这期间，到底发生了什么？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;以下，我大概按如这几部分来探索关于浏览器是怎么呈现出我们想要的页面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入 url&lt;/li&gt;
&lt;li&gt;解析域名&lt;/li&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;li&gt;发起请求&lt;/li&gt;
&lt;li&gt;响应请求&lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;li&gt;断开连接&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
      <category term="网络" scheme="https://yuanblq.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>yield理解</title>
    <link href="https://yuanblq.github.io/2017/05/08/yield%E7%90%86%E8%A7%A3/"/>
    <id>https://yuanblq.github.io/2017/05/08/yield理解/</id>
    <published>2017-05-08T12:54:59.000Z</published>
    <updated>2017-05-19T14:34:24.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案"><a href="#这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案" class="headerlink" title="这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案"></a>这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案</h3><p>原文: <a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained" target="_blank" rel="external">http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained</a></p>
<h4 id="提问者的问题"><a href="#提问者的问题" class="headerlink" title="提问者的问题"></a>提问者的问题</h4><p>Python 关键字 yield 的作用是什么? 用来干什么的?</p>
<p>比如, 我正在试图理解下面的代码 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></div><div class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</div><div class="line">        <span class="keyword">yield</span> self._leftchild</div><div class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</div><div class="line">        <span class="keyword">yield</span> self._rightchild</div></pre></td></tr></table></figure>
<p>下面的是调用 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">result, candidates = list(), [self]</div><div class="line"><span class="keyword">while</span> candidates:</div><div class="line">    node = candidates.pop()</div><div class="line">    distance = node._get_dist(obj)</div><div class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</div><div class="line">        result.extend(node._values)</div><div class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>当调用 _get_child_candidates 的时候发生了什么? 返回了一个列表? 返回了一个元素? 被重复调用了么? 什么时候这个调用结束呢?</p>
<a id="more"></a>
<h4 id="回答部分"><a href="#回答部分" class="headerlink" title="回答部分"></a>回答部分</h4><p>为了理解什么是 yield ,你必须理解什么是生成器. 在理解生成器之前, 让我们先走近迭代.</p>
<h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>当你建立了一个列表, 你可以逐项地读取这个列表, 这叫做一个可迭代对象 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
2
3
</code></pre><p>mylist 是一个可迭代对象. 当你使用一个列表生成式来建立一个列表的时候, 就建立了一个可迭代对象 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>0
1
4
</code></pre><p>所有你可以使用 for .. in .. 语法的叫做一个迭代器 : 列表, 字符串, 文件 … 你经常使用它们是因为你可以如你所愿的读取其中的元素, 但是你把所有的值都存储到了内存中, 如果你有大量数据的话, 这个方式并不是你想要的.</p>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>生成器是可以迭代的, 但是你 <strong><em>只可以读取它一次</em></strong> ,因为它并不把所有的值放在内存中, 它是实时地生成数据 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>0
1
4
</code></pre><p>看起来除了把 [] 换成 () 外没什么不同. 但是, 你不可以再次使用 for i in mygenerator , 因为生成器只能被迭代一次 : 先计算出 0, 然后继续计算 1, 然后计算 4, 一个接一个的 …</p>
<h5 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h5><p>yield 是一个类似 rerun 的关键字, 只是这个函数返回的是一个生成器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></div><div class="line">    mylist = range(<span class="number">3</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">        <span class="keyword">yield</span> i*i</div><div class="line"></div><div class="line">mygenerator = createGenerator()</div><div class="line">print(mygenerator)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>&lt;generator object createGenerator at 0x00C189C0&gt;
0
1
4
</code></pre><p>这个例子没什么用途, 但是它让你知道, 这个函数会返回一大批你只需要读一次的值.</p>
<p>为了精通 yield ,你必须要理解 : <strong>当你调用这个函数的时候, 函数内部的代码并不立马执行</strong> , 这个函数只是返回一个生成器对象, 这有点蹊跷不是吗.</p>
<p>那么, 函数的代码什么时候执行呢? 当你使用 for 进行迭代的时候.</p>
<p>现在到了关键点了 !</p>
<p>第一次迭代中你的函数会执行, 从开始到达 yield 关键字, 然后返回 yield 后的值作为第一次迭代的返回值, 然后, 每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次, 再返回那个值, 直到没有可以返回的.</p>
<p>如果生成器内部没有定义 yield 关键字, 那么这个生成器被认为空的. 这种情况可能因为是循环进行没了, 或者是没有满足 if/else 条件.</p>
<h5 id="回到你的代码"><a href="#回到你的代码" class="headerlink" title="回到你的代码"></a>回到你的代码</h5><p>生成器 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建 node 对象的一个方法, 该方法返回一个生成器</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></div><div class="line">    <span class="comment"># 如果 node 对象的左边仍然有 child</span></div><div class="line">    <span class="comment"># 并且距离合适, 则返回下一个 child</span></div><div class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</div><div class="line">        <span class="keyword">yield</span> self._leftchild</div><div class="line">    </div><div class="line">    <span class="comment"># 如果 node 对象的右边仍然有 child</span></div><div class="line">    <span class="comment"># 并且距离合适, 则返回下一个 child</span></div><div class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</div><div class="line">        <span class="keyword">yield</span> self._rightchild</div><div class="line">        </div><div class="line">    <span class="comment"># 如果函数执行到这了, 则认为生成器已经空了</span></div><div class="line">    <span class="comment"># 不再有这两个值: leftchild, rightchild</span></div></pre></td></tr></table></figure>
<p>调用者 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个空列表, 和带有当前对象引用的列表</span></div><div class="line">result, candidates = list(), [self]</div><div class="line"></div><div class="line"><span class="comment"># candidates 的循环 (一开始他们只包含一个元素 --&gt; self)</span></div><div class="line"><span class="keyword">while</span> candidates:</div><div class="line">    </div><div class="line">    <span class="comment"># 获取最后一位 candidate , 并把它从列表中移除</span></div><div class="line">    node = candidates.pop()</div><div class="line">    </div><div class="line">    <span class="comment"># 获取 obj 和 candidate 之间的 distance</span></div><div class="line">    distance = node._get_dist(obj)</div><div class="line">    </div><div class="line">    <span class="comment"># 如果距离合适, 加入result</span></div><div class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</div><div class="line">        result.extend(node._values)</div><div class="line">        </div><div class="line">    <span class="comment"># 在 candidates 列表中添加 candidate 的 children</span></div><div class="line">    <span class="comment"># 这样, 循环就能持续执行, 直到它查遍 candidate 的所有 children</span></div><div class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</div><div class="line">    </div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>这个代码包含了几个小部分 :</p>
<ul>
<li>我们对一个列表进行迭代, 但是迭代中列表还在不断的扩展. 它是一个迭代这些嵌套的数据的简洁方式, 即使这样有点危险, 因为可能导致无限迭代.<br>  <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code><br>  <strong>穷尽了生成器的所有制</strong>, 但 <code>while</code> 不断地在产生新的生成器, 他们会产生和上一次不一样的值, 但没有作用到同一个节点上.</li>
<li><code>extend()</code> 是一个迭代器方法, 作用于迭代器, 并把参数追加到迭代器的后面.</li>
</ul>
<p>通常我们传给它一个列表参数 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">a.extend(b)</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4]
</code></pre><p>但是在你的代码中是一个生成器, 这是不错的, 因为 :</p>
<ul>
<li>你不必读两次所有的值.</li>
<li>你可以有很多子对象, 但不必叫他们都储存在内存里面.</li>
</ul>
<p>并且这很奏效, 因为 Python 不关心一个方法的参数是不是个列表. Python 只希望它是一个可以迭代的, 所以这个参数可以是列表, 元祖, 字符串, 生成器 … 这叫做 <code>duck typing</code>, 这也是为何 Python 如此棒的原因之一, 但这已经是另外一个问题了 … </p>
<p>你可以在这里停下, 来看看生成器的一些高级用法 : </p>
<font color="red">控制生成器的穷尽</font>


<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span>   <span class="comment"># 让我们创建一个银行, 生成 ATM</span></div><div class="line">    crisis = <span class="keyword">False</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</div><div class="line">            <span class="keyword">yield</span> <span class="string">'$100'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hsbc = Bank()</div><div class="line">corner_street_atm = hsbc.create_atm()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>$100
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>$100
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print([corner_street_atm.__next__() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</div></pre></td></tr></table></figure>
<pre><code>[&apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hsbc.crisis = <span class="keyword">True</span> <span class="comment"># 经济危机来了, 没钱啦!</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-21-0291977c370d&gt; in &lt;module&gt;()
----&gt; 1 print(corner_street_atm.__next__())


StopIteration: 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wall_street_atm = hsbc.create_atm() <span class="comment"># 甚至新的 ATM 也有危机</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(wall_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-32-b42bcf449bd2&gt; in &lt;module&gt;()
----&gt; 1 print(wall_street_atm.__next__())


StopIteration: 
</code></pre><p><strong>糟糕的是, 危机走了, 但是 ATM 却依然没钱 …</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hsbc.crisis = <span class="keyword">False</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-36-0291977c370d&gt; in &lt;module&gt;()
----&gt; 1 print(corner_street_atm.__next__())


StopIteration: 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brand_new_atm = hsbc.create_atm()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">7</span></div><div class="line"><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</div><div class="line">    i -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</div><div class="line">        print(cash)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<pre><code>$100
$100
$100
$100
$100
$100
</code></pre><p>对于控制一些资源的访问来说, 这很有用.</p>
<font color="red">Itertools, 你最好的朋友</font>

<p>itertools 包含了很多特殊的迭代方法. 是不是曾想过复制一个迭代器? 串联两个迭代器? 把嵌套的列表分组? 不用创造一个新的列表的 <code>zip/map</code> ?</p>
<p>只要 <code>import itertools</code></p>
<p>需要个例子? 让我们看看比赛中 4 匹马可能到达终点的先后顺序的可能情况 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"></div><div class="line">horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">races = itertools.permutations(horses)</div><div class="line">print(races)</div></pre></td></tr></table></figure>
<pre><code>&lt;itertools.permutations object at 0x012B9DB0&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(list(races))</div></pre></td></tr></table></figure>
<pre><code>[(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)]
</code></pre><font color="red">了解迭代器的内部机理</font>

<p>迭代是一个实现可迭代对象(实现的是 <code>__iter__()</code> )和迭代器(实现的是 <code>__next__()</code> )的过程. 可迭代对象是你可以从其获取到一个迭代器的任一对象. 迭代器是那些允许你迭代可迭代对象的对象.</p>
<p>更多见这个文章 <a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">http://effbot.org/zone/python-for-statement.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案&quot;&gt;&lt;a href=&quot;#这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案&quot; class=&quot;headerlink&quot; title=&quot;这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案&quot;&gt;&lt;/a&gt;这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案&lt;/h3&gt;&lt;p&gt;原文: &lt;a href=&quot;http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained&quot;&gt;http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;提问者的问题&quot;&gt;&lt;a href=&quot;#提问者的问题&quot; class=&quot;headerlink&quot; title=&quot;提问者的问题&quot;&gt;&lt;/a&gt;提问者的问题&lt;/h4&gt;&lt;p&gt;Python 关键字 yield 的作用是什么? 用来干什么的?&lt;/p&gt;
&lt;p&gt;比如, 我正在试图理解下面的代码 :&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;_get_child_candidates&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, distance, min_dist, max_dist)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self._leftchild &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance - max_dist &amp;lt; self._median:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; self._leftchild&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self._rightchild &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance + max_dist &amp;gt;= self._median:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; self._rightchild&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面的是调用 :&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;result, candidates = list(), [self]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; candidates:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    node = candidates.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    distance = node._get_dist(obj)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; distance &amp;lt;= max_dist &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance &amp;gt;= min_dist:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result.extend(node._values)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当调用 _get_child_candidates 的时候发生了什么? 返回了一个列表? 返回了一个元素? 被重复调用了么? 什么时候这个调用结束呢?&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>itchat 微信机器人</title>
    <link href="https://yuanblq.github.io/2017/05/02/itchat/"/>
    <id>https://yuanblq.github.io/2017/05/02/itchat/</id>
    <published>2017-05-02T04:13:51.000Z</published>
    <updated>2017-05-02T07:09:04.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过-itchat-模块和微软小冰的微信公众号-xiaoice-ms-打造自己的微信机器人"><a href="#通过-itchat-模块和微软小冰的微信公众号-xiaoice-ms-打造自己的微信机器人" class="headerlink" title="通过 itchat 模块和微软小冰的微信公众号(xiaoice-ms)打造自己的微信机器人"></a>通过 itchat 模块和微软小冰的微信公众号(xiaoice-ms)打造自己的微信机器人</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li>通过微信的 python 接口 itchat获取微信消息  </li>
<li>将微信消息转发给”小冰”  </li>
<li>获取”小冰”处理后的返回消息  </li>
<li>将返回消息返回给微信消息的发送人  </li>
</ul>
<a id="more"></a>
<h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><h3 id="获取微信消息"><a href="#获取微信消息" class="headerlink" title="获取微信消息"></a>获取微信消息</h3><p>itchat 在注册时会根据相应的消息类型调用对应的函数.<br>比如现在只需获取基本的文本消息, 只需这样注册:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itchat</div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_msg</span><span class="params">(msg)</span>:</span></div><div class="line">	print(msg[<span class="string">'Text'</span>])</div><div class="line"></div><div class="line">itchat.auto_login()</div><div class="line">itchat.run()</div></pre></td></tr></table></figure></p>
<p>第三行, 通过装饰符将 <code>get_msg()</code> 注册为处理文本消息的函数.<br>微信的消息有很多类型, 通过注册不同的消息类型, 可以分别处理不同类型的消息.<br>执行命令后, 和登录网页版微信一样, 扫描弹出来的二维码, 即可登录你的微信并开始处理微信消息:<br><img src="/2017/05/02/itchat/qr.PNG" alt="png">  </p>
<h3 id="发送微信消息"><a href="#发送微信消息" class="headerlink" title="发送微信消息"></a>发送微信消息</h3><p>同样, 发送的微信消息有各种类型, 现在我们同样只处理文本类型的消息.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">itchat.send(<span class="string">'your msg'</span>, <span class="string">'toUserName'</span>)</div></pre></td></tr></table></figure></p>
<p>该发送消息的函数接收两个参数, 消息的内容和消息接收者的 UserName, 即该对象的标识符.<br>我们先试着给文件助手发送一条消息:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itchat</div><div class="line"></div><div class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)</div><div class="line">itchat.send(<span class="string">'我发送的消息'</span>, <span class="string">'filehelper'</span>)</div></pre></td></tr></table></figure></p>
<p>如果每次调试都要扫码登录的话比较麻烦.<br>第三行, 通过将 <code>auto_login()</code> 函数的 <code>hotReload</code> 参数设为 <code>True</code>, 即可实现热登陆.<br>保存代码后, 执行命令后, 效果如下:<br><img src="/2017/05/02/itchat/file.PNG" alt="png">  </p>
<p>该方法是主动给别人发送消息, 还有种是给你发送消息的回复消息.<br>如下的代码所示, 是回复给你发送消息的人:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itchat</div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reply_msg</span><span class="params">(msg)</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">'我回复的内容'</span></div><div class="line"></div><div class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)</div><div class="line">itchat.run()</div></pre></td></tr></table></figure></p>
<p>这种回复消息的方法属于被动触发, 只有别人给你发消息了, 才会去回复并且不需要消息接收者的 UserName.  </p>
<h3 id="将消息转发给”小冰”"><a href="#将消息转发给”小冰”" class="headerlink" title="将消息转发给”小冰”"></a>将消息转发给”小冰”</h3><p>既然我们已经会了收发消息的方法, 那么现在就可以完成将别人发给你的微信消息转发给”小冰”, 进而获取”小冰”的回复.<br>但是要发送消息给”小冰”, 那么”小冰”的 UserName 是什么呢?<br>itchat 提供了搜索每个人 UserName 的方法, 比如搜索公众号 UserName 的方法为:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">itchat.search_mps(name=<span class="string">'小冰'</span>)</div></pre></td></tr></table></figure></p>
<p>该方法返回的是一个字典, 通过查看字典结构即可拿到”小冰”的 UserName:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xiaoice = itchat.search_mps(name=<span class="string">'小冰'</span>)[<span class="number">0</span>][<span class="string">'UserName'</span>]</div></pre></td></tr></table></figure></p>
<p>现在, 我们就可一接收消息, 并把消息转发给”小冰”了:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itchat</div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fw_ice</span><span class="params">(msg)</span>:</span></div><div class="line">    msg_text = msg[<span class="string">'Text'</span>]</div><div class="line">    itchat.send(msg_text, xiaoice)</div><div class="line"></div><div class="line">itchat.auto_login(hotReload=<span class="keyword">True</span>)</div><div class="line">xiaoice = itchat.search_mps(name=<span class="string">'小冰'</span>)[<span class="number">0</span>][<span class="string">'UserName'</span>]</div><div class="line">itchat.run()</div></pre></td></tr></table></figure></p>
<p>运行之后, 当别人给你发送消息的时候, 程序会自动将其转发给”小冰”:<br><img src="/2017/05/02/itchat/ice_reply.PNG" alt="png"><br><img src="/2017/05/02/itchat/ice_reply2.PNG" alt="png">  </p>
<h3 id="获取小冰的回复内容-并将其转发给给你发送微信的人"><a href="#获取小冰的回复内容-并将其转发给给你发送微信的人" class="headerlink" title="获取小冰的回复内容, 并将其转发给给你发送微信的人"></a>获取小冰的回复内容, 并将其转发给给你发送微信的人</h3><p>首先, 我们获取给你发微信的人 UserName<br>从 <code>def fw_ice(msg)</code> 传进来 msg 是一个字典, 我们可以从中获取到该次消息对话的很多信息, 其中就有消息发送者的 UserName: <code>msg[&#39;FromUserName&#39;]</code>.<br>我们把发送者的 UserName 存储在一个全局变量中, 这样等获取到”小冰”发送的内容后就能知道转发给谁了.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">who_send = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fw_ice</span><span class="params">(msg)</span>:</span></div><div class="line">	<span class="keyword">global</span> who_send</div><div class="line">    msg_text = msg[<span class="string">'Text'</span>]</div><div class="line">    who_send = msg[<span class="string">'FromUserName'</span>]</div><div class="line">    itchat.send(msg_text, xiaoice)</div></pre></td></tr></table></figure></p>
<p>然后, 我们获取”小冰”的回复内容, 并把它转发给发送者:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@itchat.msg_register(itchat.content.TEXT, isMpChat=True)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ice</span><span class="params">(msg)</span>:</span></div><div class="line">    ice_msg = msg[<span class="string">'Text'</span>]</div><div class="line">    itchat.send(ice_msg, toUserName=g_who_send)</div></pre></td></tr></table></figure></p>
<p>因为和”小冰”聊天属于和公众号的聊天, 所以在注册时需要添加 <code>isMpChat=True</code> 来让该函数知道它需要处理的是和公众号的聊天消息.<br>接着, 我们通过 msg 这个字典获取到”小冰”的回复内容后通过 <code>itchat.send()</code> 方法, 把该内容转发给发送者.<br>执行后, 如图所示:<br><img src="/2017/05/02/itchat/ice_reply3.PNG" alt="png"><br><img src="/2017/05/02/itchat/ice_reply4.PNG" alt="png"><br>这样就基本完成了利用”小冰”来实现的微信机器人.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;通过-itchat-模块和微软小冰的微信公众号-xiaoice-ms-打造自己的微信机器人&quot;&gt;&lt;a href=&quot;#通过-itchat-模块和微软小冰的微信公众号-xiaoice-ms-打造自己的微信机器人&quot; class=&quot;headerlink&quot; title=&quot;通过 itchat 模块和微软小冰的微信公众号(xiaoice-ms)打造自己的微信机器人&quot;&gt;&lt;/a&gt;通过 itchat 模块和微软小冰的微信公众号(xiaoice-ms)打造自己的微信机器人&lt;/h1&gt;&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;通过微信的 python 接口 itchat获取微信消息  &lt;/li&gt;
&lt;li&gt;将微信消息转发给”小冰”  &lt;/li&gt;
&lt;li&gt;获取”小冰”处理后的返回消息  &lt;/li&gt;
&lt;li&gt;将返回消息返回给微信消息的发送人  &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="应用实例" scheme="https://yuanblq.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
      <category term="itchat" scheme="https://yuanblq.github.io/tags/itchat/"/>
    
      <category term="小冰" scheme="https://yuanblq.github.io/tags/%E5%B0%8F%E5%86%B0/"/>
    
  </entry>
  
  <entry>
    <title>mySQL操作</title>
    <link href="https://yuanblq.github.io/2017/04/21/mySQL%E6%93%8D%E4%BD%9C/"/>
    <id>https://yuanblq.github.io/2017/04/21/mySQL操作/</id>
    <published>2017-04-21T11:38:36.000Z</published>
    <updated>2017-05-02T09:44:47.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL分为三个部分：</p>
<p>DDL：Data Definition<br>Language，数据定义语言，用来维护存储数据的结构（数据库，表），代表指令：create，drop，alter等。</p>
<p>DML：Data Manipulation<br>Language，数据操作语言，用来对数据进行操作（数据表中的内容），代表指令：insert，delete，update等；其中DML内部又单独进行了一个分类：DQL（Data<br>Query Language：数据查询语言，如select）。</p>
<p>DCL：Data Control<br>Language，数据控制语言，主要是负责权限管理（用户），代表指令：grant，revoke等。</p>
<p>SQL是关系型数据库的操作指令，SQL是一种约束，但不强制（类似W3C），不同产品（如Oracle，mysql）可能内部会有一些细微的区别。</p>
<a id="more"></a>
<h1 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h1><p>Mysql数据库是一种c/s结构的软件：客户端/服务端，若想访问服务器必须通过客户端（服务器一直运行，客户端在需要使用的时候运行）。</p>
<p>交互方式</p>
<ol>
<li><p>客户端连接认证：连接服务器，认证身份：mysql.exe -hPup（hP连接，up认证）</p>
<p> <img src="/2017/04/21/mySQL操作/1.png" alt="png"></p>
</li>
<li><p>发送SQL指令</p>
</li>
<li><p>服务器接收SQL指令，处理SQL指令，返回操作结果</p>
</li>
<li><p>客户端接受结果，显示结果</p>
<p> <img src="/2017/04/21/mySQL操作/2.png" alt="png"></p>
</li>
<li><p>断开连接（释放资源：服务器并发限制）：exit / quit / \q</p>
<p> <img src="/2017/04/21/mySQL操作/3.png" alt="png"></p>
</li>
</ol>
<h1 id="MySQL服务器对象"><a href="#MySQL服务器对象" class="headerlink" title="MySQL服务器对象"></a>MySQL服务器对象</h1><p>将mysql服务器内部对象分成四层：系统（DBMS）-> 数据库（DB）-><br>数据表（table）-> 字段（field）</p>
<p><img src="/2017/04/21/mySQL操作/4.png" alt="png"></p>
<h1 id="SQL基本操作"><a href="#SQL基本操作" class="headerlink" title="SQL基本操作"></a>SQL基本操作</h1><p>基本操作：CRUD</p>
<p>将SQL的基本操作根据操作对象分为三类：库操作，表操作（字段），数据操作</p>
<h2 id="库操作"><a href="#库操作" class="headerlink" title="库操作"></a>库操作</h2><p>对数据库的增删改查</p>
<h3 id="新增数据库"><a href="#新增数据库" class="headerlink" title="新增数据库"></a>新增数据库</h3><p>基本语法</p>
<p>create database 数据库名字 [库选项];</p>
<p>库选项：用来约束数据库，分为两个选项</p>
<p>字符集设定：charset / character set<br>具体字符集（数据存储的编码格式）：常用字符集：gbk和utf8</p>
<p>校对集设定：collate 具体校对集（数据比较的规则）</p>
<p><img src="/2017/04/21/mySQL操作/5.png" alt="png"></p>
<p>其中：数据库名字不能用关键字或者保留字，非要用可以在前后加上反引号（`）</p>
<p>当创建数据库的SQL语句执行后，发生了什么？</p>
<ol>
<li><p>在数据库系统中，增加了对应的数据库信息</p>
</li>
<li><p>会在保存数据的文件夹下：Data目录，创建一个对应数据库名字的文件夹</p>
<p><img src="/2017/04/21/mySQL操作/6.png" alt="png"></p>
</li>
<li><p>每个数据库下都有一个opt文件：保存了库选项</p>
<p><img src="/2017/04/21/mySQL操作/7.png" alt="png"></p>
</li>
</ol>
<h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><ol>
<li><p>查看所有数据库</p>
<p>show databases;</p>
<p><img src="/2017/04/21/mySQL操作/8.png" alt="png"></p>
</li>
<li><p>查看指定部分的数据库：模糊查询</p>
<p>show databases like ‘pattern’ – pattern是匹配模式</p>
<p>%：表示匹配多个字符</p>
<p>_：表示匹配单个字符</p>
</li>
<li><p>查看数据库的创建语句</p>
<p>show create database 数据库名字;</p>
<p><img src="/2017/04/21/mySQL操作/9.png" alt="png"></p>
<p>数据库在执行SQL语句之前会优化SQL，系统保存优化之后的结果。</p>
</li>
</ol>
<h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><p>数据库的名字不可以修改。 – 修改数据库名字不安全</p>
<p>数据库的修改仅限库选项：字符集和校对集（校对集依赖字符集）</p>
<p>alter database 数据库名字 [库选项];</p>
<p>库选项：charset / character set [=] 字符集</p>
<p>collate 校对集</p>
<p><img src="/2017/04/21/mySQL操作/10.png" alt="png"></p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>drop database 数据库名字;</p>
<p><img src="/2017/04/21/mySQL操作/11.png" alt="png"></p>
<p>当执行删除数据库语句时，发生了什么？</p>
<ol>
<li><p>在数据库内部看不到对应的数据库</p>
</li>
<li><p>在对应的数据库存储的文件夹内：数据库名字对应的文件夹也被删除（级联删除：里面的数据表全部删除）</p>
</li>
</ol>
<h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>表与字段是不可分的。</p>
<h3 id="新增数据表"><a href="#新增数据表" class="headerlink" title="新增数据表"></a>新增数据表</h3><p>create table [if not exists] 表名(</p>
<p>字段名字 数据类型,</p>
<p>字段名字 数据类型,</p>
<p>…</p>
<p>)[表选项];</p>
<p>if not exists：如果表名不存在，那就创建，否则不执行创建代码：检查功能</p>
<p>表选项：控制表的表现</p>
<p>字符集：charset / character set 具体字符集; – 保证表中数据存储的字符集</p>
<p>校对集：collate 具体校对集;</p>
<p>存储引擎：engin 具体的存储引擎（innodb和myisam）</p>
<p><img src="/2017/04/21/mySQL操作/12.png" alt="png"></p>
<p>任何一个表的设计都必须指定数据库。</p>
<p>方案1：显式的指定表所属的数据库</p>
<p>create table 数据库名.表名(); – 将当前的数据表创建到指定的数据库下</p>
<p><img src="/2017/04/21/mySQL操作/13.png" alt="png"></p>
<p>方案2：隐式的指定表所属的数据库：先进入到某个数据库环境，这样创建的表自动归属到某个指定的数据库。</p>
<p>进入数据库环境：use 数据库名字</p>
<p><img src="/2017/04/21/mySQL操作/14.png" alt="png"></p>
<p>当创建表的SQL指令执行之后，发生了什么？</p>
<ol>
<li><p>指定数据库下已经存在对应的表</p>
</li>
<li><p>在数据库对应的文件夹下，会产生对应表的机构文件（跟存储引擎有关）</p>
<p><img src="/2017/04/21/mySQL操作/15.png" alt="png"></p>
</li>
</ol>
<h3 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h3><p>数据库能查看的方式表都能用。</p>
<ol>
<li><p>查看所有表：show tables;</p>
<p><img src="/2017/04/21/mySQL操作/16.png" alt="png"></p>
</li>
<li><p>查看部分表：show tables like ‘pattren’; – pattern 匹配模式</p>
</li>
<li><p>查看表创建语句：show create table 表名;</p>
<p>show create table student\g – \g 等价于分号（;）</p>
<p>show create table student\G; – \G将查到的结构旋转90°（纵向）</p>
<p><img src="/2017/04/21/mySQL操作/17.png" alt="png"></p>
</li>
<li><p>查看表结构：查看表中的字段信息</p>
<p>desc/ describe / show columns from 表名;</p>
<p><img src="/2017/04/21/mySQL操作/18.png" alt="png"></p>
</li>
</ol>
<h3 id="更新数据表"><a href="#更新数据表" class="headerlink" title="更新数据表"></a>更新数据表</h3><p>表的修改分为两部分：修改表本身和修改字段</p>
<h4 id="修改表本身"><a href="#修改表本身" class="headerlink" title="修改表本身"></a>修改表本身</h4><p>表本身可以修改：表名和表选项</p>
<ol>
<li><p>修改表名：rename table 老表名 to 新表名;</p>
<p><img src="/2017/04/21/mySQL操作/19.png" alt="png"></p>
</li>
<li><p>修改表选项：字符集，校对集和存储引擎</p>
<p>alter table 表名 表选项 [=] 值</p>
<p><img src="/2017/04/21/mySQL操作/20.png" alt="png"></p>
</li>
</ol>
<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>字段操作有很多：新增，修改，重名，删除</p>
<ol>
<li><p>新增字段</p>
<p>alter table 表名 add [column] 字段名 数据类型 [列属性] [位置];</p>
<p>位置：字段名可以存放到表中的任意位置：</p>
<p>first：第一个位置</p>
<p>after：在哪个字段之后：after 字段名；默认的是在最后一个字段之后</p>
<p><img src="/2017/04/21/mySQL操作/21.png" alt="png"></p>
</li>
<li><p>修改字段：通常修改属性或者数据类型</p>
<p>alter table 表名 modify 字段名 数据类型 [属性] [位置];</p>
<p><img src="/2017/04/21/mySQL操作/22.png" alt="png"></p>
</li>
<li><p>重命名字段</p>
<p>alter table 表名 change 旧字段名 新字段名 数据类型 [属性] [位置];</p>
<p><img src="/2017/04/21/mySQL操作/23.png" alt="png"></p>
</li>
<li><p>删除字段</p>
<p>alter table 表名 drop 字段名;</p>
<p><img src="/2017/04/21/mySQL操作/24.png" alt="png"></p>
</li>
</ol>
<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><p>drop table 表名1，表名2…; – 可以删除多张数据表</p>
<p><img src="/2017/04/21/mySQL操作/25.png" alt="png"></p>
<p>当删除数据表的指令执行后发生了什么？</p>
<ol>
<li><p>在表空间中，没有了指定的表（数据也没有了）</p>
</li>
<li><p>在数据库对用的文件夹下，表对应的文件（与存储引擎有关）也会被删除</p>
<p><img src="/2017/04/21/mySQL操作/26.png" alt="png"></p>
</li>
</ol>
<h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><p>有两种方法</p>
<p>方案1：给全表字段插入数据，不需要指定字段列表：要求数据的值出现的顺序必须与表中设计的字段出现的顺序一致：凡是非数值数据，都需要使用引号（建议是单引号）包裹</p>
<p>insert into 表名 values(值列表)[,(值列表)]; – 可以一次性插入多条记录</p>
<p><img src="/2017/04/21/mySQL操作/27.png" alt="png"></p>
<p>方案2：给部分字段插入数据，需要选定字段列表：字段列表出现的顺序与字段的顺序无关，但是值列表的顺序必须与选定的字段的顺序一致。</p>
<p>inset into 表名 (字段列表) values (值列表)[,(值列表)];</p>
<p><img src="/2017/04/21/mySQL操作/28.png" alt="png"></p>
<h3 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h3><p>select */字段列表 from 表名 [where 条件];</p>
<ol>
<li><p>查看所有数据</p>
<p><img src="/2017/04/21/mySQL操作/29.png" alt="png"></p>
</li>
<li><p>查看指定字段，指定条件的数据</p>
<p><img src="/2017/04/21/mySQL操作/30.png" alt="png"></p>
</li>
</ol>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>update 表名 set 字段 = 值 [where 条件]; – 不加where条件就是更新全部数据</p>
<p><img src="/2017/04/21/mySQL操作/31.png" alt="png"></p>
<h3 id="删除数据库-1"><a href="#删除数据库-1" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>delete from 表名 [where条件];</p>
<p><img src="/2017/04/21/mySQL操作/32.png" alt="png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h1&gt;&lt;p&gt;SQL分为三个部分：&lt;/p&gt;
&lt;p&gt;DDL：Data Definition&lt;br&gt;Language，数据定义语言，用来维护存储数据的结构（数据库，表），代表指令：create，drop，alter等。&lt;/p&gt;
&lt;p&gt;DML：Data Manipulation&lt;br&gt;Language，数据操作语言，用来对数据进行操作（数据表中的内容），代表指令：insert，delete，update等；其中DML内部又单独进行了一个分类：DQL（Data&lt;br&gt;Query Language：数据查询语言，如select）。&lt;/p&gt;
&lt;p&gt;DCL：Data Control&lt;br&gt;Language，数据控制语言，主要是负责权限管理（用户），代表指令：grant，revoke等。&lt;/p&gt;
&lt;p&gt;SQL是关系型数据库的操作指令，SQL是一种约束，但不强制（类似W3C），不同产品（如Oracle，mysql）可能内部会有一些细微的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="document" scheme="https://yuanblq.github.io/categories/document/"/>
    
    
      <category term="mySQL" scheme="https://yuanblq.github.io/tags/mySQL/"/>
    
  </entry>
  
  <entry>
    <title>词云小例子</title>
    <link href="https://yuanblq.github.io/2017/04/10/%E8%AF%8D%E4%BA%91%E5%B0%8F%E4%BE%8B%E5%AD%90/"/>
    <id>https://yuanblq.github.io/2017/04/10/词云小例子/</id>
    <published>2017-04-10T14:52:09.000Z</published>
    <updated>2017-05-02T09:44:38.302Z</updated>
    
    <content type="html"><![CDATA[<p><font size="4">在<a href="/2017/04/03/WordCloud/" title="&nbsp;上一篇&nbsp;">&nbsp;上一篇&nbsp;</a>中介绍了 word cloud 的一些用法，下面是几个实战小例子。</font></p>
<h2 id="使用默认参数从文本中生成矩形词云"><a href="#使用默认参数从文本中生成矩形词云" class="headerlink" title="使用默认参数从文本中生成矩形词云"></a>使用默认参数从文本中生成矩形词云</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div></pre></td></tr></table></figure>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'JaneEyre.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    text = f.read()</div></pre></td></tr></table></figure>
<h3 id="生成词云图"><a href="#生成词云图" class="headerlink" title="生成词云图"></a>生成词云图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wordcloud = WordCloud().generate(text)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="展示生成的图片"><a href="#展示生成的图片" class="headerlink" title="展示生成的图片"></a>展示生成的图片</h3><h4 id="matplotlib-方式："><a href="#matplotlib-方式：" class="headerlink" title="matplotlib 方式："></a>matplotlib 方式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.imshow(wordcloud, interpolation=<span class="string">'bilinear'</span>)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2017/04/10/词云小例子/output_8_0.png" alt="png"></p>
<h5 id="把最大字体尺寸改小点"><a href="#把最大字体尺寸改小点" class="headerlink" title="把最大字体尺寸改小点"></a>把最大字体尺寸改小点</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wordcloud = WordCloud(max_font_size=<span class="number">40</span>).generate(text)</div><div class="line">plt.figure()</div><div class="line">plt.imshow(wordcloud, interpolation=<span class="string">'bilinear'</span>)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2017/04/10/词云小例子/output_10_0.png" alt="png"></p>
<h4 id="用PIL方式（这种方式需要有管理员权限才可以运行）："><a href="#用PIL方式（这种方式需要有管理员权限才可以运行）：" class="headerlink" title="用PIL方式（这种方式需要有管理员权限才可以运行）："></a>用PIL方式（这种方式需要有管理员权限才可以运行）：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 运行之后会自动打开生成的图片文件</span></div><div class="line">image = wordcloud.to_image()</div><div class="line">image.show()</div></pre></td></tr></table></figure>
<h2 id="在mask中生成词云图"><a href="#在mask中生成词云图" class="headerlink" title="在mask中生成词云图"></a>在mask中生成词云图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud, STOPWORDS</div></pre></td></tr></table></figure>
<h3 id="读取文本文件"><a href="#读取文本文件" class="headerlink" title="读取文本文件"></a>读取文本文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'JaneEyre.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    text = f.read()</div></pre></td></tr></table></figure>
<h3 id="读取用作mask的图片"><a href="#读取用作mask的图片" class="headerlink" title="读取用作mask的图片"></a>读取用作mask的图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> Image.open(<span class="string">'mask.jpg'</span>) <span class="keyword">as</span> p:</div><div class="line">    mask = np.array(p)</div></pre></td></tr></table></figure>
<h3 id="生成词云"><a href="#生成词云" class="headerlink" title="生成词云"></a>生成词云</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wc = WordCloud(background_color=<span class="string">'white'</span>, max_words=<span class="number">2000</span>, mask=mask)</div><div class="line">wc.generate(text)</div></pre></td></tr></table></figure>
<pre><code>&lt;wordcloud.wordcloud.WordCloud at 0x7c849b0&gt;
</code></pre><h3 id="存储到文件中"><a href="#存储到文件中" class="headerlink" title="存储到文件中"></a>存储到文件中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wc.to_file(<span class="string">'wc.png'</span>)</div></pre></td></tr></table></figure>
<pre><code>&lt;wordcloud.wordcloud.WordCloud at 0x7c849b0&gt;
</code></pre><h3 id="或者直接显示出来"><a href="#或者直接显示出来" class="headerlink" title="或者直接显示出来"></a>或者直接显示出来</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plt.imshow(wc, interpolation=<span class="string">'bilinear'</span>)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.figure()</div><div class="line">plt.imshow(mask, cmap=plt.cm.gray, interpolation=<span class="string">'bilinear'</span>)</div><div class="line">plt.axis(<span class="string">'off'</span>)</div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="/2017/04/10/词云小例子/output_11_0.png" alt="png"></p>
<p><img src="/2017/04/10/词云小例子/output_11_1.png" alt="png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;4&quot;&gt;在&lt;a href=&quot;/2017/04/03/WordCloud/&quot; title=&quot;&amp;nbsp;上一篇&amp;nbsp;&quot;&gt;&amp;nbsp;上一篇&amp;nbsp;&lt;/a&gt;中介绍了 word cloud 的一些用法，下面是几个实战小例子。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用默认参数从文本中生成矩形词云&quot;&gt;&lt;a href=&quot;#使用默认参数从文本中生成矩形词云&quot; class=&quot;headerlink&quot; title=&quot;使用默认参数从文本中生成矩形词云&quot;&gt;&lt;/a&gt;使用默认参数从文本中生成矩形词云&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; wordcloud &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; WordCloud&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;读取文件&quot;&gt;&lt;a href=&quot;#读取文件&quot; class=&quot;headerlink&quot; title=&quot;读取文件&quot;&gt;&lt;/a&gt;读取文件&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;with&lt;/span&gt; open(&lt;span class=&quot;string&quot;&gt;&#39;JaneEyre.txt&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; f:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    text = f.read()&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;生成词云图&quot;&gt;&lt;a href=&quot;#生成词云图&quot; class=&quot;headerlink&quot; title=&quot;生成词云图&quot;&gt;&lt;/a&gt;生成词云图&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;wordcloud = WordCloud().generate(text)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
      <category term="词云" scheme="https://yuanblq.github.io/tags/%E8%AF%8D%E4%BA%91/"/>
    
      <category term="wordcloud" scheme="https://yuanblq.github.io/tags/wordcloud/"/>
    
      <category term="mask" scheme="https://yuanblq.github.io/tags/mask/"/>
    
  </entry>
  
  <entry>
    <title>WordCloud</title>
    <link href="https://yuanblq.github.io/2017/04/03/WordCloud/"/>
    <id>https://yuanblq.github.io/2017/04/03/WordCloud/</id>
    <published>2017-04-03T12:55:52.000Z</published>
    <updated>2017-05-02T09:44:29.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wordcloud-的-API-Reference-分三部分："><a href="#Wordcloud-的-API-Reference-分三部分：" class="headerlink" title="Wordcloud 的 API Reference 分三部分："></a>Wordcloud 的 API Reference 分三部分：</h1><ul>
<li>WordCloud([font_path, width, height, …])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Word cloud对象，用于生成以及绘制</li>
<li>ImageColorGenerator(image)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于一个彩色图片的颜色生成器</li>
<li>random_color_func([word, font_size, …])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机色相生成器</li>
</ul>
<a id="more"></a>
<h2 id="wordcloud-WordCloud"><a href="#wordcloud-WordCloud" class="headerlink" title="wordcloud.WordCloud"></a>wordcloud.WordCloud</h2><p><table><tr><td bgcolor="#EEE8AA">class <font color="red"><b>wordcloud.WordCloud </b></font>(font_path=None, width=400, height=200, margin=2, ranks_only=None, prefer_horizontal=0.9, mask=None, scale=1, color_func=None, max_words=200, min_font_size=4, stopwords=None, random_state=None, background_color=’black’, max_font_size=None, font_step=1, mode=’RGB’, relative_scaling=0.5, regexp=None, collocations=True, colormap=None, normalize_plurals=True)<br></td></tr></table></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数:"></a>参数:</h3><h4 id="font-path-sting"><a href="#font-path-sting" class="headerlink" title="font_path : sting"></a>font_path : sting</h4><div class="note default"><p>字体的路径（OTF 或者 TTF 字体）。在Linux上默认为 DroidSansMono 路径，如果没有这个字体或者其它的 OS 操作系统，那就需要手动调整路径。</p>
</div>
<h4 id="width-int-default-400"><a href="#width-int-default-400" class="headerlink" title="width : int (default=400)"></a>width : int (default=400)</h4><div class="note default"><p>画布的宽度。</p>
</div>
<h4 id="height-int-default-200"><a href="#height-int-default-200" class="headerlink" title="height : int (default=200)"></a>height : int (default=200)</h4><div class="note default"><p>画布的高度。</p>
</div>
<h4 id="prefer-horizontal-float-default-0-9"><a href="#prefer-horizontal-float-default-0-9" class="headerlink" title="prefer_horizontal : float (default=0.9)"></a>prefer_horizontal : float (default=0.9)</h4><div class="note default"><p>水平词语占的比例，即最后词云图中以水平方式展现的词语占的比例。</p>
</div>
<h4 id="mask-nd-array-or-None-default-None"><a href="#mask-nd-array-or-None-default-None" class="headerlink" title="mask : nd-array or None (default=None)"></a>mask : nd-array or None (default=None)</h4><div class="note default"><p>如果不为None，那么就在这给定的二进制文件的mask上绘制词云，并且忽略 width 和 height 。<br>所有的白色区域（#FF 或者 #FFFFFF）都视为在mask外部，也就是不绘制词云。</p>
</div>
<h4 id="scale-float-default-1"><a href="#scale-float-default-1" class="headerlink" title="scale : float (default=1)"></a>scale : float (default=1)</h4><div class="note default"><p>当词云图片比较大时，不要使用大画布而是使用 scale 缩放。</p>
</div>
<h4 id="min-font-size-int-default-4"><a href="#min-font-size-int-default-4" class="headerlink" title="min_font_size : int (default=4)"></a>min_font_size : int (default=4)</h4><div class="note default"><p>所使用的最小尺寸的字体。当没有空间能容纳此尺寸的字体时，停止绘制词云。</p>
</div>
<h4 id="font-step-int-default-1"><a href="#font-step-int-default-1" class="headerlink" title="font_step : int (default=1)"></a>font_step : int (default=1)</h4><div class="note default"><p>字体大小渐变步长。</p>
</div>
<h4 id="max-words-number-default-200"><a href="#max-words-number-default-200" class="headerlink" title="max_words : number (default=200)"></a>max_words : number (default=200)</h4><div class="note default"><p>最大词数。</p>
</div>
<h4 id="stopwords-set-of-strings-or-None"><a href="#stopwords-set-of-strings-or-None" class="headerlink" title="stopwords : set of strings or None"></a>stopwords : set of strings or None</h4><div class="note default"><p>不计入的词语集合。</p>
</div>
<h4 id="background-color-color-value-default-”black”"><a href="#background-color-color-value-default-”black”" class="headerlink" title="background_color : color value (default=”black”)"></a>background_color : color value (default=”black”)</h4><div class="note default"><p>词云图的背景颜色。</p>
</div>
<h4 id="max-font-size-int-or-None-default-None"><a href="#max-font-size-int-or-None-default-None" class="headerlink" title="max_font_size : int or None (default=None)"></a>max_font_size : int or None (default=None)</h4><div class="note default"><p>最大词语的字体大小。如果为 None，则使用图片的 height。</p>
</div>
<h4 id="mode-string-default-”RGB”"><a href="#mode-string-default-”RGB”" class="headerlink" title="mode : string (default=”RGB”)"></a>mode : string (default=”RGB”)</h4><div class="note default"><p>当模式为 “RGBA” 时，可以生成透明背景，background_color 可以为 None。</p>
</div>
<h4 id="relative-scaling-float-default-0-5"><a href="#relative-scaling-float-default-0-5" class="headerlink" title="relative_scaling : float (default=0.5)"></a>relative_scaling : float (default=0.5)</h4><div class="note default"><p>为 0 时，字体大小只考虑词的频率排名。<br>为 1 时，某个词频率为其它词频率 2 倍时，该字体的大小也是它的 2 倍。<br>一般设为 0.5 比较合适。</p>
</div>
<h4 id="color-func-callable-default-None"><a href="#color-func-callable-default-None" class="headerlink" title="color_func : callable (default=None)"></a>color_func : callable (default=None)</h4><div class="note default"><p>带有 word, font_size, position, orientation, font_path, random_state 参数，给每个词返回 PIL 颜色的调用对象。<br>会覆盖 “colormap”。</p>
</div>
<h4 id="regexp-string-or-None-optional"><a href="#regexp-string-or-None-optional" class="headerlink" title="regexp : string or None (optional)"></a>regexp : string or None (optional)</h4><div class="note default"><p>分词规则。如果为 None ，则使用 r”\w[\w’]+”。</p>
</div>
<h4 id="collocations-bool-default-True"><a href="#collocations-bool-default-True" class="headerlink" title="collocations : bool (default=True)"></a>collocations : bool (default=True)</h4><div class="note default"><p>是否需要包括两个词组成的词语。</p>
</div>
<h4 id="colormap-string-or-matplotlib-colormap-default-”viridis”"><a href="#colormap-string-or-matplotlib-colormap-default-”viridis”" class="headerlink" title="colormap : string or matplotlib colormap (default=”viridis”)"></a>colormap : string or matplotlib colormap (default=”viridis”)</h4><div class="note default"><p>从中任意选取颜色来绘制每个词。如果 “color_func” 指定的话，则忽略此参数。</p>
</div>
<h4 id="normalize-plurals-bool-default-True"><a href="#normalize-plurals-bool-default-True" class="headerlink" title="normalize_plurals : bool (default=True)"></a>normalize_plurals : bool (default=True)</h4><div class="note default"><p>是否需要把词语的 ‘s’ 后缀移除，并将其加入没有 ‘s’ 后缀的词的统计中。</p>
</div>
<h4 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h4><div class="note default"><p>大尺寸的画布会使代码运行缓慢。如果需要一个大的词云图，那就用”小尺寸画布”和”scale参数”。</p>
</div>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="words-list-of-tuples-string-float"><a href="#words-list-of-tuples-string-float" class="headerlink" title="words_ : list of tuples (string, float)"></a>words_ : list of tuples (string, float)</h4><div class="note default"><p>带有频率的词语</p>
</div>
<h4 id="layout-list-of-tuples-string-int-int-int-int-color"><a href="#layout-list-of-tuples-string-int-int-int-int-color" class="headerlink" title="layout_ : list of tuples (string, int, (int, int), int ,color)"></a>layout_ : list of tuples (string, int, (int, int), int ,color)</h4><div class="note default"><p>编码拟合好的词云。每个词语的字符串、字号、位置、方向和颜色的编码。</p>
</div>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="init-font-path-None-width-400-…"><a href="#init-font-path-None-width-400-…" class="headerlink" title="init(font_path=None, width=400, …)"></a><strong>init</strong>(font_path=None, width=400, …)</h4><div class="note default"><p>Parameters :<br>font_path=None, width=400, height=200, margin=2, ranks_only=None, prefer_horizontal=0.9, mask=None, scale=1, color_func=None, max_words=200, min_font_size=4, stopwords=None, random_state=None, background_color=’black’, max_font_size=None, font_step=1, mode=’RGB’, relative_scaling=0.5, regexp=None, collocations=True, colormap=None, normalize_plurals=True</p>
</div>
<h4 id="fit-words-frequencies"><a href="#fit-words-frequencies" class="headerlink" title="fit_words (frequencies)"></a>fit_words (frequencies)</h4><div class="note default"><p>通过 words 和 frequencies 创建 word_cloud。<br>generate_from_frequencies 的别名。</p>
<p>Parameters : </p>
<ul>
<li>frequencies : tuples 数组 （一个包含 word 和 frequency 的 tuple）。</li>
</ul>
<p>Returns : self</p>
</div>
<h4 id="generate-text"><a href="#generate-text" class="headerlink" title="generate (text)"></a>generate (text)</h4><div class="note default"><p>通过 text 生成 wordcloud<br>generate_from_text 的别名。<br>调用了 process_text 和 generate_from_frequencies。</p>
<p>Returns : self</p>
</div>
<h4 id="generate-from-frequencies-frequencies-…"><a href="#generate-from-frequencies-frequencies-…" class="headerlink" title="generate_from_frequencies (frequencies[, …])"></a>generate_from_frequencies (frequencies[, …])</h4><div class="note default"><p>通过 words 和 frequencies 创建 word_cloud。</p>
<p>Parameters : </p>
<ul>
<li>frequencies : 一个 string to float 的词典 （包含 words 和相关的频率）。</li>
<li>max_font_size : int （使用 font-size 而不是 self.max_font_size）。</li>
</ul>
<p>Returns : self</p>
</div>
<h4 id="generate-from-text-text"><a href="#generate-from-text-text" class="headerlink" title="generate_from_text (text)"></a>generate_from_text (text)</h4><div class="note default"><p>通过 text 生成 wordcloud。<br>调用了 process_text 和 generate_from_frequencies。</p>
<p><b> 版本变化(1.2.2)： </b><br>generate_from_frequencies() 的参数不再返回 process_text()。</p>
<p>Returns : self</p>
</div>
<h4 id="process-text-text"><a href="#process-text-text" class="headerlink" title="process_text (text)"></a>process_text (text)</h4><div class="note default"><p>把长文本分割成词语，移除 stopwords。</p>
<p>Parameters : </p>
<ul>
<li>text : string （要处理的文本）。</li>
</ul>
<p>Returns : </p>
<ul>
<li>words : 相关频率标记的词</li>
<li><b>版本变化(1.2.2)：</b>返回类型从 tuples 的 list 变为 dict。</li>
</ul>
</div>
<h4 id="recolor-random-state-color-func-colormap"><a href="#recolor-random-state-color-func-colormap" class="headerlink" title="recolor ([random_state, color_func, colormap])"></a>recolor ([random_state, color_func, colormap])</h4><div class="note default"><p>给已存在的布局重新上色。</p>
<p>Parameters : </p>
<ul>
<li>random_state : RandomState, int or None, default=None（如果不为 None 即使用了确定的随机状态 ，那么给的 int 值即为 random 的 seed）。</li>
<li>color_func : function or None, default=None （从 word count, font size, position 和 orientation 生成新颜色的 function, 如果为 None 则使用 self.color_func ）。</li>
<li>colormap : string or matplotlib colormap, default=None （使用这个 colormap 生成新的 colors. 如果 color_func 指定了则忽略此参数。如果为 None 则使用 self.color_func 或者 self.color_map ）。</li>
</ul>
<p>Returns : self</p>
</div>
<h4 id="to-array"><a href="#to-array" class="headerlink" title="to_array ()"></a>to_array ()</h4><div class="note default"><p>转换成 numpy 数组。</p>
<p>Returns : </p>
<ul>
<li>image : nd-array size (width, height, 3) （numpy 矩阵的词云图）。</li>
</ul>
</div>
<h4 id="to-file-filename"><a href="#to-file-filename" class="headerlink" title="to_file (filename)"></a>to_file (filename)</h4><div class="note default"><p>导出为图片文件。</p>
<p>Parameters : filename : string （写入位置）。</p>
<p>Returns : self</p>
</div>
<h4 id="to-html"><a href="#to-html" class="headerlink" title="to_html ()"></a>to_html ()</h4><h4 id="to-image"><a href="#to-image" class="headerlink" title="to_image ()"></a>to_image ()</h4><h2 id="wordcloud-ImageColorGenerator"><a href="#wordcloud-ImageColorGenerator" class="headerlink" title="wordcloud.ImageColorGenerator"></a>wordcloud.ImageColorGenerator</h2><p><table><tr><td bgcolor="#EEE8AA">class <font color="red"><b>wordcloud.ImageColorGenerator </b></font>(image)<br></td></tr></table><br>颜色生成器基于一张 RGB 颜色的图片。词的颜色由它所在图片中附近的颜色的均值决定。<br>生成之后，该对象可以作为 color_func 传入 wordcloud 构造器中，或者 recolor 方法中。</p>
<p>Parameters : </p>
<ul>
<li>image : nd-array, shape (height, width, 3)<div class="note default"><p>image 是用来生成词的颜色。忽略 Alpha 通道。 image应与画布大小尺寸一致。</p>
</div>
</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="call-word-font-size-font-path-…"><a href="#call-word-font-size-font-path-…" class="headerlink" title="call (word, font_size, font_path, …)"></a><strong>call</strong> (word, font_size, font_path, …)</h4><p>使用固定的图片给指定的词生成颜色。</p>
<h4 id="init-image"><a href="#init-image" class="headerlink" title="init (image)"></a><strong>init</strong> (image)</h4><h2 id="wordcloud-random-color-func"><a href="#wordcloud-random-color-func" class="headerlink" title="wordcloud.random_color_func"></a>wordcloud.random_color_func</h2><p><table><tr><td bgcolor="#EEE8AA"><font color="red"><b>wordcloud.random_color_func </b></font>(word=None, font_size=None, position=None, orientation=None, font_path=None, random_state=None)<br></td></tr></table><br>随机色相生成器。<br>默认的上色方法。该方法采取 80% 的色相和 50% 的亮度。</p>
<p>Parameters : </p>
<ul>
<li>word</li>
<li>font_size</li>
<li>position</li>
<li>orientation : ignored</li>
<li>random_state : random.Random 对象或者 None，默认为 None（如果指定了 random 对象，则使用此生成随机数）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Wordcloud-的-API-Reference-分三部分：&quot;&gt;&lt;a href=&quot;#Wordcloud-的-API-Reference-分三部分：&quot; class=&quot;headerlink&quot; title=&quot;Wordcloud 的 API Reference 分三部分：&quot;&gt;&lt;/a&gt;Wordcloud 的 API Reference 分三部分：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;WordCloud([font_path, width, height, …])&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Word cloud对象，用于生成以及绘制&lt;/li&gt;
&lt;li&gt;ImageColorGenerator(image)&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;基于一个彩色图片的颜色生成器&lt;/li&gt;
&lt;li&gt;random_color_func([word, font_size, …])&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;随机色相生成器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="模块文档" scheme="https://yuanblq.github.io/categories/%E6%A8%A1%E5%9D%97%E6%96%87%E6%A1%A3/"/>
    
      <category term="document" scheme="https://yuanblq.github.io/categories/%E6%A8%A1%E5%9D%97%E6%96%87%E6%A1%A3/document/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
      <category term="词云" scheme="https://yuanblq.github.io/tags/%E8%AF%8D%E4%BA%91/"/>
    
      <category term="wordcloud" scheme="https://yuanblq.github.io/tags/wordcloud/"/>
    
  </entry>
  
  <entry>
    <title>三门问题</title>
    <link href="https://yuanblq.github.io/2017/03/25/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://yuanblq.github.io/2017/03/25/三门问题/</id>
    <published>2017-03-25T12:07:45.000Z</published>
    <updated>2017-03-26T02:33:11.925Z</updated>
    
    <content type="html"><![CDATA[<div class="note info"><p>三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？</p>
</div>
<a id="more"></a>
<h5 id="如果假设只是从三扇门中选，没有交换，则："><a href="#如果假设只是从三扇门中选，没有交换，则：" class="headerlink" title="如果假设只是从三扇门中选，没有交换，则："></a>如果假设只是从三扇门中选，没有交换，则：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">total = <span class="number">100000</span></div><div class="line">bingo = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total):</div><div class="line">    my_choice = random.randint(<span class="number">0</span>, <span class="number">2</span>)</div><div class="line">    car = random.randint(<span class="number">0</span>, <span class="number">2</span>)</div><div class="line">    <span class="keyword">if</span> my_choice == car:</div><div class="line">        bingo += <span class="number">1</span></div><div class="line">print(<span class="string">"一共选中 %d 次"</span> % bingo)</div><div class="line">print(<span class="string">"选中概率为：%.2f"</span> %(bingo / total))</div></pre></td></tr></table></figure>
<pre><code>一共选中 33164 次
选中概率为：0.33
</code></pre><h5 id="加上询问交换这一流程后："><a href="#加上询问交换这一流程后：" class="headerlink" title="加上询问交换这一流程后："></a>加上询问交换这一流程后：</h5><ul>
<li>先从三扇门中选一个</li>
<li>然后主持人在剩下的两扇门中选一个打开</li>
<li>询问是否更换：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">total = <span class="number">100000</span></div><div class="line">bingo_change = <span class="number">0</span></div><div class="line">change = <span class="number">0</span></div><div class="line">bingo_not_change = <span class="number">0</span></div><div class="line">not_change = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total):</div><div class="line">    car = random.randint(<span class="number">0</span>, <span class="number">2</span>)</div><div class="line">    my_choice = random.randint(<span class="number">0</span>, <span class="number">2</span>)</div><div class="line">    is_switch = random.choice([<span class="keyword">True</span>, <span class="keyword">False</span>])</div><div class="line">    <span class="keyword">if</span> is_switch:</div><div class="line">        change += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> my_choice != car:</div><div class="line">            bingo_change += <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        not_change += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> my_choice == car:</div><div class="line">            bingo_not_change += <span class="number">1</span></div><div class="line">print(<span class="string">"选手更换了 %d 次，选对的次数：%d，即选中的概率为：%.2f"</span> % (change, bingo_change, bingo_change / change))</div><div class="line">print(<span class="string">"选手不更换 %d 次，选对的次数：%d，即选中的概率为：%.2f"</span> % (not_change, bingo_not_change, bingo_not_change / not_change))</div></pre></td></tr></table></figure>
<pre><code>选手更换了 49956 次，选对的次数：33180，即选中的概率为：0.66
选手不更换 50044 次，选对的次数：16677，即选中的概率为：0.33
</code></pre><h5 id="通过暴力计算，可见三门问题的结论就一个字：换。"><a href="#通过暴力计算，可见三门问题的结论就一个字：换。" class="headerlink" title="通过暴力计算，可见三门问题的结论就一个字：换。"></a>通过暴力计算，可见三门问题的结论就一个字：换。</h5><h5 id="有位知友-“邢可”-的答案把三门问题解释得很形象。"><a href="#有位知友-“邢可”-的答案把三门问题解释得很形象。" class="headerlink" title="有位知友 “邢可” 的答案把三门问题解释得很形象。"></a>有位知友<a href="https://www.zhihu.com/question/26709273/answer/65418012?utm_source=com.samsung.android.app.memo&utm_medium=social" target="_blank" rel="external"> “邢可” </a>的答案把三门问题解释得很形象。</h5>]]></content>
    
    <summary type="html">
    
      &lt;div class=&quot;note info&quot;&gt;&lt;p&gt;三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？&lt;/p&gt;
&lt;/div&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://yuanblq.github.io/tags/python/"/>
    
      <category term="三门问题" scheme="https://yuanblq.github.io/tags/%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
