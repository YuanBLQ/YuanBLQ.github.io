<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanblq.github.io/"/>
  <updated>2018-07-31T04:01:26.000Z</updated>
  <id>https://yuanblq.github.io/</id>
  
  <author>
    <name>Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Channel实战-聊天服务器-P02</title>
    <link href="https://yuanblq.github.io/2018/07/31/Channel%E5%AE%9E%E6%88%98-Part02/"/>
    <id>https://yuanblq.github.io/2018/07/31/Channel实战-Part02/</id>
    <published>2018-07-31T07:33:41.000Z</published>
    <updated>2018-07-31T04:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中我们已经把基本的环境配置都弄好了。</p>
<p>现在我们就正式进入正题，搭建我们的聊天服务器。</p>
<a id="more"></a>
<h4 id="实现一个聊天服务器"><a href="#实现一个聊天服务器" class="headerlink" title="实现一个聊天服务器"></a>实现一个聊天服务器</h4><h5 id="添加一个聊天室视图"><a href="#添加一个聊天室视图" class="headerlink" title="添加一个聊天室视图"></a>添加一个聊天室视图</h5><p>现在我们再创建第二个视图，我们可以在里面发送我们想要发送的消息。</p>
<p>我们现在创建这个文件 <code>chat/templates/chat/room.html</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- chat/templates/chat/room.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat Room<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"chat-log"</span> <span class="attr">cols</span>=<span class="string">"100"</span> <span class="attr">rows</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"chat-message-input"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"100"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"chat-message-submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Send"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">    var roomName = &#123;&#123; room_name_json &#125;&#125;;</div><div class="line"></div><div class="line">    var chatSocket = new WebSocket(</div><div class="line">        'ws://' + window.location.host +</div><div class="line">        '/ws/chat/' + roomName + '/');</div><div class="line"></div><div class="line">    chatSocket.onmessage = function(e) &#123;</div><div class="line">        var data = JSON.parse(e.data);</div><div class="line">        var message = data['message'];</div><div class="line">        document.querySelector('#chat-log').value += (message + '\n');</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    chatSocket.onclose = function(e) &#123;</div><div class="line">        console.error('Chat socket closed unexpectedly');</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    document.querySelector('#chat-message-input').focus();</div><div class="line">    document.querySelector('#chat-message-input').onkeyup = function(e) &#123;</div><div class="line">        if (e.keyCode === 13) &#123;  // enter, return</div><div class="line">            document.querySelector('#chat-message-submit').click();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    document.querySelector('#chat-message-submit').onclick = function(e) &#123;</div><div class="line">        var messageInputDom = document.querySelector('#chat-message-input');</div><div class="line">        var message = messageInputDom.value;</div><div class="line">        chatSocket.send(JSON.stringify(&#123;</div><div class="line">            'message': message</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        messageInputDom.value = '';</div><div class="line">    &#125;;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后在 <code>view.py</code> 中创建视图函数，为了安全起见，我们需要对房间名做个安全操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/views.py</span></div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> render(request, <span class="string">'chat/index.html'</span>, &#123;&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">room</span><span class="params">(request, room_name)</span>:</span></div><div class="line">    <span class="keyword">return</span> render(request, <span class="string">'chat/room.html'</span>, &#123;</div><div class="line">        <span class="string">'room_name_json'</span>: mark_safe(json.dumps(room_name))</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>最后，我们来创建这个路由：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/urls.py</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</div><div class="line"></div><div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(<span class="string">r'^$'</span>, views.index, name=<span class="string">'index'</span>),</div><div class="line">    url(<span class="string">r'^(?P&lt;room_name&gt;[^/]+)/$'</span>, views.room, name=<span class="string">'room'</span>),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>OK，启动测试服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>在浏览器输入 <code>http://127.0.0.1:8000/chat/</code>，然后输入“lobby”按回车，就会跳转到 <code>http://127.0.0.1:8000/chat/lobby/</code> 这个聊天页面。</p>
<p>我们输入“Hello”，然后按回车。</p>
<p>咦？什么也没有发生，甚至还出现了这行 log：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2018/07/31 09:25:49] WebSocket DISCONNECT /ws/chat/lobby/ [127.0.0.1:51241]</div></pre></td></tr></table></figure></p>
<p>到底什么情况，哪出错了？</p>
<p>当我们按下回车发送消息的时候会打开连向 <code>ws://127.0.0.1:8000/ws/chat/lobby/</code> 的一个 WebSocket，但是我们还没创建消费者来接收这个 WebSocket 连接。</p>
<h5 id="创建第一个消费者"><a href="#创建第一个消费者" class="headerlink" title="创建第一个消费者"></a>创建第一个消费者</h5><p>和 Django 接收 HTTP 请求之后根据 URLconf 找到对应的 view 视图一样，当 channel 接收到一个 WebSocket 连接之后，也需要根据 routing 配置找到对应的消费者去处理各种到来的事件。</p>
<p>现在我们来创建一个连向 <code>/ws/chat/ROOM_NAME/</code> WebSocket 的一个消费者，并把接收到的聊天信息原样返回回去。</p>
<p>创建一个新文件 <code>chat/consumers.py</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/consumers.py</span></div><div class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatConsumer</span><span class="params">(WebsocketConsumer)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></div><div class="line">        self.accept()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, close_code)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data)</span>:</span></div><div class="line">        text_data_json = json.loads(text_data)</div><div class="line">        message = text_data_json[<span class="string">'message'</span>]</div><div class="line"></div><div class="line">        self.send(text_data=json.dumps(&#123;</div><div class="line">            <span class="string">'message'</span>: message</div><div class="line">        &#125;))</div></pre></td></tr></table></figure></p>
<p>然后和 Django 的 URLconf 一样，我们也在各个 APP 中创建对应的 <code>routing.py</code> 文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/routing.py</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</div><div class="line"></div><div class="line"><span class="keyword">from</span> chat <span class="keyword">import</span> consumers</div><div class="line"></div><div class="line">websocket_urlpatterns = [</div><div class="line">    url(<span class="string">r'^ws/chat/(?P&lt;room_name&gt;[^/]+)/$'</span>, consumers.ChatConsumer),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>下一步，就是要在项目的 <code>routing.py</code> 文件中加入我们 <code>chat.routing</code> 配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/routing.py</span></div><div class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> AuthMiddlewareStack</div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter, URLRouter</div><div class="line"><span class="keyword">import</span> chat.routing</div><div class="line"></div><div class="line">application = ProtocolTypeRouter(&#123;</div><div class="line">    <span class="comment"># (http-&gt;django views is added by default)</span></div><div class="line">    <span class="string">'websocket'</span>: AuthMiddlewareStack(</div><div class="line">        URLRouter(</div><div class="line">            chat.routing.websocket_urlpatterns</div><div class="line">        )</div><div class="line">    ),</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这个路由配置表示：如果接收到一个发至 channels 服务器的一个连接，<code>ProtocolTypeRouter</code> 会先检查这个连接的类型。如果是一个 WebSocket 连接（ws:// 或者 wss://），该连接就会给到 <code>AuthMiddlewareStack</code> 去处理。</p>
<p><code>AuthMiddlewareStack</code> 能从连接的 <code>scope</code> 中拿到当前验证的用户对象，就像 Django 的 <code>AuthenticationMiddleware</code> 从 <code>request</code> 中拿到验证的用户对象一样。</p>
<p>然后该连接继续传给 <code>URLRouter</code>。</p>
<p><code>URLRouter</code> 就会最终路由到对应的消费者。</p>
<p>现在我们再次启动测试服务器验证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>现在我们再试着之前的操作，在聊天页面输入聊天信息，之后回车，是不是很神奇，我们的聊天内容果真发出去了。</p>
<p>不要高兴的太早！</p>
<p>试着再打开一个同名的 <code>lobby</code> 聊天室，模拟下多人在同一个聊天室能否互相聊天。</p>
<p>哈哈哈，不行吧。</p>
<p>这时，我们就需要引入 <code>channel layer</code> 这一抽象概念，来帮我们在同一个消费者的多个实例中传递数据。</p>
<h5 id="搞定-channel-layer"><a href="#搞定-channel-layer" class="headerlink" title="搞定 channel layer"></a>搞定 channel layer</h5><p>channel layer 是一种通信系统。它能让你能在多个消费者实例间互相通信。</p>
<p><code>channel layer</code> 包含两个抽象概念：</p>
<ul>
<li><code>channel</code> 类似于邮箱，我们要通信的消息会发往这里。每个 <code>channel</code> 都有一个独一无二的名字，只要我们拥有这个名字，就能往这里发消息。</li>
<li><code>group</code> 是一组相关 <code>channel</code> 的集合。同样 <code>group</code> 也有名字，拥有这个名字，我们就能往里面添加删除 <code>channel</code>，并且能往该 <code>group</code> 中所有的 <code>channel</code> 发送消息。</li>
</ul>
<p>每个消费者实例都会自动生成唯一的 channel 名字，我们就可以用它在 channel layer 中进行通信。</p>
<p>因此，我们把每个 <code>ChatConsumer</code> 的 channel 添加到以 room 名字命名的 group 中，这样在同一个房间的 <code>ChatConsumer</code> 可以互相通信了。</p>
<p>在用 channel layer 之前，我们还需要用到 Redis 作为后端存储。</p>
<p>方便起见，我们可以直接用 Docker 起一个 Redis 服务：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker run -p 6379:6379 <span class="_">-d</span> redis</div></pre></td></tr></table></figure></p>
<p>然后，我们还需要安装 <code>channels_redis</code> 来让我们的 channel 和 redis 进行通信：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install channels_redis</div></pre></td></tr></table></figure></p>
<p>最后，需要在项目的 <code>settings.py</code> 中添加如下配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/settings.py</span></div><div class="line"><span class="comment"># Channels</span></div><div class="line">ASGI_APPLICATION = <span class="string">'WSChat.routing.application'</span></div><div class="line">CHANNEL_LAYERS = &#123;</div><div class="line">    <span class="string">'default'</span>: &#123;</div><div class="line">        <span class="string">'BACKEND'</span>: <span class="string">'channels_redis.core.RedisChannelLayer'</span>,</div><div class="line">        <span class="string">'CONFIG'</span>: &#123;</div><div class="line">            <span class="string">"hosts"</span>: [(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>)],</div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一切安装完之后，我们进入 Django 的 shell 环境验证下有没有安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ python manage.py shell</div><div class="line">In [1]: import channels.layers</div><div class="line"></div><div class="line">In [2]: channel_layer = channels.layers.get_channel_layer()</div><div class="line"></div><div class="line">In [3]: from asgiref.sync import async_to_sync</div><div class="line"></div><div class="line">In [4]: async_to_sync(channel_layer.send)(<span class="string">'test_channel'</span>, &#123;<span class="string">'type'</span>: <span class="string">'hello'</span>&#125;)</div><div class="line"></div><div class="line">In [5]: async_to_sync(channel_layer.receive)(<span class="string">'test_channel'</span>)</div><div class="line">Out[5]: &#123;<span class="string">'type'</span>: <span class="string">'hello'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们就来改造一下之前的 <code>ChatConsumer</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/consumers.py</span></div><div class="line"><span class="keyword">from</span> asgiref.sync <span class="keyword">import</span> async_to_sync</div><div class="line"><span class="keyword">from</span> channels.generic.websocket <span class="keyword">import</span> WebsocketConsumer</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatConsumer</span><span class="params">(WebsocketConsumer)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self)</span>:</span></div><div class="line">        self.room_name = self.scope[<span class="string">'url_route'</span>][<span class="string">'kwargs'</span>][<span class="string">'room_name'</span>]</div><div class="line">        self.room_group_name = <span class="string">'chat_%s'</span> % self.room_name</div><div class="line"></div><div class="line">        <span class="comment"># 将当前 channel 对象加入 group</span></div><div class="line">        async_to_sync(self.channel_layer.group_add)(</div><div class="line">            self.room_group_name,</div><div class="line">            self.channel_name</div><div class="line">        )</div><div class="line"></div><div class="line">        self.accept()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">disconnect</span><span class="params">(self, close_code)</span>:</span></div><div class="line">        <span class="comment"># Leave room group</span></div><div class="line">        async_to_sync(self.channel_layer.group_discard)(</div><div class="line">            self.room_group_name,</div><div class="line">            self.channel_name</div><div class="line">        )</div><div class="line"></div><div class="line">    <span class="comment"># 从 WebSocket 接收消息</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">receive</span><span class="params">(self, text_data)</span>:</span></div><div class="line">        text_data_json = json.loads(text_data)</div><div class="line">        message = text_data_json[<span class="string">'message'</span>]</div><div class="line"></div><div class="line">        <span class="comment"># 将消息发往 group，以便同一聊天室的大家都能收到消息</span></div><div class="line">        async_to_sync(self.channel_layer.group_send)(</div><div class="line">            self.room_group_name,</div><div class="line">            &#123;</div><div class="line">                <span class="string">'type'</span>: <span class="string">'chat_message'</span>,</div><div class="line">                <span class="string">'message'</span>: message</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line"></div><div class="line">    <span class="comment"># 从 group 接收消息</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chat_message</span><span class="params">(self, event)</span>:</span></div><div class="line">        message = event[<span class="string">'message'</span>]</div><div class="line"></div><div class="line">        <span class="comment"># 将消息发往 WebSocket</span></div><div class="line">        self.send(text_data=json.dumps(&#123;</div><div class="line">            <span class="string">'message'</span>: message</div><div class="line">        &#125;))</div></pre></td></tr></table></figure></p>
<p>整个聊天流程是这样的：</p>
<ul>
<li>一个用户发送一条消息，JS 函数把这条消息通过 WebSocket 传递给 ChatConsumer。</li>
<li>ChatConsumer 收到消息后，将消息转到对应的聊天室 group。</li>
<li>在同一 group 的 ChatConsumer 从 group 收到消息后会通过 WebSocket 把消息转给 JS，最终呈现在前端。</li>
</ul>
<p>关于上面的代码还有几点需要解释一下：</p>
<ul>
<li><p>self.scope[‘url_route’][‘kwargs’][‘room_name’]</p>
<ul>
<li>从 <code>chat/routing.py</code> 路由中获取 <code>room_name</code> 参数</li>
<li>每个消费者都有一个 <code>scope</code> 参数，包含了连接相关的信息，还有来自 URLRouter 的位置参数和关键字参数，以及当前用户对象</li>
</ul>
</li>
<li><p>self.room_group<em>name=’chat</em>%s’ % self.room_name</p>
<ul>
<li>通过用户指定的房间名构造一个 channel 的 group 名字</li>
<li>注意：group 名字只能包含字母、数字、连字符和句点</li>
</ul>
</li>
<li><p>async_to_sync(self.channel_layer.group_add)(…)</p>
<ul>
<li>加入一个 group</li>
<li>因为我们的 ChatConsumer 是一个同步的消费者，所有有必要调用 <code>async_to_sync(...)</code> 装饰器。（所有的 channel layer 方法都是异步的）</li>
</ul>
</li>
<li><p>self.accept()</p>
<ul>
<li>接收 WebSocket 连接</li>
<li>如果不在 <code>connect()</code> 方法中调用 <code>accept()</code>，那么该连接将会被拒绝并关闭。比如，当用户未验证身份时，你可以拒绝连接</li>
<li>推荐在 <code>connect()</code> 方法的最后再去调用 <code>accept()</code></li>
</ul>
</li>
<li><p>async_to_sync(self.channel_layer.group_discard)(…)</p>
<ul>
<li>退出 group</li>
</ul>
</li>
<li><p>async_to_sync(self.channel_layer.group_send)</p>
<ul>
<li>往 group 发送一个事件</li>
<li>每个事件都有一个 <code>type</code> 的特殊关键key，表示该事件将会去调用这个消费者中哪个名字的方法来处理这个事件</li>
</ul>
</li>
</ul>
<p>OK，我们来验证下是否好用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>打开两个浏览器页面进入 <code>http://127.0.0.1:8000/chat/lobby/</code> 页面，试着在两个页面分别输入消息，看看是否都能收到消息。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://channels.readthedocs.io/en/latest/tutorial/part_2.html" target="_blank" rel="external">Channels</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中我们已经把基本的环境配置都弄好了。&lt;/p&gt;
&lt;p&gt;现在我们就正式进入正题，搭建我们的聊天服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="实战" scheme="https://yuanblq.github.io/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="Channel" scheme="https://yuanblq.github.io/tags/Channel/"/>
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Channel实战-聊天服务器-P01</title>
    <link href="https://yuanblq.github.io/2018/07/30/Channel%E5%AE%9E%E6%88%98-Part01/"/>
    <id>https://yuanblq.github.io/2018/07/30/Channel实战-Part01/</id>
    <published>2018-07-30T03:48:25.000Z</published>
    <updated>2018-07-31T04:00:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本系列，我们将会构建一个基于 WebSocket 的聊天服务器。</p>
<p>一共只有两个页面：</p>
<ul>
<li>输入要加入聊天室的名称</li>
<li>具体聊天室的聊天页面</li>
</ul>
<a id="more"></a>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>本系列环境要求：</p>
<blockquote>
<p>Python &gt;= 3.5<br>Django &gt;= 1.11<br>channels &gt;= 2.0</p>
</blockquote>
<h5 id="创建一个-Django-项目"><a href="#创建一个-Django-项目" class="headerlink" title="创建一个 Django 项目"></a>创建一个 Django 项目</h5><p>在一个合适的目录创建我们即将使用的新项目：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ django-admin startproject WSChat</div></pre></td></tr></table></figure></p>
<p>这时，我们的目录结构应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WSChat/</div><div class="line">    manage.py</div><div class="line">    WSChat/</div><div class="line">        __init__.py</div><div class="line">        settings.py</div><div class="line">        urls.py</div><div class="line">        wsgi.py</div></pre></td></tr></table></figure></p>
<h5 id="创建-Chat-APP"><a href="#创建-Chat-APP" class="headerlink" title="创建 Chat APP"></a>创建 Chat APP</h5><p>我们会把聊天相关的服务都放在这个 APP 内：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py startapp chat</div></pre></td></tr></table></figure></p>
<p>此时会多出一个这样的 <code>chat</code> 文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">chat/</div><div class="line">    __init__.py</div><div class="line">    admin.py</div><div class="line">    apps.py</div><div class="line">    migrations/</div><div class="line">        __init__.py</div><div class="line">    models.py</div><div class="line">    tests.py</div><div class="line">    views.py</div></pre></td></tr></table></figure></p>
<p>然后我们需要让 Django 知道我们刚创建的 <code>chat</code> APP。</p>
<p>在 <code>WSChat/settings.py</code> 文件的 <code>INSTALLED_APPS</code> 配置中添加 <code>chat</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/settings.py</span></div><div class="line">INSTALLED_APPS = [</div><div class="line">    <span class="string">'chat'</span>,</div><div class="line">    <span class="string">'django.contrib.admin'</span>,</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.messages'</span>,</div><div class="line">    <span class="string">'django.contrib.staticfiles'</span>,</div><div class="line">]</div></pre></td></tr></table></figure></p>
<h5 id="添加主页面"><a href="#添加主页面" class="headerlink" title="添加主页面"></a>添加主页面</h5><p>现在我们需要创建一个主页面，能让我们输入要加入的聊天室名字。</p>
<p>在 <code>chat</code> 文件夹内创建 <code>templates</code> 文件夹，在 <code>templates</code> 文件夹内创建 <code>chat</code> 文件夹，最后，在刚建的 <code>chat</code> 文件夹创建 <code>index.html</code> 文件。</p>
<p>最终， <code>chat</code> 文件夹可能长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">chat/</div><div class="line">    __init__.py</div><div class="line">    templates/</div><div class="line">        chat/</div><div class="line">            index.html</div><div class="line">    admin.py</div><div class="line">    apps.py</div><div class="line">    migrations/</div><div class="line">        __init__.py</div><div class="line">    models.py</div><div class="line">    tests.py</div><div class="line">    views.py</div></pre></td></tr></table></figure></p>
<p>然后我们把下面代码放进刚创建的 <code>index.html</code> 文件内：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- chat/templates/chat/index.html --&gt;</span></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Chat Rooms<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    What chat room would you like to enter?<span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"room-name-input"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"100"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"room-name-submit"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Enter"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line">        document.querySelector('#room-name-input').focus();</div><div class="line">        document.querySelector('#room-name-input').onkeyup = function(e) &#123;</div><div class="line">            if (e.keyCode === 13) &#123;  // enter, return</div><div class="line">                document.querySelector('#room-name-submit').click();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        document.querySelector('#room-name-submit').onclick = function(e) &#123;</div><div class="line">            var roomName = document.querySelector('#room-name-input').value;</div><div class="line">            window.location.pathname = '/chat/' + roomName + '/';</div><div class="line">        &#125;;</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>接着，我们在 <code>chat/view.py</code> 文件内创建我们的视图函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/views.py</span></div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> render(request, <span class="string">'chat/index.html'</span>, &#123;&#125;)</div></pre></td></tr></table></figure></p>
<p>最后，配置我们的路由地址。</p>
<p>先在 <code>chat</code> APP 内创建 <code>urls.py</code> 文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># chat/urls.py</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> url</div><div class="line"></div><div class="line"><span class="keyword">from</span> chat <span class="keyword">import</span> views</div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(<span class="string">r'^$'</span>, views.index, name=<span class="string">'index'</span>),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>然后，在项目的 <code>urls.py</code> 文件中创建以下路由代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/urls.py</span></div><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> include, url</div><div class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(<span class="string">r'^chat/'</span>, include(<span class="string">'chat.urls'</span>)),</div><div class="line">    url(<span class="string">r'^admin/'</span>, admin.site.urls),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>好了，我们现在启动测试服务器验证一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver</div></pre></td></tr></table></figure></p>
<p>你可能会在终端看到如下的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Performing system checks...</div><div class="line"></div><div class="line">System check identified no issues (0 silenced).</div><div class="line"></div><div class="line">You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.</div><div class="line">Run &apos;python manage.py migrate&apos; to apply them.</div><div class="line"></div><div class="line">July 30, 2018 - 03:37:32</div><div class="line">Django version 2.0.7, using settings &apos;JTChannel.settings&apos;</div><div class="line">Starting development server at http://0.0.0.0:8000/</div><div class="line">Quit the server with CONTROL-C.</div></pre></td></tr></table></figure></p>
<p>在浏览器输入 <code>http://127.0.0.1:8000/chat/</code> 就可以看见带“What chat room would you like to enter?”这句话的输入框。</p>
<p>我们输入“lobby”并回车，我们发现我们的页面地址跳转到了 <code>http://127.0.0.1:8000/chat/lobby/</code>，但我们现在还没写这个页面，所有会出现“Page not found”的错误页面。</p>
<h5 id="集成-channel-库"><a href="#集成-channel-库" class="headerlink" title="集成 channel 库"></a>集成 channel 库</h5><p>首先，像配置 Django 的 URLconf 一样，配置 channels 的 routing 配置。</p>
<p>这样，当 Channels 服务器收到 HTTP 请求之后，就能知道需要执行哪段代码。</p>
<p>现在，我们现在 <code>WSChat/routing.py</code> 文件中创建一下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> ProtocolTypeRouter</div><div class="line"></div><div class="line"></div><div class="line">application = ProtocolTypeRouter(&#123;</div><div class="line">    <span class="comment">#  (http-&gt;django views is added by default)</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>然后，我们要在 <code>settings.py</code> 配置的 <code>INSTALLED_APPS</code> 中加上我们的 <code>channels</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/settings.py</span></div><div class="line">INSTALLED_APPS = [</div><div class="line">    <span class="string">'channels'</span>,</div><div class="line">    <span class="string">'chat'</span>,</div><div class="line">    <span class="string">'django.contrib.admin'</span>,</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.messages'</span>,</div><div class="line">    <span class="string">'django.contrib.staticfiles'</span>,</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>最后需要像 WSGI 一样，告诉 Django 我们 channels 的根路由配置文件在哪：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># WSChat/settings.py</span></div><div class="line"><span class="comment"># Channels</span></div><div class="line">ASGI_APPLICATION = <span class="string">'WSChat.routing.application'</span></div></pre></td></tr></table></figure></p>
<p>最后我们再来启动测试服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Performing system checks...</div><div class="line"></div><div class="line">System check identified no issues (0 silenced).</div><div class="line"></div><div class="line">You have 14 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.</div><div class="line">Run &apos;python manage.py migrate&apos; to apply them.</div><div class="line"></div><div class="line">July 30, 2018 - 03:37:32</div><div class="line">Django version 2.0.7, using settings &apos;JTChannel.settings&apos;</div><div class="line">Starting ASGI/Channels version 2.1.2 development server at http://0.0.0.0:8000/</div><div class="line">Quit the server with CONTROL-C.</div><div class="line">2018-07-30 03:37:32,233 - INFO - server - HTTP/2 support not enabled (install the http2 and tls Twisted extras)</div><div class="line">2018-07-30 03:37:32,233 - INFO - server - Configuring endpoint tcp:port=8000:interface=0.0.0.0</div><div class="line">2018-07-30 03:37:32,236 - INFO - server - Listening on TCP address 0.0.0.0:8000</div></pre></td></tr></table></figure>
<p>这时，如果你看见这段话 <code>Starting ASGI/Channels version 2.1.2 development server at http://0.0.0.0:8000/</code> 说明 channel 已经接管了 Django 的测试服务器。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul>
<li><a href="https://channels.readthedocs.io/en/latest/tutorial/part_1.html" target="_blank" rel="external">Channels</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列，我们将会构建一个基于 WebSocket 的聊天服务器。&lt;/p&gt;
&lt;p&gt;一共只有两个页面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入要加入聊天室的名称&lt;/li&gt;
&lt;li&gt;具体聊天室的聊天页面&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="实战" scheme="https://yuanblq.github.io/categories/%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="Channel" scheme="https://yuanblq.github.io/tags/Channel/"/>
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow-01-预测房价</title>
    <link href="https://yuanblq.github.io/2018/07/27/TensorFlow-01-%E9%A2%84%E6%B5%8B%E6%88%BF%E4%BB%B7/"/>
    <id>https://yuanblq.github.io/2018/07/27/TensorFlow-01-预测房价/</id>
    <published>2018-07-27T09:44:16.000Z</published>
    <updated>2018-07-27T09:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习目标：</p>
<ul>
<li>学习基本的 TensorFlow 概念</li>
<li>在 TensorFlow 中使用 LinearRegressor 类并基于单个输入特征预测各城市街区的房屋价值中位数</li>
<li>使用均方根误差 (RMSE) 评估模型预测的准确率</li>
<li>通过调整模型的超参数提高模型准确率</li>
</ul>
<a id="more"></a>
<h4 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">house_data = pd.read_csv(<span class="string">"https://dl.google.com/mlcc/mledu-datasets/california_housing_train.csv"</span>, sep=<span class="string">","</span>)</div><div class="line"></div><div class="line">print(house_data)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">       longitude         ...          median_house_value</div><div class="line">0         -114.3         ...                     66900.0</div><div class="line">1         -114.5         ...                     80100.0</div><div class="line">2         -114.6         ...                     85700.0</div><div class="line">3         -114.6         ...                     73400.0</div><div class="line">4         -114.6         ...                     65500.0</div><div class="line">...          ...         ...                         ...</div><div class="line">16995     -124.3         ...                    111400.0</div><div class="line">16996     -124.3         ...                     79000.0</div><div class="line">16997     -124.3         ...                    103600.0</div><div class="line">16998     -124.3         ...                     85800.0</div><div class="line">16999     -124.3         ...                     94600.0</div><div class="line"></div><div class="line">[17000 rows x 9 columns]</div></pre></td></tr></table></figure>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><ul>
<li>随机化处理。以保证不会出现病态的排序结果（防止损害梯度下降算法的效果）</li>
<li>将 <code>median_house_value</code> 调整为以千为单位</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line">house_data = house_data.reindex(</div><div class="line">    np.random.permutation(california_housing_dataframe.index)</div><div class="line">)</div><div class="line">house_data[<span class="string">"median_house_value"</span>] /= <span class="number">1000.0</span></div><div class="line"></div><div class="line">print(house_data)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">longitude</th>
<th style="text-align:center">latitude</th>
<th style="text-align:center">housing_median_age</th>
<th style="text-align:center">total_rooms</th>
<th style="text-align:center">total_bedrooms</th>
<th style="text-align:center">population</th>
<th style="text-align:center">households</th>
<th style="text-align:center">median_income</th>
<th style="text-align:center">median_house_value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">417</td>
<td style="text-align:center">-117.0</td>
<td style="text-align:center">32.8</td>
<td style="text-align:center">12.0</td>
<td style="text-align:center">5535.0</td>
<td style="text-align:center">1434.0</td>
<td style="text-align:center">3112.0</td>
<td style="text-align:center">1262.0</td>
<td style="text-align:center">2.6</td>
<td style="text-align:center">108.3</td>
</tr>
<tr>
<td style="text-align:center">14423</td>
<td style="text-align:center">-122.1</td>
<td style="text-align:center">37.4</td>
<td style="text-align:center">18.0</td>
<td style="text-align:center">1617.0</td>
<td style="text-align:center">231.0</td>
<td style="text-align:center">555.0</td>
<td style="text-align:center">222.0</td>
<td style="text-align:center">8.9</td>
<td style="text-align:center">500.0</td>
</tr>
<tr>
<td style="text-align:center">2320</td>
<td style="text-align:center">-117.5</td>
<td style="text-align:center">34.0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">12870.0</td>
<td style="text-align:center">2315.0</td>
<td style="text-align:center">5820.0</td>
<td style="text-align:center">1759.0</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">147.3</td>
</tr>
<tr>
<td style="text-align:center">1420</td>
<td style="text-align:center">-117.2</td>
<td style="text-align:center">32.8</td>
<td style="text-align:center">23.0</td>
<td style="text-align:center">1215.0</td>
<td style="text-align:center">225.0</td>
<td style="text-align:center">592.0</td>
<td style="text-align:center">224.0</td>
<td style="text-align:center">3.4</td>
<td style="text-align:center">200.6</td>
</tr>
<tr>
<td style="text-align:center">14724</td>
<td style="text-align:center">-122.2</td>
<td style="text-align:center">37.8</td>
<td style="text-align:center">52.0</td>
<td style="text-align:center">2198.0</td>
<td style="text-align:center">397.0</td>
<td style="text-align:center">984.0</td>
<td style="text-align:center">369.0</td>
<td style="text-align:center">3.2</td>
<td style="text-align:center">156.5</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">3201</td>
<td style="text-align:center">-117.8</td>
<td style="text-align:center">33.9</td>
<td style="text-align:center">25.0</td>
<td style="text-align:center">1548.0</td>
<td style="text-align:center">256.0</td>
<td style="text-align:center">811.0</td>
<td style="text-align:center">263.0</td>
<td style="text-align:center">5.2</td>
<td style="text-align:center">242.2</td>
</tr>
<tr>
<td style="text-align:center">9159</td>
<td style="text-align:center">-119.0</td>
<td style="text-align:center">35.4</td>
<td style="text-align:center">42.0</td>
<td style="text-align:center">1705.0</td>
<td style="text-align:center">418.0</td>
<td style="text-align:center">905.0</td>
<td style="text-align:center">393.0</td>
<td style="text-align:center">1.6</td>
<td style="text-align:center">54.6</td>
</tr>
<tr>
<td style="text-align:center">12103</td>
<td style="text-align:center">-121.4</td>
<td style="text-align:center">37.8</td>
<td style="text-align:center">30.0</td>
<td style="text-align:center">1912.0</td>
<td style="text-align:center">451.0</td>
<td style="text-align:center">1065.0</td>
<td style="text-align:center">388.0</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">125.0</td>
</tr>
<tr>
<td style="text-align:center">14972</td>
<td style="text-align:center">-122.2</td>
<td style="text-align:center">37.8</td>
<td style="text-align:center">41.0</td>
<td style="text-align:center">2576.0</td>
<td style="text-align:center">406.0</td>
<td style="text-align:center">794.0</td>
<td style="text-align:center">376.0</td>
<td style="text-align:center">6.0</td>
<td style="text-align:center">366.1</td>
</tr>
<tr>
<td style="text-align:center">15500</td>
<td style="text-align:center">-122.3</td>
<td style="text-align:center">37.9</td>
<td style="text-align:center">29.0</td>
<td style="text-align:center">2304.0</td>
<td style="text-align:center">399.0</td>
<td style="text-align:center">1377.0</td>
<td style="text-align:center">454.0</td>
<td style="text-align:center">5.0</td>
<td style="text-align:center">140.6</td>
</tr>
</tbody>
</table>
<p>17000 rows × 9 columns</p>
<h4 id="检查数据"><a href="#检查数据" class="headerlink" title="检查数据"></a>检查数据</h4><p>dataframe 数据的 <code>describe()</code> 方法能方便地显示出数据的快速摘要：样本数、均值、标准偏差、最大值、最小值和各种分位数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">house_data.describe()</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">longitude</th>
<th style="text-align:center">latitude</th>
<th style="text-align:center">housing_median_age</th>
<th style="text-align:center">total_rooms</th>
<th style="text-align:center">total_bedrooms</th>
<th style="text-align:center">population</th>
<th style="text-align:center">households</th>
<th style="text-align:center">median_income</th>
<th style="text-align:center">median_house_value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
</tr>
<tr>
<td style="text-align:center">mean</td>
<td style="text-align:center">-119.6</td>
<td style="text-align:center">35.6</td>
<td style="text-align:center">28.6</td>
<td style="text-align:center">2643.7</td>
<td style="text-align:center">539.4</td>
<td style="text-align:center">1429.6</td>
<td style="text-align:center">501.2</td>
<td style="text-align:center">3.9</td>
<td style="text-align:center">207.3</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">2.1</td>
<td style="text-align:center">12.6</td>
<td style="text-align:center">2179.9</td>
<td style="text-align:center">421.5</td>
<td style="text-align:center">1147.9</td>
<td style="text-align:center">384.5</td>
<td style="text-align:center">1.9</td>
<td style="text-align:center">116.0</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">-124.3</td>
<td style="text-align:center">32.5</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1.0</td>
<td style="text-align:center">0.5</td>
<td style="text-align:center">15.0</td>
</tr>
<tr>
<td style="text-align:center">25%</td>
<td style="text-align:center">-121.8</td>
<td style="text-align:center">33.9</td>
<td style="text-align:center">18.0</td>
<td style="text-align:center">1462.0</td>
<td style="text-align:center">297.0</td>
<td style="text-align:center">790.0</td>
<td style="text-align:center">282.0</td>
<td style="text-align:center">2.6</td>
<td style="text-align:center">119.4</td>
</tr>
<tr>
<td style="text-align:center">50%</td>
<td style="text-align:center">-118.5</td>
<td style="text-align:center">34.2</td>
<td style="text-align:center">29.0</td>
<td style="text-align:center">2127.0</td>
<td style="text-align:center">434.0</td>
<td style="text-align:center">1167.0</td>
<td style="text-align:center">409.0</td>
<td style="text-align:center">3.5</td>
<td style="text-align:center">180.4</td>
</tr>
<tr>
<td style="text-align:center">75%</td>
<td style="text-align:center">-118.0</td>
<td style="text-align:center">37.7</td>
<td style="text-align:center">37.0</td>
<td style="text-align:center">3151.2</td>
<td style="text-align:center">648.2</td>
<td style="text-align:center">1721.0</td>
<td style="text-align:center">605.2</td>
<td style="text-align:center">4.8</td>
<td style="text-align:center">265.0</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">-114.3</td>
<td style="text-align:center">42.0</td>
<td style="text-align:center">52.0</td>
<td style="text-align:center">37937.0</td>
<td style="text-align:center">6445.0</td>
<td style="text-align:center">35682.0</td>
<td style="text-align:center">6082.0</td>
<td style="text-align:center">15.0</td>
<td style="text-align:center">500.0</td>
</tr>
</tbody>
</table>
<h4 id="构建第一个模型"><a href="#构建第一个模型" class="headerlink" title="构建第一个模型"></a>构建第一个模型</h4><p>在这个基础练习中，我们以 <code>median_house_value</code> 为标签（也称为目标），使用 <code>total_rooms</code> 作为输入特征。</p>
<p><strong>注意：</strong> 因为我们使用的城市街区的数据，所以 <code>total_rooms</code> 表示的是该街区的所有房间数，而不是单间房屋的房间数（想想这数据也不是 :)）。</p>
<p>为了训练模型，我们将使用 TensorFlow <a href="https://www.tensorflow.org/get_started/estimator" target="_blank" rel="external">Estimator</a> API 提供的 <a href="https://www.tensorflow.org/get_started/estimator" target="_blank" rel="external">LinearRegressor</a> 接口。此 API 负责处理大量低级别的模型搭建工作，并会提供执行模型训练、评估和推理的便捷方法。</p>
<h5 id="第一步：定义特征并配置特征列"><a href="#第一步：定义特征并配置特征列" class="headerlink" title="第一步：定义特征并配置特征列"></a>第一步：定义特征并配置特征列</h5><p>特征字段主要有两种数据类型：</p>
<ul>
<li>分类数据：一种文字数据，本基础练习不含这种数据，但可能会在看到类似包括家居风格以及房地产广告词这类数据。</li>
<li>数值数据：一种数字数据（整数或浮点数）以及你希望视为数字的数据，但有时可能也会把例如邮编这种数据也是为分类数据来做处理（在稍后的进行详细说明）。</li>
</ul>
<p>现在我们的数据还是 pandas 的 <code>DataFrame</code> 数据格式，我们得让 TensorFlow 读懂这些数据。</p>
<p>首先，我们需要指定每个特征包含的数据类型（以上两种类型），然后我们使用一种称为“特征列”的结构来表示特征的数据类型。</p>
<p><strong>注意：</strong> 特征列仅仅存储对特征数据的描述，和特征数据本身没关系。</p>
<p>现在，我们使用上面所说的 <code>total_rooms</code> 作为数值输入特征。以下代码会从 <code>house_data</code> 中提取 <code>total_rooms</code> 数据，并使用 <code>numeric_column</code> 定义特征列，这样会将其数据指定为数值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="comment"># 拿到输入特征：total_rooms</span></div><div class="line">my_feature = house_data[[<span class="string">'total_rooms'</span>]]</div><div class="line"></div><div class="line"><span class="comment"># 将 total_rooms 配置为数值特征列</span></div><div class="line">feature_colums = [tf.feature_column.numeric_column(<span class="string">'total_rooms'</span>)]</div><div class="line"></div><div class="line">print(my_feature)</div><div class="line">print(feature_columns)</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">total_rooms</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8899</td>
<td style="text-align:center">8803.0</td>
</tr>
<tr>
<td style="text-align:center">682</td>
<td style="text-align:center">3967.0</td>
</tr>
<tr>
<td style="text-align:center">13332</td>
<td style="text-align:center">3735.0</td>
</tr>
<tr>
<td style="text-align:center">9720</td>
<td style="text-align:center">2242.0</td>
</tr>
<tr>
<td style="text-align:center">14046</td>
<td style="text-align:center">4125.0</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">6328</td>
<td style="text-align:center">1476.0</td>
</tr>
<tr>
<td style="text-align:center">2329</td>
<td style="text-align:center">1379.0</td>
</tr>
<tr>
<td style="text-align:center">14272</td>
<td style="text-align:center">1382.0</td>
</tr>
<tr>
<td style="text-align:center">4124</td>
<td style="text-align:center">3443.0</td>
</tr>
<tr>
<td style="text-align:center">5124</td>
<td style="text-align:center">718.0</td>
</tr>
</tbody>
</table>
<p>[17000 rows x 1 columns]</p>
<p>[_NumericColumn(key=’total_rooms’, shape=(1,), default_value=None, dtype=tf.float32, normalizer_fn=None)]</p>
<h5 id="第二部：定义标签-目标"><a href="#第二部：定义标签-目标" class="headerlink" title="第二部：定义标签 / 目标"></a>第二部：定义标签 / 目标</h5><p>接下来，我们把 <code>median_house_value</code> 定义为我们的目标。同样，先从 <code>house_data</code> 中提取它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">targets = housse_data[<span class="string">"median_house_value"</span>]</div></pre></td></tr></table></figure>
<h5 id="第三部：配置-LinearRegressor"><a href="#第三部：配置-LinearRegressor" class="headerlink" title="第三部：配置 LinearRegressor"></a>第三部：配置 LinearRegressor</h5><p>接下来我们使用 LinearRegressor 配置线性回归模型，并使用 GradientDescentOptimizer（它会实现小批量随机梯度下降法（SGD）） 训练该模型。</p>
<p><code>learning_rate</code> 参数可控制梯度步长的大小。</p>
<p><strong>注意：</strong> 为了安全起见，我们会通过 <code>clip_gradients_by_norm</code> 将<a href="https://developers.google.com/machine-learning/glossary/#gradient_clipping" target="_blank" rel="external">梯度裁剪</a>应用到我们的优化器。梯度裁剪能确保梯度大小在训练期间不会变得过大，梯度过大会导致梯度下降法失败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 采用梯度下降法作为模型训练的优化器，并应用梯度裁剪</span></div><div class="line"><span class="comment"># 将梯度下降的学习速率设置为 0.0000001</span></div><div class="line">my_optimizer = tf.train.GradientDescentOptimizer(learning_rate=<span class="number">0.0000001</span>)</div><div class="line">my_optimizer = tf.contrib.estimator.clip_gradients_by_norm(my_optimizer, <span class="number">5.0</span>)</div><div class="line"></div><div class="line"><span class="comment"># 将特征列和优化器应用到我们的线性回归模型上</span></div><div class="line">linear_regressor = tf.estimator.LinearRegressor(</div><div class="line">    feature_column=feature_colums, optimizer=my_optimizer</div><div class="line">)</div></pre></td></tr></table></figure>
<h5 id="第四步：定义输入函数"><a href="#第四步：定义输入函数" class="headerlink" title="第四步：定义输入函数"></a>第四步：定义输入函数</h5><p>要把数据导入 LinearRegressor，我们需要定义一个输入函数，得让 TensorFlow 知道怎么对数据进行预处理，以及在模型训练期间如何进行批处理、随机处理、重复数据。</p>
<p>首先，我们需要把 pandas 数据转换成 Numpy 数组字典。然后，我们就能使用 TensorFlow 的 <a href="https://www.tensorflow.org/programmers_guide/datasets" target="_blank" rel="external">Dataset API</a> 根据我们的数据构建 Dataset 对象，并将数据拆分成大小为 batch_size 的多批数据，以按照指定周期数（num_epochs）进行重复。</p>
<p><strong>注意：</strong> 如果 num_epochs=None，那么输入的数据会无限期重复。</p>
<p>然后，如果 <code>shuffle</code> 设置为 True，那么我们就会对数据进行随机处理，以便在训练期间以随机方式传递到模型。<code>buffer_size</code> 参数会指定 shuffle 将从随机抽样的数据集的大小。</p>
<p>最后，输入函数会为该数据集构建一个迭代器，并向 LinearRegressor 返回下一批数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_input_fn</span><span class="params">(features, targets, batch_size=<span class="number">1</span>, shuffle=True, num_epochs=None)</span>:</span></div><div class="line">    <span class="comment"># 将 pandas 特征数据转换成 Numpy 数组字段</span></div><div class="line">    <span class="comment"># features: DataFrame -&gt; Dict(&#123;column_name: column_data(Series)&#125;) -&gt; np.array</span></div><div class="line">    <span class="comment"># 这里数据类型的转化：输入之前拿到的那列 DataFrame，最后获取那列数据的一个 np.array 类数组对象</span></div><div class="line">    features = &#123; key: np.array(value) <span class="keyword">for</span> key, value <span class="keyword">in</span> dict(features).items() &#125;</div><div class="line">    </div><div class="line">    <span class="comment"># 构建 Dataset 对象，并将数据拆分成大小为 batch_size 的多批数据，以 num_epochs 周期重复</span></div><div class="line">    <span class="comment"># 每个步长都会跑 batch_size 批的数据</span></div><div class="line">    ds = Dataset.from_tensor_slices((features, targets))  <span class="comment"># 上限 2 GB</span></div><div class="line">    ds = ds.batch(batch_size).repeat(num_epochs)</div><div class="line">    </div><div class="line">    <span class="comment"># 随机化数据（一共 17k 条数据，每次随机取 10k 条）</span></div><div class="line">    <span class="keyword">if</span> shuffle:</div><div class="line">        ds = ds.shuffle(buffer_size=<span class="number">10000</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 返回下一个 batch 的数据</span></div><div class="line">    features, labels = ds.make_one_shot_iterator().get_next()</div><div class="line">    <span class="keyword">return</span> features, labels</div></pre></td></tr></table></figure>
<p>输入函数的初步解释已经写在函数定义中了，更详细的文档参阅 <a href="https://www.tensorflow.org/programmers_guide/datasets" target="_blank" rel="external">TensorFlow 编程人员指南</a>。</p>
<h5 id="第五步：训练模型"><a href="#第五步：训练模型" class="headerlink" title="第五步：训练模型"></a>第五步：训练模型</h5><p>现在，我们可以使用 <code>train()</code> 来训练我们的模型。我们将 <code>my_input_fn</code> 封装在 lambda 中，这样我们就可以把 <code>my_features</code> 和 <code>targets</code> 最为参数传入（更过详阅 <a href="https://www.tensorflow.org/get_started/input_fn#passing_input_fn_data_to_your_model" target="_blank" rel="external">TensorFlow 输入函数教程</a>）。</p>
<p>首先，我们先训练 100 个步长。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">_ = linear_regressor.train(</div><div class="line">    input_fn=<span class="keyword">lambda</span>: my_input_fn(my_feature, targets),</div><div class="line">    steps=<span class="number">100</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<h5 id="第六步：评估模型"><a href="#第六步：评估模型" class="headerlink" title="第六步：评估模型"></a>第六步：评估模型</h5><p>经过上面的训练之后，我们现在来做一次预测，看看模型与这些数据的拟合情况。</p>
<p><strong>注意：</strong> 训练误差衡量的是你的模型与训练数据的拟合情况，不能衡量模型<strong>泛化到新数据</strong>上的效果。如果评估模型的泛化能力在后面探索。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 为预测创建一个输入函数</span></div><div class="line"><span class="comment"># 因为我们就做一次预测，就没必要重复打乱数据了</span></div><div class="line">prediction_input_fn = <span class="keyword">lambda</span>: my_input_fn(my_feature, target, num_epochs=<span class="number">1</span>, shuffle=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="comment"># 调用模型的 predict() 函数进行预测</span></div><div class="line">predictions = linear_regressor.predict(input_fn=prediction_input_fn)</div><div class="line"></div><div class="line"><span class="comment"># 将预测数据格式化成 Numpy 的数组类型，方便检查</span></div><div class="line">predictions = np.arrary([item[<span class="string">'predictions'</span>][<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> predictions])</div><div class="line"></div><div class="line"><span class="comment"># 打印出均方误差和均方根误差</span></div><div class="line">mean_squared_error = metrics.mean_squared_error(predictions, targets)</div><div class="line">root_mean_squared_error = math.sqrt(mean_squared_error)</div><div class="line"></div><div class="line">print(<span class="string">"Mean Squared Error (on training data): %0.3f"</span> % mean_squared_error)</div><div class="line">print(<span class="string">"Root Mean Squared Error (on training data): %0.3f"</span> % root_mean_squared_error)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Mean Squared Error (on training data): 56367.025</div><div class="line">Root Mean Squared Error (on training data): 237.417</div></pre></td></tr></table></figure>
<p>均方差和均方根误差都已经算出来了，但是我们该怎么去评估这个误差是否能被接受呢？</p>
<p>均方根误差（RMSE）是一个很好的特征，它可以在与原目标相同的规模下解读。</p>
<p>我们来比较下 RMSE 与目标最大值和最小值的差值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">min_house_value = house_data[<span class="string">'median_house_value'</span>].min()</div><div class="line">max_house_value = house_data[<span class="string">'median_house_value'</span>].max()</div><div class="line"></div><div class="line">print(<span class="string">'Min. median house value: %0.3f'</span> % min_house_value)</div><div class="line">print(<span class="string">'Max. median house value: %0.3f'</span> % max_house_value)</div><div class="line">print(<span class="string">'Difference between Min. and Max.: %0.3f'</span> % (max_house_value - min_house_value))</div><div class="line">print(<span class="string">'Root Mean Squared Error: %0.3f'</span> % root_mean_squared_error)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Min. Median House value: 14.999</div><div class="line">Max. Median House value: 500.001</div><div class="line">Difference between Min. and Max.: 485.002</div><div class="line">Root Mean Squared Error: 237.417</div></pre></td></tr></table></figure>
<p>通过上面的计算，我们的误差跨越了目标值的一半。这意味着我们的误差很大吗？</p>
<p>那我们有什么办法来缩小这个误差吗？</p>
<p>首先，我们可以了解下根据总体摘要统计信息，预测和目标的符合情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">calibration_data = pd.DataFrame()</div><div class="line">calibration_data[<span class="string">'predictions'</span>] = pd.Series(predictions)</div><div class="line">calibration_data[<span class="string">'targets'</span>] = pd.Series(targets)</div><div class="line">calibration_data.describe()</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">predictions</th>
<th style="text-align:center">targets</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
</tr>
<tr>
<td style="text-align:center">mean</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">207.3</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">116.0</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">15.0</td>
</tr>
<tr>
<td style="text-align:center">25%</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">119.4</td>
</tr>
<tr>
<td style="text-align:center">50%</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">180.4</td>
</tr>
<tr>
<td style="text-align:center">75%</td>
<td style="text-align:center">0.2</td>
<td style="text-align:center">265.0</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">1.9</td>
<td style="text-align:center">500.0</td>
</tr>
</tbody>
</table>
<p>以上的这些参数指标，对我们评价模型的预测值有什么意义吗？</p>
<p>也许可以比较下平均值和模型的 RMSE？各种分位数和 RMSE？</p>
<p>我相信不管和哪个指标比较，我们现在的预测值都是一坨屎！</p>
<p>为了更直观的显示我们的预测有多狗屎，我们先从这个数据集拿一部分均匀分布的随机数据样本（全部绘制出来太乱了，看不清），绘制散点图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sample = house_data.sample(n=<span class="number">300</span>)</div></pre></td></tr></table></figure>
<p>然后，我们根据模型的偏差项和特征权重绘制学到的线，并绘制散点图。改线以红色显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取 total_rooms 数据的最大最小值</span></div><div class="line">x_0 = sample[<span class="string">'total_rooms'</span>].min()</div><div class="line">x_1 = sample[<span class="string">'total_rooms'</span>].max()</div><div class="line"></div><div class="line"><span class="comment"># 获取在模型最终训练后的权重与偏差</span></div><div class="line">weight = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/total_rooms/weights'</span>)[<span class="number">0</span>]</div><div class="line">bias = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/bias_weights'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 通过获取的预测权重与偏差计算出 median_house_value 预测的最大最小值</span></div><div class="line">y_0 = weight * x_0 + bias</div><div class="line">y_1 = weight * x_1 + bias</div><div class="line"></div><div class="line"><span class="comment"># 画出我们的预测线性回归线 (x_0, y_0) (x_1, y_1) | c='r' 是 color='red' 的意思 :)</span></div><div class="line">plt.plot([x_0, x_1], [y_0, y_1], c=<span class="string">'r'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 加上坐标描述</span></div><div class="line">plt.xlabel(<span class="string">'total_rooms'</span>)</div><div class="line">plt.ylabel(<span class="string">'median_house_value'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 把我们的样本点一个个“点上去”</span></div><div class="line">plt.sactter(sample[<span class="string">'total_rooms'</span>], sample[<span class="string">'median_house_value'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 把图画出来</span></div><div class="line">plt.show()</div></pre></td></tr></table></figure>
<p><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/TensorFlow/14_25_47__07_27_2018.jpg" alt="散点图"></p>
<p>哈哈哈，是不是很直观地就发现我们的预测就是一坨屎。</p>
<h4 id="调整模型超参数"><a href="#调整模型超参数" class="headerlink" title="调整模型超参数"></a>调整模型超参数</h4><p>为了方便起见，我们把上面几个步骤合并在一个函数里面，然后把要调整的参数暴露出来，这样就能很容易的测试各种不同参数所模拟的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_model</span><span class="params">(learning_rate, steps, batch_size, input_feature=<span class="string">'total_rooms'</span>)</span>:</span></div><div class="line">    periods = <span class="number">10</span></div><div class="line">    steps_per_period = steps / periods</div><div class="line">    </div><div class="line">    my_feature = input_feature</div><div class="line">    my_feature_data = house_data[[my_feature]]</div><div class="line">    </div><div class="line">    my_target = <span class="string">'median_house_value'</span></div><div class="line">    targets = house_data[my_target]</div><div class="line">    </div><div class="line">    <span class="comment"># 创建特征列</span></div><div class="line">    feature_columns = [tf.feature_column.numeric_column(my_feature)]</div><div class="line">    </div><div class="line">    <span class="comment"># 创建输入函数</span></div><div class="line">    training_input_fn = <span class="keyword">lambda</span>: my_input_fn(my_feature_data, targets, batch_size=batch_size)</div><div class="line">    prediction_input_fn = <span class="keyword">lambda</span>: my_input_fn(my_feature_data, targets, num_epochs=<span class="number">1</span>, shuffle=<span class="keyword">False</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 创建线性回归模型</span></div><div class="line">    my_optimizer = tf.train.GradientDescentOptimizer(learning_rate=learning_rate)</div><div class="line">    my_optimizer = tf.contrib.estimator.clip_gradients_by_norm(my_optimizer, <span class="number">5.0</span>)</div><div class="line">    linear_regressor = tf.estimator.LinearRegressor(</div><div class="line">        feature_columns=feature_columns,</div><div class="line">        optimizer=my_optimizer</div><div class="line">    )</div><div class="line">    </div><div class="line">    <span class="comment"># plot 基本配置</span></div><div class="line">    plt.figure(figsize=(<span class="number">15</span>, <span class="number">6</span>))  <span class="comment"># 每个网格 15 X 6 大小</span></div><div class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 当前操作一行两列的第一个图表</span></div><div class="line">    plt.title(<span class="string">'Learned Line by Period'</span>)  <span class="comment"># 设置标题</span></div><div class="line">    plt.xlabel(my_feature)  <span class="comment"># 设置横坐标名</span></div><div class="line">    plt.ylabel(my_label)  <span class="comment"># 设置纵坐标名</span></div><div class="line">    </div><div class="line">    <span class="comment"># 获取绘制样本</span></div><div class="line">    sample = house_data.sample(n=<span class="number">300</span>)</div><div class="line">    plt.scatter(sample[my_feature], sample[my_lable])</div><div class="line">    colors = [cm.coolwarm(x) <span class="keyword">for</span> x <span class="keyword">in</span> np.linspace(<span class="number">-1</span>, <span class="number">1</span>, periods)]</div><div class="line">    </div><div class="line">    <span class="comment"># 训练模型，每个周期评估下误差损失</span></div><div class="line">    print(<span class="string">'Training model...'</span>)</div><div class="line">    print(<span class="string">'RMSE (on training data): '</span>)</div><div class="line">    root_mean_squared_errors = []</div><div class="line">    <span class="keyword">for</span> period <span class="keyword">in</span> range(<span class="number">0</span>, periods):</div><div class="line">        linear_regressor.train(</div><div class="line">            input_fn=training_input_fn,</div><div class="line">            steps=steps_per_period</div><div class="line">        )</div><div class="line">        </div><div class="line">        <span class="comment"># 每个周期训练完之后计算一下损失</span></div><div class="line">        predictions = linear_regressor.predict(input_fn=prediction_input_fn)</div><div class="line">        perdictions = np.array([item[<span class="string">'predictions'</span>][<span class="number">0</span>] <span class="keyword">for</span> item <span class="keyword">in</span> predictions])</div><div class="line">        </div><div class="line">        <span class="comment"># 计算损失</span></div><div class="line">        root_mean_squared_error = math.sqrt(</div><div class="line">            metrics.mean_squared_error(predictions, targets)</div><div class="line">        )</div><div class="line">        </div><div class="line">        <span class="comment"># 输出当前损失</span></div><div class="line">        print(<span class="string">'period %02d : %0.2f'</span> % (period, root_mean_squared_error))</div><div class="line">        <span class="comment"># 将当前损失加到记录损失的列表中</span></div><div class="line">        root_mean_squared_errors.append(root_mean_squared_error)</div><div class="line">        </div><div class="line">        <span class="comment"># 为了画出来的效果，适当调整下横纵坐标的大小</span></div><div class="line">        y_extents = np.array([<span class="number">0</span>, sample[my_label].max()])</div><div class="line">        </div><div class="line">        weight = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/%s/weights'</span> % input_feature)[<span class="number">0</span>]</div><div class="line">        bias = linear_regressor.get_variable_value(<span class="string">'linear/linear_model/bias_weights'</span>)</div><div class="line">        </div><div class="line">        x_extents = (y_extents - bias) / weight</div><div class="line">        x_extents = np.maximum(</div><div class="line">            np.minimum(x_extents, sample[my_feature].max()),</div><div class="line">            sample[my_feature].min()</div><div class="line">        )</div><div class="line">        y_extents = weight * x_extents + bias</div><div class="line">        plt.plot(x_extents, y_extents, color=colors[period])</div><div class="line">    </div><div class="line">    print(<span class="string">'Model training finished.'</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># 现在把每个周期的损失画出来</span></div><div class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</div><div class="line">    plt.xlabel(<span class="string">'Periods'</span>)</div><div class="line">    plt.ylabel(<span class="string">'RMSE'</span>)</div><div class="line">    plt.title(<span class="string">'Root Mean Squared Error vs. Periods'</span>)</div><div class="line">    plt.tight_layout()  <span class="comment"># 自动调整子图的布局和坐标刻度的大小</span></div><div class="line">    plt.plot(root_mean_squared_errors)</div><div class="line">    </div><div class="line">    <span class="comment"># 将最终的预测值和目标值放在一张表里展示</span></div><div class="line">    calibration_data = pd.DataFrame()</div><div class="line">    calibration_data[<span class="string">"predictions"</span>] = pd.Series(predictions)</div><div class="line">    calibration_data[<span class="string">"targets"</span>] = pd.Series(targets)</div><div class="line">    display.display(calibration_data.describe())</div><div class="line">    </div><div class="line">    print(<span class="string">"Final RMSE (on training data): %0.2f"</span> % root_mean_squared_error)</div></pre></td></tr></table></figure>
<p>最后我们直接调用这个函数就可以方便地测试各种参数搭配的 RMSE 的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">train_model(</div><div class="line">    learning_rate=<span class="number">0.00002</span>,</div><div class="line">    steps=<span class="number">500</span>,</div><div class="line">    batch_size=<span class="number">5</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Training model...</div><div class="line">RMSE (on training data):</div><div class="line">  period 00 : 225.63</div><div class="line">  period 01 : 214.42</div><div class="line">  period 02 : 204.44</div><div class="line">  period 03 : 194.97</div><div class="line">  period 04 : 187.23</div><div class="line">  period 05 : 180.53</div><div class="line">  period 06 : 175.00</div><div class="line">  period 07 : 171.07</div><div class="line">  period 08 : 169.21</div><div class="line">  period 09 : 167.37</div><div class="line">Model training finished.</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">predictions</th>
<th style="text-align:center">targets</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
</tr>
<tr>
<td style="text-align:center">mean</td>
<td style="text-align:center">116.3</td>
<td style="text-align:center">207.3</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center">95.9</td>
<td style="text-align:center">116.0</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">0.1</td>
<td style="text-align:center">15.0</td>
</tr>
<tr>
<td style="text-align:center">25%</td>
<td style="text-align:center">64.3</td>
<td style="text-align:center">119.4</td>
</tr>
<tr>
<td style="text-align:center">50%</td>
<td style="text-align:center">93.6</td>
<td style="text-align:center">180.4</td>
</tr>
<tr>
<td style="text-align:center">75%</td>
<td style="text-align:center">138.7</td>
<td style="text-align:center">265.0</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">1669.2</td>
<td style="text-align:center">500.0</td>
</tr>
</tbody>
</table>
<p><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/TensorFlow/17_18_02__07_27_2018.jpg" alt="模拟结果"></p>
<p>当然，我们还可以试试其他参数作为我们的特征值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">train_model(</div><div class="line">    learning_rate=<span class="number">0.00002</span>,</div><div class="line">    steps=<span class="number">1000</span>,</div><div class="line">    batch_size=<span class="number">5</span>,</div><div class="line">    input_feature=<span class="string">"population"</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Training model...</div><div class="line">RMSE (on training data):</div><div class="line">  period 00 : 225.63</div><div class="line">  period 01 : 214.62</div><div class="line">  period 02 : 204.67</div><div class="line">  period 03 : 196.42</div><div class="line">  period 04 : 189.12</div><div class="line">  period 05 : 183.91</div><div class="line">  period 06 : 180.03</div><div class="line">  period 07 : 177.64</div><div class="line">  period 08 : 176.45</div><div class="line">  period 09 : 175.95</div><div class="line">Model training finished.</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">predictions</th>
<th style="text-align:center">targets</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">17000.0</td>
<td style="text-align:center">17000.0</td>
</tr>
<tr>
<td style="text-align:center">mean</td>
<td style="text-align:center">121.8</td>
<td style="text-align:center">207.3</td>
</tr>
<tr>
<td style="text-align:center">std</td>
<td style="text-align:center">97.8</td>
<td style="text-align:center">116.0</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">0.3</td>
<td style="text-align:center">15.0</td>
</tr>
<tr>
<td style="text-align:center">25%</td>
<td style="text-align:center">67.3</td>
<td style="text-align:center">119.4</td>
</tr>
<tr>
<td style="text-align:center">50%</td>
<td style="text-align:center">99.4</td>
<td style="text-align:center">180.4</td>
</tr>
<tr>
<td style="text-align:center">75%</td>
<td style="text-align:center">146.6</td>
<td style="text-align:center">265.0</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">3040.1</td>
<td style="text-align:center">500.0</td>
</tr>
</tbody>
</table>
<p><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/TensorFlow/17_41_30__07_27_2018.jpg" alt="模拟结果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习基本的 TensorFlow 概念&lt;/li&gt;
&lt;li&gt;在 TensorFlow 中使用 LinearRegressor 类并基于单个输入特征预测各城市街区的房屋价值中位数&lt;/li&gt;
&lt;li&gt;使用均方根误差 (RMSE) 评估模型预测的准确率&lt;/li&gt;
&lt;li&gt;通过调整模型的超参数提高模型准确率&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>理解Python元类</title>
    <link href="https://yuanblq.github.io/2018/05/31/%E7%90%86%E8%A7%A3Python%E5%85%83%E7%B1%BB/"/>
    <id>https://yuanblq.github.io/2018/05/31/理解Python元类/</id>
    <published>2018-05-31T08:11:12.000Z</published>
    <updated>2018-05-31T08:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要理解 Python 中的元类只要记住：一切皆对象。记住这 5 个字，理解元类就会轻松很多。</p>
<a id="more"></a>
<h3 id="先创建一个自定义对象瞧瞧"><a href="#先创建一个自定义对象瞧瞧" class="headerlink" title="先创建一个自定义对象瞧瞧"></a>先创建一个自定义对象瞧瞧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">my_obj = MyClass()</div><div class="line"></div><div class="line">my_obj</div></pre></td></tr></table></figure>
<pre><code>&lt;__main__.MyClass at 0x10907aa20&gt;
</code></pre><p>我们，很容易就获得了一个自定义的对象。那在这期间都发生了些什么呢？</p>
<p><code>my_obj = MyClass()</code> 这段代码运行的时候，我们都知道这是在实例化一个类来获取这个类的对象，实例化期间会去走 <code>MyClass</code> 类中的 <code>__init__()</code> 方法。</p>
<p>当然，我们都知道在走 <code>__init__()</code> 方法之前还会先去走 <code>MyClass</code> 类的 <code>__new__()</code> 方法，通过 <code>__new__()</code> 方法来创建类的实例。Python 最常见的单例就是通过 <code>__new__()</code> 方法实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></div><div class="line">    __instance = <span class="keyword">None</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></div><div class="line">        print(<span class="string">"in MyClass __new__ method"</span>)</div><div class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            print(<span class="string">"create a new instance"</span>)</div><div class="line">            cls.__instance = super(MyClass, cls).__new__(cls, *args)</div><div class="line">        <span class="keyword">return</span> cls.__instance</div><div class="line"></div><div class="line">c1 = MyClass()</div><div class="line">c2 = MyClass()</div><div class="line">c1, c2</div></pre></td></tr></table></figure>
<pre><code>in MyClass __new__ method
create a new instance
in MyClass __new__ method





(&lt;__main__.MyClass at 0x1090a1f60&gt;, &lt;__main__.MyClass at 0x1090a1f60&gt;)
</code></pre><p>实际上通过这个单例模式可以了解到，其实真正创建对象的方法是 <code>__new__()</code>，而 <code>__init__()</code> 方法只是给已经创建出来的对象赋予属性等操作。</p>
<h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>在 Python 中，函数可以是个对象，类也可以是个对象。既然类是个对象，那就应该拥有对象所拥有的特性：</p>
<ul>
<li>可以传递给其他变量</li>
<li>可以拷贝它</li>
<li>可以动态地给它增加属性</li>
<li>可以作为参数传递</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mc = MyClass</div><div class="line">mc.new_attr = <span class="string">'Hello'</span></div><div class="line">mc, mc.new_attr</div></pre></td></tr></table></figure>
<pre><code>(__main__.MyClass, &apos;Hello&apos;)
</code></pre><h3 id="动态创建类"><a href="#动态创建类" class="headerlink" title="动态创建类"></a>动态创建类</h3><p>既然类也是对象，那我们就可以动态的创建一个类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dynamic_class</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">if</span> name == <span class="string">'Class_1'</span>:</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Class_1</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> Class_1</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">OtherClass</span>:</span></div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> OtherClass</div><div class="line"></div><div class="line">d1 = create_dynamic_class(<span class="string">'Class_1'</span>)</div><div class="line">d2 = create_dynamic_class(<span class="string">'Class_2'</span>)</div><div class="line"></div><div class="line">d1, d2</div></pre></td></tr></table></figure>
<pre><code>(__main__.create_dynamic_class.&lt;locals&gt;.Class_1,
 __main__.create_dynamic_class.&lt;locals&gt;.OtherClass)
</code></pre><p>但是上面的类创建地还不够“动态”，熟悉 Python 应该知道，这时候就要上 <code>type</code> 了。</p>
<p>使用 <code>type</code> 可以这样创建类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">TClass = type(<span class="string">'TClass'</span>, (), &#123;&#125;)</div><div class="line">tc = TClass()</div><div class="line">tc, type(tc)</div></pre></td></tr></table></figure>
<pre><code>(&lt;__main__.TClass at 0x10907a470&gt;, __main__.TClass)
</code></pre><p><code>type()</code> 传递三个参数：类名、父类们、属性。</p>
<p><code>TClass = type(&#39;TClass&#39;, (), {})</code> 这个形式有没有觉得很熟悉，像不像通过类来创建对象这个形式 <code>obj = SomeClass()</code>。实际上 <code>type</code> 算是一个类，只不过小写的形式有点迷惑性，不过想想 <code>str</code>、<code>int</code>、<code>dict</code>、<code>list</code>、<code>set</code> 不都是小写的吗。</p>
<p>这样一来，其实所有对象都是 <code>type</code> 的子类？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">isinstance(int, type), isinstance(str, type), isinstance(dict, type), isinstance(MyClass, type)</div></pre></td></tr></table></figure>
<pre><code>(True, True, True, True)
</code></pre><p>果然就是这个样子！</p>
<h3 id="定义类的创建过程"><a href="#定义类的创建过程" class="headerlink" title="定义类的创建过程"></a>定义类的创建过程</h3><p>通过上面单例的示例代码可知，通过 <code>__new__()</code> 方法可以控制对象的创建过程。</p>
<p>而元类就是利用这一特性！控制类的创建过程。</p>
<p>所有的类，默认情况下都是由 <code>type</code> 控制创建的，我们想自定义类的创建过程当然是修改父类 <code>type</code> 的属性。正常情况就是继承 <code>type</code> 创建自已的 “<code>type</code> 类”然后让我们的类继承我们的 “<code>type</code> 类”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMetaClass</span><span class="params">(type)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></div><div class="line">        print(<span class="string">'got MyMetaClass __new__()'</span>)</div><div class="line">        <span class="keyword">if</span> name == <span class="string">'DeniedClass'</span>:</div><div class="line">            <span class="keyword">raise</span> RuntimeError</div><div class="line">        <span class="keyword">return</span> super(MyMetaClass, cls).__new__(cls, name, bases, attrs)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OKClass</span><span class="params">(metaclass=MyMetaClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></div><div class="line">        print(<span class="string">'got OKClass __new__()'</span>)</div><div class="line">        <span class="keyword">return</span> super(OKClass, cls).__new__(cls, *args)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'got OKClass __init__()'</span>)</div><div class="line"></div><div class="line">ok_class = OKClass()</div><div class="line">ok_class</div></pre></td></tr></table></figure>
<pre><code>got MyMetaClass __new__()
got OKClass __new__()
got OKClass __init__()





&lt;__main__.OKClass at 0x1090cc5f8&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeniedClass</span><span class="params">(metaclass=MyMetaClass)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args)</span>:</span></div><div class="line">        print(<span class="string">'got DeniedClass __new__()'</span>)</div><div class="line">        <span class="keyword">return</span> super(DeniedClass, cls).__new__(cls, *args)</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'got DeniedClass __init__()'</span>)</div><div class="line"></div><div class="line">denied_class = DeniedClass()</div><div class="line">denied_class</div></pre></td></tr></table></figure>
<pre><code>got MyMetaClass __new__()



---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

&lt;ipython-input-9-913341894ab1&gt; in &lt;module&gt;()
----&gt; 1 class DeniedClass(metaclass=MyMetaClass):
      2     def __new__(cls, *args):
      3         print(&apos;got DeniedClass __new__()&apos;)
      4         return super(DeniedClass, cls).__new__(cls, *args)
      5 


&lt;ipython-input-7-266bb1820d0c&gt; in __new__(cls, name, bases, attrs)
      3         print(&apos;got MyMetaClass __new__()&apos;)
      4         if name == &apos;DeniedClass&apos;:
----&gt; 5             raise RuntimeError
      6         return super(MyMetaClass, cls).__new__(cls, name, bases, attrs)


RuntimeError: 
</code></pre><p>从上面两个类实例的创建例子可见，<strong>实例化一个类对象的时候会先通过该类继承的元类创建出该类的类对象，然后通过该类的类对象创建出该类的对象。</strong></p>
<p>这句话很绕，其实很简单，就是从上往下不断地创建对象（元类 –&gt; 类 –&gt; 实例对象）。</p>
<h3 id="元类应用"><a href="#元类应用" class="headerlink" title="元类应用"></a>元类应用</h3><p>大家最熟悉的一个元类应用就是 <code>Django</code> 的 <code>ORM</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(models.Model)</span>:</span></div><div class="line">    name = models.CharField(max_length=<span class="number">30</span>)</div><div class="line">    age = models.IntegerField()</div><div class="line"></div><div class="line">p  = Person(name=<span class="string">'bob'</span>, age=<span class="number">35</span>)</div><div class="line">print(p.age)</div></pre></td></tr></table></figure>
<p>最终输出 <code>p.age</code> 为 <code>35</code> 而不是 <code>models.IntegerField()</code>，这是因为 <code>models.Model</code> 实现的自定义元类对数据库做了一系列 hook，最后暴露给我们这些简单的 API。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000#0" target="_blank" rel="external">使用元类</a></li>
<li><a href="http://www.dongwm.com/archives/%E8%AF%A6%E8%A7%A3Python/" target="_blank" rel="external">详解Python元类</a></li>
<li><a href="https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python" target="_blank" rel="external">What are metaclasses in Python?</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要理解 Python 中的元类只要记住：一切皆对象。记住这 5 个字，理解元类就会轻松很多。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django+uWSGI+Nginx部署</title>
    <link href="https://yuanblq.github.io/2018/04/04/Django-uWSGI-Nginx%E9%83%A8%E7%BD%B2/"/>
    <id>https://yuanblq.github.io/2018/04/04/Django-uWSGI-Nginx部署/</id>
    <published>2018-04-04T08:16:00.000Z</published>
    <updated>2018-04-04T08:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在玩微信小程序，但是测试的时候想和 Django 后端通信时出现了问题。</p>
<p>微信小程序的服务器域名配置文档中写到：</p>
<blockquote>
<p>服务器域名请在 小程序后台-设置-开发设置-服务器域名 中进行配置，配置时需要注意：  </p>
<ul>
<li>域名只支持 https (request、uploadFile、downloadFile) 和 wss (connectSocket) 协议；  </li>
<li>域名不能使用 IP 地址或 localhost，且不能带端口号；</li>
</ul>
</blockquote>
<p>这就尴尬了，所以可以采用 Nginx “隐藏”端口号，并搭建本地 https。</p>
<a id="more"></a>
<h2 id="安装uwsgi"><a href="#安装uwsgi" class="headerlink" title="安装uwsgi"></a>安装uwsgi</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>如果 <code>pip install uwsgi</code> 失败，很可能是没有安装 Python 的开发环境包，如果是 Debian 类型的系统直接 <code>apt-get install pythonX.Y-dev</code> 即可。</p>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><p>随便在哪里创建一个 <code>test.py</code> 文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)])</div><div class="line">    <span class="keyword">return</span> [<span class="string">b"Hello World"</span>] <span class="comment"># python3</span></div><div class="line">    <span class="comment">#return ["Hello World"] # python2</span></div></pre></td></tr></table></figure></p>
<p>然后再该文件所在位置执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --http :8000 --wsgi-file test.py</div></pre></td></tr></table></figure></p>
<p>这样，在浏览器输入 <code>yourdomain.com:8000</code> 即可看见写有 <code>Hello World</code> 的页面了。</p>
<ul>
<li><code>--http :8000</code> 表示使用 <code>http</code> 协议，端口号 <code>8000</code></li>
<li><code>wsgi-file test.py</code> 表示载入指定的 <code>test.py</code> 文件</li>
</ul>
<p>如果顺利完成这一步，那么 <code>浏览器 &lt;-&gt; uWSGI &lt;-&gt; Python</code> 这条路就走通了！</p>
<h3 id="接入-Django"><a href="#接入-Django" class="headerlink" title="接入 Django"></a>接入 Django</h3><p><code>cd your-Django-project-dir</code> 进入你的 Django 项目文件夹。</p>
<p>上面是直接指定某个 Python 文件，现在，我们只需指定某个项目模块即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --http :8000 --module your-Django-project.wsgi</div></pre></td></tr></table></figure></p>
<p>同样，打开浏览器输入 <code>yourdomain.com:8000</code> 即可看见我们的 Django 项目页面了。</p>
<p>如果顺利完成这一步，那么 <code>浏览器 &lt;-&gt; uWSGI &lt;-&gt; Django</code> 这条路就走通了！</p>
<h2 id="加入-nginx"><a href="#加入-nginx" class="headerlink" title="加入 nginx"></a>加入 nginx</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装完 <code>nginx</code> 后，确保 <code>nginx</code> 监听的是 80 端口，然后在浏览器输入 <code>yourdomain.com</code> 就能看到 <code>nginx</code> 默认的 <code>Welcome to nginx</code> 页面了。<br><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/Django/deploy/20180403152217.png" alt="Welcome to nginx"></p>
<p>如果顺利完成这一步，那么 <code>浏览器 &lt;-&gt; nginx</code> 这条路就走通了！</p>
<h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><h4 id="处理静态文件"><a href="#处理静态文件" class="headerlink" title="处理静态文件"></a>处理静态文件</h4><p>安装完 <code>nginx</code> 之后应该在类似 <code>/etc/nginx/</code> 目录下有一个叫做 <code>uwsgi_params</code> 的文件，把它拷贝至 Django 项目的目录下。如果没有 <code>uwsgi_params</code> 文件，可以从<a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params" target="_blank" rel="external">这里</a>复制一份。</p>
<p>现在我们在 <code>/etc/nginx/sites-available/</code> 文件夹下创建一个 <code>yourdomain_nginx.conf</code> 的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"># yourdomain_nginx.conf</div><div class="line"></div><div class="line"># the upstream component nginx needs to connect to</div><div class="line">upstream django &#123;</div><div class="line">    # server unix:///path/to/your/mysite/mysite.sock; # for a file socket</div><div class="line">    server 127.0.0.1:8001; # for a web port socket (we&apos;ll use this first)</div><div class="line">&#125;</div><div class="line"></div><div class="line"># configuration of the server</div><div class="line">server &#123;</div><div class="line">    # the port your site will be served on</div><div class="line">    listen      8000;</div><div class="line">    # the domain name it will serve for</div><div class="line">    server_name yourdomain.com; # substitute your machine&apos;s IP address or FQDN</div><div class="line">    charset     utf-8;</div><div class="line"></div><div class="line">    # max upload size</div><div class="line">    client_max_body_size 75M;   # adjust to taste</div><div class="line"></div><div class="line">    # Django media</div><div class="line">    location /media  &#123;</div><div class="line">        alias /path/to/your/mysite/media;  # your Django project&apos;s media files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /static &#123;</div><div class="line">        alias /path/to/your/mysite/static; # your Django project&apos;s static files - amend as required</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    # Finally, send all non-media requests to the Django server.</div><div class="line">    location / &#123;</div><div class="line">        uwsgi_pass  django;</div><div class="line">        include     /path/to/your/mysite/uwsgi_params; # the uwsgi_params file you installed</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个文件告诉 <code>nginx</code> 去处理我们 Django 项目的一些静态文件（media, static）。</p>
<p>然后我们创建一个软连接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /etc/nginx/sites-available/yourdomain_nginx.conf  /etc/nginx/sites-enabled/</div></pre></td></tr></table></figure></p>
<p>如果之前没有添加过 Django 静态文件夹配置的话，在 <code>settings.py</code> 文件中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 文件夹的位置需要和 yourdomain_nginx.conf 中配置的一样</div><div class="line">STATIC_ROOT = os.path.join(BASE_DIR, &quot;static/&quot;)</div></pre></td></tr></table></figure></p>
<p>然后执行：<code>python manage.py collectstatic</code> 将静态文件搜集进这个文件夹</p>
<p>现在重启 <code>nginx</code>: <code>/etc/init.d/nginx restart</code></p>
<p>在浏览器中输入 <code>http://www.yourdomain.com:8000/static/admin/js/autocomplete.js</code>，应该能看见这个 js 文件的内容。（你可能没有这个文件，视不同版本 Django 而定，你可以访问你自己的某个静态文件）<br><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/Django/deploy/20180403154812.png" alt="静态文件"></p>
<p>如果顺利完成这一步，那么 <code>浏览器 &lt;-&gt; nginx &lt;-&gt; 静态文件</code> 这条路就走通了！</p>
<h4 id="处理-uwsgi-链接（TCP-socket）"><a href="#处理-uwsgi-链接（TCP-socket）" class="headerlink" title="处理 uwsgi 链接（TCP socket）"></a>处理 uwsgi 链接（TCP socket）</h4><p>在 <code>yourdomain_nginx.conf</code> 文件中的这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">upstream django &#123;</div><div class="line">    # server unix:///path/to/your/mysite/mysite.sock; # for a file socket</div><div class="line">    server 127.0.0.1:8001; # for a web port socket (we&apos;ll use this first)</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">location / &#123;</div><div class="line">        uwsgi_pass  django;</div><div class="line">        include     /your-Django-project-dir/uwsgi_params; # the uwsgi_params file you installed</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>告诉了 <code>nginx</code> 去处理 <code>uwsgi</code> 过来的 <code>request</code>。</p>
<p>现在你在之前的 <code>test.py</code> 目录下执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --socket :8001 --wsgi-file test.py</div></pre></td></tr></table></figure></p>
<p>然后打开浏览器访问 <code>yourdomain.com:8000</code> 就能看见 <code>test.py</code> 中的 <code>Hello World</code> 了。</p>
<p>这时，<code>浏览器 &lt;-&gt; nginx &lt;-&gt; socket &lt;-&gt; uwsgi &lt;-&gt; Python</code> 这条路就走通了！</p>
<h4 id="处理-uwsgi-链接（unix-socket）"><a href="#处理-uwsgi-链接（unix-socket）" class="headerlink" title="处理 uwsgi 链接（unix socket）"></a>处理 uwsgi 链接（unix socket）</h4><p>在上面的 <code>yourdomain_nginx.conf</code> 文件中，配置 sock 文件位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">upstream django &#123;</div><div class="line">    server unix:///path/to/your/mysite/mysite.sock;</div><div class="line">    # server 127.0.0.1:8001;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启 <code>nginx</code></p>
<p>启动 <code>uWSGI</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --socket mysite.sock --wsgi-file test.py</div></pre></td></tr></table></figure></p>
<p>打开浏览器，访问 <code>yourdomain.com:8000</code> 就能看见 <code>test.py</code> 中的 <code>Hello World</code> 了。</p>
<blockquote>
<p><strong>注意：</strong><br>这里由于存在多个“用户”读写同一个文件（mysite.sock），所以可能会在 <code>uwsgi</code> 或者 <code>nginx</code> 中报权限不足的错误。<br>如果在 <code>nginx</code> 的错误日志中（/var/log/nginx/error.log）出现 <code>connect() to unix:///path/to/your/mysite/mysite.sock failed (13: Permission denied)</code>，你可以这么启动 <code>uwsgi</code>：<br><code>uwsgi --socket mysite.sock --wsgi-file test.py --chmod-socket=666</code>  </p>
<p>由于我是在 Docker 中跑的，启动 <code>uwsgi</code> 的时候一直报 <code>uwsgi bind(): Operation not permitted [core/socket.c line 230]</code> 这个权限的错误。<br>这是因为 <code>sock</code> 文件存放的位置在 Docker 的挂载路径中，从而导致了权限的问题，只需把 <code>sock</code> 文件存在其他位置即可。</p>
</blockquote>
<h2 id="Django-uWSGI-NGINX"><a href="#Django-uWSGI-NGINX" class="headerlink" title="Django + uWSGI + NGINX"></a>Django + uWSGI + NGINX</h2><p>现在我们把这三个连接到一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --socket mysite.sock --module mysite.wsgi</div></pre></td></tr></table></figure></p>
<p>打开浏览器，访问 <code>yourdomain.com</code> 就能看见 Django 的 Hello World 页面了。<br><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/Django/deploy/20180404154538.png" alt="Django 首页"></p>
<h2 id="uWSGI-配置"><a href="#uWSGI-配置" class="headerlink" title="uWSGI 配置"></a>uWSGI 配置</h2><p>uWSGI 启动的时候可以添加一些个性化配置，可以在项目文件夹下新建 <code>yourdomain_uwsgi.ini</code> 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"># yourdomain_uwsgi.ini file</div><div class="line">[uwsgi]</div><div class="line"></div><div class="line"># Django 项目根目录（绝对路径）</div><div class="line">chdir           = /path/to/your/project</div><div class="line"># Django 项目的 wsgi 文件</div><div class="line">module          = project.wsgi</div><div class="line"># Python 虚拟环境路径（绝对路径）</div><div class="line"># home            = /path/to/virtualenv</div><div class="line"></div><div class="line"># 是否为主进程</div><div class="line">master          = true</div><div class="line"># 最多工作进程数</div><div class="line">processes       = 4</div><div class="line"># sock 文件路径（绝对路径）</div><div class="line">socket          = /path/to/your/project/mysite.sock</div><div class="line"># 之前讲的权限问题，在这边设置合适的权限</div><div class="line"># chmod-socket    = 664</div><div class="line"># 退出时，清除环境</div><div class="line">vacuum          = true</div><div class="line"># uwsgi pid 文件存放路径</div><div class="line">pidfile         = /uwsgi_conf/uwsgi.pid</div><div class="line"># uwsgi log 文件存放路径（不添加则前台进程，加上后会转为后台进程）</div><div class="line">daemonize       = /uwsgi_conf/uwsgi.log</div></pre></td></tr></table></figure></p>
<p><code>uwsgi</code> 配置文件写完后，启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --ini yourdomain_uwsgi.ini</div></pre></td></tr></table></figure></p>
<h2 id="利用-NGINX-配置本地-HTTPS"><a href="#利用-NGINX-配置本地-HTTPS" class="headerlink" title="利用 NGINX 配置本地 HTTPS"></a>利用 NGINX 配置本地 HTTPS</h2><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><p>首先需要确认已经安装 <code>OpenSSL</code></p>
<p>装完后，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout server.key -out server.crt</div></pre></td></tr></table></figure></p>
<ul>
<li>req：处理证书签署请求。</li>
<li>x509：生成自签名证书。</li>
<li>nodes：跳过为证书设置密码的阶段，这样 Nginx 才可以直接打开证书。</li>
<li>days 365：证书有效期为一年。</li>
<li>newkey rsa:2048：生成一个新的私钥，采用的算法是2048位的 RSA。</li>
<li>keyout：新生成的私钥文件为当前目录下的 server.key。</li>
<li>out：新生成的证书文件为当前目录下的 server.crt。</li>
</ul>
<p>然后会让你填写一些信息，其中最重要的就是 <code>Common Name (e.g. server FQDN or YOUR name) []:</code></p>
<p>你可以填上你的域名（本地 hosts 中随意的”假”域名）或者 ip。</p>
<p>最后得到这两个文件：<code>example.crt</code>， <code>example.key</code>。</p>
<h3 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h3><p>将下面的代码加到之前 <code>yourdomain_nginx.conf</code> 的最后面（别忘了修改你对应的文件位置）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen 443 ssl http2;</div><div class="line">    server_name  yourdomain;</div><div class="line"></div><div class="line">    ssl                      on;</div><div class="line">    ssl_certificate          /path/to/your/server.crt;</div><div class="line">    ssl_certificate_key      /path/to/your/server.key;</div><div class="line"></div><div class="line">    ssl_session_timeout  5m;</div><div class="line"></div><div class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</div><div class="line">    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</div><div class="line">    ssl_prefer_server_ciphers   on;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        uwsgi_pass  django;</div><div class="line">        include     /path/to/your/uwsgi_params;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启 <code>nginx</code>，在浏览器中输入 <code>https://yourdomain.com</code>，即可看见之前的页面，不过这个 https 认证浏览器会认为是不安全的，对于本地测试完全不用在意。<br><img src="https://pages-ncdn-1253600859.cossh.myqcloud.com/Django/deploy/20180404160902.png" alt="https 页面"></p>
<p>好了，我要去玩微信小程序了。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="external">uWSGI 文档</a><br><a href="https://github.com/docker/compose/issues/3211#issuecomment-201503053" target="_blank" rel="external">Docker 跨容器挂载</a><br><a href="http://www.ruanyifeng.com/blog/2018/02/nginx-docker.html" target="_blank" rel="external">阮一峰 https 配置</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在玩微信小程序，但是测试的时候想和 Django 后端通信时出现了问题。&lt;/p&gt;
&lt;p&gt;微信小程序的服务器域名配置文档中写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器域名请在 小程序后台-设置-开发设置-服务器域名 中进行配置，配置时需要注意：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名只支持 https (request、uploadFile、downloadFile) 和 wss (connectSocket) 协议；  &lt;/li&gt;
&lt;li&gt;域名不能使用 IP 地址或 localhost，且不能带端口号；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就尴尬了，所以可以采用 Nginx “隐藏”端口号，并搭建本地 https。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="https://yuanblq.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>集中式日志系统ELK协议栈简介与入门</title>
    <link href="https://yuanblq.github.io/2018/03/13/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9FELK%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8/"/>
    <id>https://yuanblq.github.io/2018/03/13/集中式日志系统ELK协议栈简介与入门/</id>
    <published>2018-03-13T08:14:25.000Z</published>
    <updated>2018-03-23T01:34:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是“ELK”？</p>
<p>“ELK”是三大开源软件的缩写：Elasticsearch、Logstash、Kibana。</p>
<p>Elasticsearch 负责搜索和分析，Logstash 负责从各个来源搜集、转换数据，kibana 以图表的形式在 Elasticsearch 中展示数据。</p>
<a id="more"></a>
<h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>Logstash 需要 Java8 的支持，可以通过<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">官方发布版本</a>或者其他<a href="http://openjdk.java.net/" target="_blank" rel="external">开源版本</a>进行安装</p>
<p>安装完之后通过以下命令检查是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -version</div></pre></td></tr></table></figure></p>
<p>安装正常的话会出现下面类似的响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version &quot;1.8.0_65&quot;</div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_65-b17)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode)</div></pre></td></tr></table></figure></p>
<h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>从<a href="https://www.elastic.co/downloads/logstash" target="_blank" rel="external">官网</a>下载符合你操作系统的安装文件。然后解压，记住不要安装在带有冒号（:）的路径中。</p>
<h3 id="仓库安装"><a href="#仓库安装" class="headerlink" title="仓库安装"></a>仓库安装</h3><p>对于一些 Linux 发布版，可以直接从其软件仓库直接安装。</p>
<h4 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h4><p>下载公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure></p>
<p>确保 <code>apt-transport-https</code> 包已经安装，没有的话先安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install apt-transport-https</div></pre></td></tr></table></figure></p>
<p>加入仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://artifacts.elastic.co/packages/6.x/apt stable main"</span> | sudo tee <span class="_">-a</span> /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure></p>
<p>最后安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install logstash</div></pre></td></tr></table></figure></p>
<h4 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h4><p>下载安装公钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ rpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch</div></pre></td></tr></table></figure></p>
<p>将下面的内容写入新文件 <code>/etc/yum.repos.d/logstash.repo</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[logstash-6.x]</div><div class="line">name=Elastic repository for 6.x packages</div><div class="line">baseurl=https://artifacts.elastic.co/packages/6.x/yum</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch</div><div class="line">enabled=1</div><div class="line">autorefresh=1</div><div class="line">type=rpm-md</div></pre></td></tr></table></figure></p>
<p>安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install logstash</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考文档：<br><a href="https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#package-repositories" target="_blank" rel="external">https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#package-repositories</a></p>
</blockquote>
<h2 id="测试Logstash"><a href="#测试Logstash" class="headerlink" title="测试Logstash"></a>测试Logstash</h2><p>每个 Logstash 的 Pipeline 都必须这两个元素：<code>input</code> 和 <code>output</code>，以及一个可选元素：<code>filter</code>。</p>
<p>先来测试 Logstash 有没有安装成功。在命令行运行以下最基本的 Pipeline：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-e</span> <span class="string">'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'</span></div></pre></td></tr></table></figure></p>
<p>启动 Logstash 之后，看见 <code>The stdin plugin is now waiting for input:</code> 说明已经启动成功，然后在命令行输入 <code>hello world</code>，你会得到如下相似的内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The stdin plugin is now waiting <span class="keyword">for</span> input:</div><div class="line">hello world</div><div class="line">2018-03-12T08:37:16.976Z xxxdeiMac.local hello world</div></pre></td></tr></table></figure></p>
<p>Logstash 会把时间戳和 IP 地址信息传递给 message。通过 CTRL-D 退出 Logstash。</p>
<h2 id="安装Elasticsearch"><a href="#安装Elasticsearch" class="headerlink" title="安装Elasticsearch"></a>安装Elasticsearch</h2><p>不同的操作系统发布版本安装过程有些许不同，具体见<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/install-elasticsearch.html" target="_blank" rel="external">官网</a>。下面以 Ubuntu 为例。</p>
<h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><p>同样需要 Java8 的环境</p>
<h3 id="仓库安装-1"><a href="#仓库安装-1" class="headerlink" title="仓库安装"></a>仓库安装</h3><p>导入公钥</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</div></pre></td></tr></table></figure>
<p>从APT仓库安装</p>
<p>如果没有安装过 <code>apt-transport-https</code> 包，同样要先安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install apt-transport-https</div></pre></td></tr></table></figure></p>
<p>加入仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://artifacts.elastic.co/packages/6.x/apt stable main"</span> | sudo tee <span class="_">-a</span> /etc/apt/sources.list.d/elastic-6.x.list</div></pre></td></tr></table></figure>
<p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update &amp;&amp; sudo apt-get install elasticsearch</div></pre></td></tr></table></figure>
<h3 id="启动Elasticsearch"><a href="#启动Elasticsearch" class="headerlink" title="启动Elasticsearch"></a>启动Elasticsearch</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  ~ <span class="built_in">cd</span> elasticsearch-6.2.2</div><div class="line">➜  elasticsearch-6.2.2 bin/elasticsearch</div></pre></td></tr></table></figure>
<p>当看到如下类似的log，说明基本启动完成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2018-03-12T17:30:02,153][INFO ][o.e.n.Node] [0TDYPSN] started</div></pre></td></tr></table></figure></p>
<p>打开浏览器，进入 <code>localhost:9200</code>，看见如下内容说明已经启动了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;0TDYPSN&quot;,</div><div class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</div><div class="line">  &quot;cluster_uuid&quot; : &quot;uQ0qekKORmKT5XgH6rzWmA&quot;,</div><div class="line">  &quot;version&quot; : &#123;</div><div class="line">    &quot;number&quot; : &quot;6.2.2&quot;,</div><div class="line">    &quot;build_hash&quot; : &quot;10b1edd&quot;,</div><div class="line">    &quot;build_date&quot; : &quot;2018-02-16T19:01:30.685723Z&quot;,</div><div class="line">    &quot;build_snapshot&quot; : false,</div><div class="line">    &quot;lucene_version&quot; : &quot;7.2.1&quot;,</div><div class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</div><div class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="利用-Logstash-解析-log-并输出到-Elasticsearch"><a href="#利用-Logstash-解析-log-并输出到-Elasticsearch" class="headerlink" title="利用 Logstash 解析 log 并输出到 Elasticsearch"></a>利用 Logstash 解析 log 并输出到 Elasticsearch</h2><p>上面我们创建了一个最最基本的 Logstash Pipeline 用于测试安装是否成功。在实际工作中，一个 Pipeline 都会比这复杂点：经常会有多个 <code>input</code>，<code>filter</code> 和 <code>output</code> 插件。</p>
<p>现在我们通过 Filebeat 来把实际工作中产生的日志文件发送给 Logstash。</p>
<h3 id="安装-Filebeat"><a href="#安装-Filebeat" class="headerlink" title="安装 Filebeat"></a>安装 Filebeat</h3><p>根据自己的操作系统从<a href="https://www.elastic.co/guide/en/beats/filebeat/6.2/filebeat-installation.html" target="_blank" rel="external">官网</a>匹配合适的安装方式</p>
<h3 id="配置-Filebeat"><a href="#配置-Filebeat" class="headerlink" title="配置 Filebeat"></a>配置 Filebeat</h3><p>将下面的内容覆盖到 Filebeat 文件夹下的 <code>filebeat.yml</code> 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">filebeat.prospectors:</div><div class="line">- type: log</div><div class="line">  paths:</div><div class="line">    - /absolute/path/to/file/test_logs.log </div><div class="line">output.logstash:</div><div class="line">  hosts: [&quot;localhost:5044&quot;]</div></pre></td></tr></table></figure></p>
<h3 id="配置-Logstash-来接收-Filebeat-的输入"><a href="#配置-Logstash-来接收-Filebeat-的输入" class="headerlink" title="配置 Logstash 来接收 Filebeat 的输入"></a>配置 Logstash 来接收 Filebeat 的输入</h3><p>前面我们验证 Logstash 有没有安装成功的时候，在命令行创建了一个最简单的 Pipeline（命令行接收 Events，并在命令行输出），现在我们要创建一个比较复杂的 Pipeline 来从 Beats 接收 Events。</p>
<p>当然比较复杂的 Pipeline 就不能再在命令行直接创建了，我们得先配置在文件中。</p>
<p>在 Logstash 目录下，创建 <code>first-pipeline.conf</code> 文件。</p>
<p>先把下面这个 Pipeline 的骨架搭好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 井号可以用作注释</div><div class="line">input &#123;</div><div class="line">&#125;</div><div class="line"># 还记得吗 filter 这部件适可选的</div><div class="line"># filter &#123;</div><div class="line">#</div><div class="line"># &#125;</div><div class="line">output &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>骨架就这样，当然现在还不能用，我们还得定义输入输出部分的配置。</p>
<ul>
<li><p>在 <code>input</code> 部分配置 Beat 插件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">beats &#123;</div><div class="line">    port =&gt; &quot;5044&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>配置 <code>output</code> 部分<br>  我们先把输出配置到 stdout，之后再搞到 Elasticsearch（一步步来 ~。~）。<br>  在 <code>output</code> 块中添加如下配置：  </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stdout &#123; codec =&gt; rubydebug &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面配完之后，你的 <code>first-pipeline.conf</code> 文件基本长成这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5044&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"># filter &#123;</div><div class="line">#</div><div class="line"># &#125;</div><div class="line">output &#123;</div><div class="line">    stdout &#123; codec =&gt; rubydebug &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用这个 Pipeline 之前，可以用下面的命令检查配置是否正确：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-f</span> first-pipeline.conf --config.test_and_exit</div></pre></td></tr></table></figure></p>
<p>如果测试通过，则会在命令行出现以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[2018-03-13T10:02:29,275][INFO ][logstash.runner] Using config.test_and_exit mode. Config Validation Result: OK. Exiting Logstash</div></pre></td></tr></table></figure></p>
<p>通过测试后，通过下面的命令启动 Logstash：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  logstash-6.2.2 bin/logstash <span class="_">-f</span> first-pipeline.conf --config.reload.automatic</div></pre></td></tr></table></figure></p>
<p><code>--config.reload.automatic</code> 能够自动重载配置，这样每次修改完配置后不用重启 Logstash 了。</p>
<h3 id="生产假数据-）"><a href="#生产假数据-）" class="headerlink" title="生产假数据 ;）"></a>生产假数据 ;）</h3><p>现在还没有可以采集的 log 日志，但是，毛主席说过：没有 log 我们就自己创造 log！</p>
<p>将以下内容复制到 <code>generate_logs.py</code> 文件中:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">METHODS = [<span class="string">'GET'</span>, <span class="string">'POST'</span>, <span class="string">'PUT'</span>, <span class="string">'DELETE'</span>]</div><div class="line">INTERFACES = [</div><div class="line">    <span class="string">'/interface/1'</span>, <span class="string">'/interface/2'</span>, <span class="string">'/interface/3'</span>,</div><div class="line">    <span class="string">'/interface/4'</span>, <span class="string">'/interface/5'</span>, <span class="string">'/interface/6'</span>,</div><div class="line">]</div><div class="line">STATUS_CODES = [<span class="number">200</span>, <span class="number">201</span>, <span class="number">301</span>, <span class="number">400</span>, <span class="number">401</span>, <span class="number">403</span>, <span class="number">404</span>, <span class="number">500</span>]</div><div class="line"></div><div class="line">LOG_FORMAT = <span class="string">'[&#123;&#125;] "&#123;&#125; &#123;&#125; HTTP/1.1" &#123;&#125;\r\n'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_fade_logs</span><span class="params">(log_path)</span>:</span></div><div class="line">    current_time = datetime.datetime.now().strftime(<span class="string">'%d/%m/%y %H:%M:%S'</span>)</div><div class="line">    method = random.choice(METHODS)</div><div class="line">    interface = random.choice(INTERFACES)</div><div class="line">    status_code = random.choice(STATUS_CODES)</div><div class="line"></div><div class="line">    log = LOG_FORMAT.format(current_time, method, interface, status_code)</div><div class="line"></div><div class="line">    <span class="keyword">with</span> open(log_path, <span class="string">'a'</span>) <span class="keyword">as</span> f:</div><div class="line">        f.writelines(log)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">while</span>  <span class="keyword">True</span>:</div><div class="line">        generate_fade_logs(<span class="string">'/Users/a/Desktop/test_logs.log'</span>)</div><div class="line">        time.sleep(random.randint(<span class="number">10</span>, <span class="number">20</span>))</div></pre></td></tr></table></figure></p>
<p>启动我们的“log生成器”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  ~ python generate_logs.py</div></pre></td></tr></table></figure></p>
<h3 id="启动-Filebeat"><a href="#启动-Filebeat" class="headerlink" title="启动 Filebeat"></a>启动 Filebeat</h3><p>在另一个命令行窗口输入以下命令启动 Filebeat：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>启动之后，伴随着“log生成器”的辛勤工作，你会在前面 Logstash 启动的命令行窗口和 Filebeat 启动的命令窗口中不断看到如下类似的信息的出现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;prospector&quot; =&gt; &#123;</div><div class="line">        &quot;type&quot; =&gt; &quot;log&quot;</div><div class="line">    &#125;,</div><div class="line">          &quot;tags&quot; =&gt; [</div><div class="line">        [0] &quot;beats_input_codec_plain_applied&quot;</div><div class="line">    ],</div><div class="line">        &quot;source&quot; =&gt; &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</div><div class="line">       &quot;message&quot; =&gt; &quot;[13/03/18 10:20:29] \&quot;DELETE /interface/5 HTTP/1.1\&quot; 404&quot;,</div><div class="line">    &quot;@timestamp&quot; =&gt; 2018-03-13T02:20:30.713Z,</div><div class="line">        &quot;offset&quot; =&gt; 4004,</div><div class="line">          &quot;beat&quot; =&gt; &#123;</div><div class="line">            &quot;name&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">        &quot;hostname&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">         &quot;version&quot; =&gt; &quot;6.2.2&quot;</div><div class="line">    &#125;,</div><div class="line">          &quot;host&quot; =&gt; &quot;xxxdeiMac.local&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用-Grok-过滤插件解析-log"><a href="#使用-Grok-过滤插件解析-log" class="headerlink" title="使用 Grok 过滤插件解析 log"></a>使用 Grok 过滤插件解析 log</h3><p>我们的 Pipeline 已经能从 Filebeat 中读取 log 信息了，但是你也看到了，输出的 log 信息全存在了 <code>message</code> 字段，我们得目的是获取这串 log 信息中的各个部分数据，为了解决这个问题，我们需要使用 <code>Grok</code> 过滤插件。</p>
<p>我们“log 生成器”生成的日志格式是长这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[13/03/18 10:22:29] &quot;POST /interface/2 HTTP/1.1&quot; 201</div></pre></td></tr></table></figure></p>
<p>中括号里面是时间，接着引号里面是请求方法、请求内容、HTTP协议，最后是响应的状态码。</p>
<p><code>Grok</code> 的解析语法一般长这样：<code>%{语法:语义}</code>。比如 <code>3.44</code> 这个数据，我们可以用 <code>NUMBER</code> 这个内置语法来捕获到，而 <code>POST</code> 这个单词可以用 <code>WORD</code> 这个内置语法捕获。</p>
<p>对于我们的日志格式，我们得 <code>Grok</code> 过滤语法可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们把这个过滤语法加到 <code>filter</code> 块中试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">filter &#123;</div><div class="line">    grok &#123;</div><div class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终，我们的 <code>first-pipeline.conf</code> 长这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">    beats &#123;</div><div class="line">        port =&gt; &quot;5044&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">filter &#123;</div><div class="line">    grok &#123;</div><div class="line">        match =&gt; &#123; &quot;message&quot; =&gt; &quot;\[%&#123;DATESTAMP:date&#125;\] \&quot;%&#123;WORD:verb&#125; %&#123;URIPATHPARAM:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;\&quot; %&#123;NUMBER:status_code&#125;&quot;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">output &#123;</div><div class="line">    stdout &#123; codec =&gt; rubydebug &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意:</strong><br>由于 Filebeat 读取日志文件的时候会记住当前读到哪个位置，下次会接在这个位置之后读取，我们先 <code>CTRL-C</code> 停止 FileBeat 的读取，然后我们需要把记录这个信息的文件删除：<code>rm data.registry</code></p>
</blockquote>
<p>现在重启 <code>Filebeat</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  filebeat-6.2.2-darwin-x86_64 ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>现在我们的 Logstash 命令行应该会输出以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">           &quot;beat&quot; =&gt; &#123;</div><div class="line">         &quot;version&quot; =&gt; &quot;6.2.2&quot;,</div><div class="line">            &quot;name&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">        &quot;hostname&quot; =&gt; &quot;xxxdeiMac.local&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;httpversion&quot; =&gt; &quot;1.1&quot;,</div><div class="line">           &quot;host&quot; =&gt; &quot;xxxdeiMac.local&quot;,</div><div class="line">     &quot;prospector&quot; =&gt; &#123;</div><div class="line">        &quot;type&quot; =&gt; &quot;log&quot;</div><div class="line">    &#125;,</div><div class="line">           &quot;tags&quot; =&gt; [</div><div class="line">        [0] &quot;beats_input_codec_plain_applied&quot;</div><div class="line">    ],</div><div class="line">           &quot;date&quot; =&gt; &quot;13/03/18 15:07:38&quot;,</div><div class="line">           &quot;verb&quot; =&gt; &quot;PUT&quot;,</div><div class="line">        &quot;request&quot; =&gt; &quot;/interface/5&quot;,</div><div class="line">     &quot;@timestamp&quot; =&gt; 2018-03-13T07:07:44.509Z,</div><div class="line">         &quot;source&quot; =&gt; &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">    &quot;status_code&quot; =&gt; &quot;201&quot;,</div><div class="line">         &quot;offset&quot; =&gt; 5183,</div><div class="line">        &quot;message&quot; =&gt; &quot;[13/03/18 15:07:38] \&quot;PUT /interface/5 HTTP/1.1\&quot; 201&quot;,</div><div class="line">       &quot;@version&quot; =&gt; &quot;1&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>date</code>，<code>verb</code>，<code>request</code>，<code>httpversion</code>，<code>status_code</code> 字段就是我们通过 <code>Grok</code> 解析出来的字段。当然，原本的 <code>message</code> 依然存在。</p>
<h3 id="索引化数据并发给-Elasticsearch"><a href="#索引化数据并发给-Elasticsearch" class="headerlink" title="索引化数据并发给 Elasticsearch"></a>索引化数据并发给 Elasticsearch</h3><p>首先，我们先把数据输出给 Elasticsearch，在 <code>first-pipeline.conf</code> 文件的 <code>output</code> 块中增加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">output &#123;</div><div class="line">    elasticsearch &#123;</div><div class="line">        hosts =&gt; [ &quot;localhost:9200&quot; ]</div><div class="line">        index =&gt; &quot;testlog&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>hosts</code> 包含运行有 Elasticsearch 的实例地址，<code>index</code> 是索引名字，等会会在 Kibana 中用到。</p>
<blockquote>
<p><strong>注意：</strong><br>上述的配置，假定 Logstash 和 Elasticsearch 都是跑在同一台实例上。</p>
</blockquote>
<p>像上面一样，重启 Filebeat，让 Filebeat 重新读取整个日志文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  filebeat-6.2.2-darwin-x86_64 rm data/registry</div><div class="line">➜  filebeat-6.2.2-darwin-x86_64 ./filebeat <span class="_">-e</span> -c filebeat.yml <span class="_">-d</span> <span class="string">"publish"</span></div></pre></td></tr></table></figure></p>
<p>上面我们安装 Elasticsearch 的时候已经启动了，如果没有启动的话现在可以启动 Elasticsearch 了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  elasticsearch-6.2.2 bin/elasticsearch</div></pre></td></tr></table></figure></p>
<p>由于 <code>Grok</code> 过滤插件已经帮我们把数据建好索引并发给了 Elasticsearch，我们可以通过在浏览器输入 <code>localhost:9200/_cat/indices?v</code> 来查看已经建好的索引名字，一般为 <code>logstash-$DATE</code>，<code>$DATE</code> 为 <code>Grok</code> 插件建立索引时候的日期：<code>YYYY.MM.DD</code>。</p>
<p>拿到索引名称后在浏览器输入 <code>localhost:9200/logstash-$DATE/_search?pretty&amp;q=status_code=404</code> 即可看到我们上面解析到的 <code>status_code</code> 这个字段全部为 <code>404</code> 的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;took&quot; : 30,</div><div class="line">  &quot;timed_out&quot; : false,</div><div class="line">  &quot;_shards&quot; : &#123;</div><div class="line">    &quot;total&quot; : 5,</div><div class="line">    &quot;successful&quot; : 5,</div><div class="line">    &quot;skipped&quot; : 0,</div><div class="line">    &quot;failed&quot; : 0</div><div class="line">  &#125;,</div><div class="line">  &quot;hits&quot; : &#123;</div><div class="line">    &quot;total&quot; : 30,</div><div class="line">    &quot;max_score&quot; : 2.384823,</div><div class="line">    &quot;hits&quot; : [</div><div class="line">      &#123;</div><div class="line">        &quot;_index&quot; : &quot;logstash-2018.03.13&quot;,</div><div class="line">        &quot;_type&quot; : &quot;doc&quot;,</div><div class="line">        &quot;_id&quot; : &quot;iNpDHmIBdTFR9RiADh6e&quot;,</div><div class="line">        &quot;_score&quot; : 2.384823,</div><div class="line">        &quot;_source&quot; : &#123;</div><div class="line">          &quot;date&quot; : &quot;13/03/18 15:05:21&quot;,</div><div class="line">          &quot;@timestamp&quot; : &quot;2018-03-13T07:28:46.413Z&quot;,</div><div class="line">          &quot;request&quot; : &quot;/interface/6&quot;,</div><div class="line">          &quot;verb&quot; : &quot;POST&quot;,</div><div class="line">          &quot;tags&quot; : [</div><div class="line">            &quot;beats_input_codec_plain_applied&quot;</div><div class="line">          ],</div><div class="line">          &quot;@version&quot; : &quot;1&quot;,</div><div class="line">          &quot;prospector&quot; : &#123;</div><div class="line">            &quot;type&quot; : &quot;log&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;status_code&quot; : &quot;404&quot;,</div><div class="line">          &quot;message&quot; : &quot;[13/03/18 15:05:21] \&quot;POST /interface/6 HTTP/1.1\&quot; 404&quot;,</div><div class="line">          &quot;source&quot; : &quot;/Users/a/Desktop/test_logs.log&quot;,</div><div class="line">          &quot;beat&quot; : &#123;</div><div class="line">            &quot;version&quot; : &quot;6.2.2&quot;,</div><div class="line">            &quot;hostname&quot; : &quot;1deiMac.local&quot;,</div><div class="line">            &quot;name&quot; : &quot;1deiMac.local&quot;</div><div class="line">          &#125;,</div><div class="line">          &quot;host&quot; : &quot;1deiMac.local&quot;,</div><div class="line">          &quot;offset&quot; : 4702,</div><div class="line">          &quot;httpversion&quot; : &quot;1.1&quot;</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      ...</div><div class="line">      ...</div><div class="line">      ...</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们基本就已经把 <code>Filebeat --&gt; Logstash --&gt; Elasticsearch</code> 这条路打通了！</p>
<p>接下来要想更直观的查看分析数据，就需要引入 <code>ELK</code> 三大组件之 <code>Kibana</code>。</p>
<h2 id="更直观的数据展示-——-Kibana"><a href="#更直观的数据展示-——-Kibana" class="headerlink" title="更直观的数据展示 —— Kibana"></a>更直观的数据展示 —— Kibana</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>根据自己对应的操作系统，从[官网]下载安装相应的版本。</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>修改 <code>config/kibana.yml</code> 文件，将 <code>elasticsearch.url</code> 这个字段指向你的 Elasticsearch 实例。</p>
<p>命令行输入 <code>bin/kibana</code> 启动，然后就可以在 <code>localhost:5601</code> 访问了。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>进入 <code>Kibana</code> 后，首先需要配置一个索引文件，不然 <code>Kibana</code> 也不知道该展示什么数据。</p>
<p>选择索引<br><img src="https://pages-ncdn-1253600859.picsh.myqcloud.com/kibana-install/14_02_14__03_19_2018.jpg!pages" alt="选择索引"></p>
<p>选择时间过滤字段<br><img src="https://pages-ncdn-1253600859.picsh.myqcloud.com/kibana-install/17_45_36__03_13_2018.jpg!pages" alt="选择时间过滤字段"></p>
<p>最后就可以在 <code>discover</code> 中看到我们的数据了<br><img src="https://pages-ncdn-1253600859.picsh.myqcloud.com/kibana-install/17_47_21__03_13_2018.jpg!pages" alt="数据展示"></p>
<h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p><a href="https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html" target="_blank" rel="external">Logstash 官方文档</a><br><a href="https://www.elastic.co/guide/en/logstash/6.2/plugins-filters-grok.html" target="_blank" rel="external">Grok 官方文档</a><br><a href="http://grokconstructor.appspot.com/" target="_blank" rel="external">Grok Constructor</a><br><a href="http://grokdebug.herokuapp.com/" target="_blank" rel="external">Grok Debugger</a><br><a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="external">Kibana 官方文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是“ELK”？&lt;/p&gt;
&lt;p&gt;“ELK”是三大开源软件的缩写：Elasticsearch、Logstash、Kibana。&lt;/p&gt;
&lt;p&gt;Elasticsearch 负责搜索和分析，Logstash 负责从各个来源搜集、转换数据，kibana 以图表的形式在 Elasticsearch 中展示数据。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Data" scheme="https://yuanblq.github.io/tags/Data/"/>
    
  </entry>
  
  <entry>
    <title>Celery 后台运行</title>
    <link href="https://yuanblq.github.io/2018/01/17/Celery-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/"/>
    <id>https://yuanblq.github.io/2018/01/17/Celery-后台运行/</id>
    <published>2018-01-17T07:20:15.000Z</published>
    <updated>2018-01-17T07:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Celery-后台运行"><a href="#Celery-后台运行" class="headerlink" title="Celery 后台运行"></a>Celery 后台运行</h2><p>测试的时候我们可以直接在不同的终端直接运行 Celery 进程，但是如果要在服务器上运行，那我们岂不是得开好几个终端，而且退出终端之后 Celery 进程也就停止了，能不能让 Celery 在后台以守护进程的方式运行？</p>
<p>不用说，当然是可以的，而且还不止一种方式。这里先介绍 <code>init-script</code> 方法。</p>
<a id="more"></a>
<h3 id="使用通用的-init-script"><a href="#使用通用的-init-script" class="headerlink" title="使用通用的 init-script"></a>使用通用的 init-script</h3><p>首先获取 Celery 的 GitHub 仓库 <a href="https://github.com/celery/celery/tree/3.1/extra/generic-init.d/" target="_blank" rel="external"><code>extra/generic-init.d/</code></a> 文件夹下的文件。</p>
<h4 id="启动-worker"><a href="#启动-worker" class="headerlink" title="启动 worker"></a>启动 worker</h4><p>将上面 GitHub 仓库文件夹下的 <code>celeryd</code> 文件复制到本地的 <code>/etc/init.d/celeryd</code> 文件中并赋予可执行的权限: <code>sudo chmod +x /etc/init.d/celeryd</code>，然后在 <code>/etc/default/</code> 文件夹下创建 <code>celeryd</code> 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Names of nodes to start</span></div><div class="line"><span class="comment">#   most people will only start one node:</span></div><div class="line">CELERYD_NODES=<span class="string">"worker1"</span></div><div class="line"><span class="comment">#   but you can also start multiple and configure settings</span></div><div class="line"><span class="comment">#   for each in CELERYD_OPTS</span></div><div class="line"><span class="comment">#CELERYD_NODES="worker1 worker2 worker3"</span></div><div class="line"><span class="comment">#   alternatively, you can specify the number of nodes to start:</span></div><div class="line"><span class="comment">#CELERYD_NODES=10</span></div><div class="line"></div><div class="line"><span class="comment"># Absolute or relative path to the 'celery' command:</span></div><div class="line">CELERY_BIN=<span class="string">"/usr/local/bin/celery"</span></div><div class="line"><span class="comment">#CELERY_BIN="/virtualenvs/def/bin/celery"</span></div><div class="line"></div><div class="line"><span class="comment"># App instance to use</span></div><div class="line"><span class="comment"># comment out this line if you don't use an app</span></div><div class="line">CELERY_APP=<span class="string">"proj"</span></div><div class="line"><span class="comment"># or fully qualified:</span></div><div class="line"><span class="comment">#CELERY_APP="proj.tasks:app"</span></div><div class="line"></div><div class="line"><span class="comment"># Where to chdir at start.</span></div><div class="line">CELERYD_CHDIR=<span class="string">"/opt/Myproject/"</span></div><div class="line"></div><div class="line"><span class="comment"># Extra command-line arguments to the worker</span></div><div class="line">CELERYD_OPTS=<span class="string">"--time-limit=300 --concurrency=8"</span></div><div class="line"><span class="comment"># Configure node-specific settings by appending node name to arguments:</span></div><div class="line"><span class="comment">#CELERYD_OPTS="--time-limit=300 -c 8 -c:worker2 4 -c:worker3 2 -Ofair:worker1"</span></div><div class="line"></div><div class="line"><span class="comment"># Set logging level to DEBUG</span></div><div class="line"><span class="comment">#CELERYD_LOG_LEVEL="DEBUG"</span></div><div class="line"></div><div class="line"><span class="comment"># %n will be replaced with the first part of the nodename.</span></div><div class="line">CELERYD_LOG_FILE=<span class="string">"/var/log/celery/%n%I.log"</span></div><div class="line">CELERYD_PID_FILE=<span class="string">"/var/run/celery/%n.pid"</span></div><div class="line"></div><div class="line"><span class="comment"># Workers should run as an unprivileged user.</span></div><div class="line"><span class="comment">#   You need to create this user manually (or you can choose</span></div><div class="line"><span class="comment">#   a user/group combination that already exists (e.g., nobody).</span></div><div class="line">CELERYD_USER=<span class="string">"celery"</span></div><div class="line">CELERYD_GROUP=<span class="string">"celery"</span></div><div class="line"></div><div class="line"><span class="comment"># If enabled pid and log directories will be created if missing,</span></div><div class="line"><span class="comment"># and owned by the userid/group configured.</span></div><div class="line">CELERY_CREATE_DIRS=1</div></pre></td></tr></table></figure>
<p>这个配置文件中，你可能需要更改 <code>CELERY_BIN</code>, <code>CELERY_APP</code>, <code>CELERYD_CHDIR</code>, <code>CELERYD_USER</code>, <code>CELERYD_GROUP</code>。</p>
<p>根据你自身项目配置好上述配置后就可以通过 <code>/etc/init.d/celeryd {start|stop|restart|graceful|kill|dryrun|create-paths}</code> 这些命令来控制 Celery worker 进程。</p>
<h4 id="启动-beat"><a href="#启动-beat" class="headerlink" title="启动 beat"></a>启动 beat</h4><p>如果你的项目中还有周期任务，那么还得把 Celery beat 启动起来。</p>
<p>把 GitHub 仓库中的 <code>celerybeat</code> 文件复制到 <code>/etc/init.d/celerybeat</code> 文件中，然后赋予可执行权限: <code>sudo chmod +x /etc/init.d/celerybeat</code>。</p>
<p>然后同样得有一个 <code>/etc/default/celerybeat</code> 配置文件。不过，如果没有什么特殊配置，可以直接使用 <code>/etc/default/celeryd</code> 配置文件，不必创建 <code>/etc/default/celerybeat</code> 配置文件。</p>
<p>如果你依然要创建的，那么这个文件可能是长这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Absolute or relative path to the 'celery' command:</span></div><div class="line">CELERY_BIN=<span class="string">"/usr/local/bin/celery"</span></div><div class="line"><span class="comment">#CELERY_BIN="/virtualenvs/def/bin/celery"</span></div><div class="line"></div><div class="line"><span class="comment"># App instance to use</span></div><div class="line"><span class="comment"># comment out this line if you don't use an app</span></div><div class="line">CELERY_APP=<span class="string">"proj"</span></div><div class="line"><span class="comment"># or fully qualified:</span></div><div class="line"><span class="comment">#CELERY_APP="proj.tasks:app"</span></div><div class="line"></div><div class="line"><span class="comment"># Where to chdir at start.</span></div><div class="line">CELERYBEAT_CHDIR=<span class="string">"/opt/Myproject/"</span></div><div class="line"></div><div class="line"><span class="comment"># Extra arguments to celerybeat</span></div><div class="line">CELERYBEAT_OPTS=<span class="string">"--schedule=/var/run/celery/celerybeat-schedule"</span></div></pre></td></tr></table></figure>
<p>完成配置后，同样通过 <code>/etc/init.d/celerybeat {start|stop|restart|create-paths|status}</code> 这些命令控制 Celery beat 进程。</p>
<blockquote>
<p>参考文档：<br><a href="http://docs.celeryproject.org/en/latest/userguide/daemonizing.html" target="_blank" rel="external">Celery daemon</a><br><a href="https://pythad.github.io/articles/2016-12/how-to-run-celery-as-a-daemon-in-production" target="_blank" rel="external">How to run celery as a daemon?</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Celery-后台运行&quot;&gt;&lt;a href=&quot;#Celery-后台运行&quot; class=&quot;headerlink&quot; title=&quot;Celery 后台运行&quot;&gt;&lt;/a&gt;Celery 后台运行&lt;/h2&gt;&lt;p&gt;测试的时候我们可以直接在不同的终端直接运行 Celery 进程，但是如果要在服务器上运行，那我们岂不是得开好几个终端，而且退出终端之后 Celery 进程也就停止了，能不能让 Celery 在后台以守护进程的方式运行？&lt;/p&gt;
&lt;p&gt;不用说，当然是可以的，而且还不止一种方式。这里先介绍 &lt;code&gt;init-script&lt;/code&gt; 方法。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Celery" scheme="https://yuanblq.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>celery入门到使用</title>
    <link href="https://yuanblq.github.io/2018/01/16/celery%E5%85%A5%E9%97%A8%E5%88%B0%E4%BD%BF%E7%94%A8/"/>
    <id>https://yuanblq.github.io/2018/01/16/celery入门到使用/</id>
    <published>2018-01-16T09:10:46.000Z</published>
    <updated>2018-01-16T09:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="celery入门到使用"><a href="#celery入门到使用" class="headerlink" title="celery入门到使用"></a>celery入门到使用</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ pip install celery</div><div class="line">$ pip install redis</div></pre></td></tr></table></figure>
<h3 id="celery应用"><a href="#celery应用" class="headerlink" title="celery应用"></a>celery应用</h3><p>使用 celery 的前提是你得有一个 Celery 的实例。我们可以称之为 Celery 应用或者简单地说 app。该实例是用来创建 task 任务、管理 worker 等等，所以必须保证在我们得其他模块中能将它导入过来。</p>
<a id="more"></a>
<h3 id="单个模块"><a href="#单个模块" class="headerlink" title="单个模块"></a>单个模块</h3><p>创建一个 tasks.py 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">from celery import Celery</div><div class="line"></div><div class="line">app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379/1&apos;)</div><div class="line"></div><div class="line">@app.task</div><div class="line">def add(x, y):</div><div class="line">    return x + y</div></pre></td></tr></table></figure></p>
<p>[分析]：<code>Celery()</code> 的第一个参数是当前模块的名字，第二个参数是 <code>broker</code> 关键字参数，填写你用的 broker 的 URL 地址。然后定义了一个叫做 add 的任务。</p>
<h3 id="启动-celery-worker-服务"><a href="#启动-celery-worker-服务" class="headerlink" title="启动 celery worker 服务"></a>启动 celery worker 服务</h3><p>通过 <code>worker</code> 参数启动我们的 worker：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ celery -A tasks worker --loglevel=info</div></pre></td></tr></table></figure></p>
<h3 id="调用-task"><a href="#调用-task" class="headerlink" title="调用 task"></a>调用 task</h3><p>调用 task 可以使用 <code>delay()</code> 方法，这是 <code>apply_async()</code> 方法的缩写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; from tasks import add</div><div class="line">&gt;&gt;&gt; add.delay(4, 4)</div></pre></td></tr></table></figure></p>
<h3 id="保存结果"><a href="#保存结果" class="headerlink" title="保存结果"></a>保存结果</h3><p>如果我们要想跟踪 task 的结果或者状态，那么就必须有个地方存储这些信息。redis 提供 <code>backend</code> 配置来设置 task 结果的存储位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app = Celery(&apos;tasks&apos;, broker=&apos;redis://localhost:6379/1&apos;, backend=&apos;redis://localhost:6379/2&apos;)</div></pre></td></tr></table></figure></p>
<p>现在我们重新启动 Celery 后，再次发送一个 task 任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.sleep(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure></p>
<p><code>ready()</code> 用来判断某个 task 任务是否完成。这个方法是立刻返回结果的，当然也可以等待 task 任务的完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>result.get(timeout=<span class="number">1</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure></p>
<p>不过这种方法一般不常用，因为我们都已经做异步任务了，而这种方法是同步的。</p>
<p><code>get()</code> 方法有个参数 <code>propagate</code>，这个参数的意思是：如果这个 task 任务发生了 Exception，那么在 <code>get()</code> 方法中会再一次抛出这个异常，通过设置 <code>propagate=False</code>，可以阻止异常的传递。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>一般情况下，Celery 的默认配置能够满足绝大多数情况，不过 Celery 提供了大量的配置能满足你的其他需求。熟悉这些配置将会让你对之后的工作游刃有余。你可以在<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html#configuration" target="_blank" rel="external">Celery 配置手册</a>中查看其他配置。</p>
<p>这些配置可以直接设置在 <code>celery_app</code> 实例中，也可以设置在一个独立的配置模块中。</p>
<p>举个例子，如果我们要配置 Celery 的默认序列化方式，可以修改 <code>task_serializer</code> 配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app.conf.task_serializer = <span class="string">'json'</span></div></pre></td></tr></table></figure></p>
<p>你也可以通过 <code>update</code> 来一次同时更新多个配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">celery_app.conf.update(</div><div class="line">    task_serializer=<span class="string">'json'</span>,</div><div class="line">    accept_content=[<span class="string">'json'</span>],  <span class="comment"># Ignore other content</span></div><div class="line">    result_serializer=<span class="string">'json'</span>,</div><div class="line">    timezone=<span class="string">'Asia/Shanghai'</span>,</div><div class="line">    enable_utc=<span class="keyword">True</span>,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>对于大点的项目，推荐使用独立的配置模块管理 Celery 配置。然后调用 <code>celery_app.config_from_object()</code> 方法告诉 Celery 实例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery_app.config_from_object(<span class="string">'celeryconfig'</span>)</div></pre></td></tr></table></figure>
<p>上面的代码表示：从一个叫做 <code>celeryconfig.py</code> 的文件中读取配置，该文件可以存放在当前目录也可以是其他 Python 路径。</p>
<p>一个正经的 <code>celeryconfig.py</code> 文件也许长的是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># celeryconfig.py</span></div><div class="line">broker_url = <span class="string">'pyamqp://'</span></div><div class="line">result_backend = <span class="string">'rpc://'</span></div><div class="line"></div><div class="line">task_serializer = <span class="string">'json'</span></div><div class="line">result_serializer = <span class="string">'json'</span></div><div class="line">accept_content = [<span class="string">'json'</span>]</div><div class="line">timezone = <span class="string">'Asia/Shanghai'</span></div><div class="line">enable_utc = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p>为了验证我们写的这个配置文件有没有语法错误可执行下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python -m celeryconfig</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;celery入门到使用&quot;&gt;&lt;a href=&quot;#celery入门到使用&quot; class=&quot;headerlink&quot; title=&quot;celery入门到使用&quot;&gt;&lt;/a&gt;celery入门到使用&lt;/h2&gt;&lt;h3 id=&quot;安装依赖&quot;&gt;&lt;a href=&quot;#安装依赖&quot; class=&quot;headerlink&quot; title=&quot;安装依赖&quot;&gt;&lt;/a&gt;安装依赖&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ pip install celery&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ pip install redis&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;celery应用&quot;&gt;&lt;a href=&quot;#celery应用&quot; class=&quot;headerlink&quot; title=&quot;celery应用&quot;&gt;&lt;/a&gt;celery应用&lt;/h3&gt;&lt;p&gt;使用 celery 的前提是你得有一个 Celery 的实例。我们可以称之为 Celery 应用或者简单地说 app。该实例是用来创建 task 任务、管理 worker 等等，所以必须保证在我们得其他模块中能将它导入过来。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Celery" scheme="https://yuanblq.github.io/tags/Celery/"/>
    
  </entry>
  
  <entry>
    <title>Redis安全说明</title>
    <link href="https://yuanblq.github.io/2018/01/10/Redis%E5%AE%89%E5%85%A8%E8%AF%B4%E6%98%8E/"/>
    <id>https://yuanblq.github.io/2018/01/10/Redis安全说明/</id>
    <published>2018-01-10T06:20:58.000Z</published>
    <updated>2018-01-10T09:27:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis 安全"></a>Redis 安全</h2><h3 id="普通安全模型"><a href="#普通安全模型" class="headerlink" title="普通安全模型"></a>普通安全模型</h3><p>redis 设计的初衷就是用来给在可信环境的可信客户端访问的，也就是说直接把 redis 实例暴露在网络或者不可信的环境中不是一个明智的选择。</p>
<p>比如在一个普通的 web 应用上下文中，使用 redis 作为数据库、缓存、消息系统，位于 web 前端的客户端应用或者甚至是用户都可以通过查询 redis 来获取请求的操作页面。</p>
<p>这种情况下，web 应用暴露在 redis 和不可信的客户端之间（用户通过 web 应用访问）。</p>
<p>这是一个特殊案例，但通常对于连接到 redis 的不可信访问都必须通过一层 ACL 层来验证用户的输入，判断应该做出什么样的操作行为。</p>
<a id="more"></a>
<h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><p>如果你只是在自己电脑上用用 redis，那么就没必要把 redis 的端口暴露在网络中。通过在 <code>redis.conf</code> 文件中的以下命令可以实现只是自己电脑的 redis 客户端通过回环接口访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bind 127.0.0.1</div></pre></td></tr></table></figure></p>
<p>如果防止 redis 端口暴露在外部环境的尝试失败，那么将可能引发不可想象的毁灭。比如一个简单的 <code>FLUSHALL</code> 命令能删光你的所有数据。</p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>从 3.2.0 版本开始，默认情况下，redis 处于“保护模式”状态。该模式下，redis 只回复回环接口的 query 请求。保护请求依然可以被手动取消或者可以开放其他接口。</p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>对于访问操作，redis 并没有做处理，而是加了一层验证层，可以在 <code>redis.conf</code> 配置文件中设置。</p>
<p>设置完密码后可以通过 <code>AUTH &lt;password&gt;</code> 命令发送验证。该密码一般有系统管理员在 <code>redis.conf</code> 文件中配置，而且应尽量的复杂：</p>
<ul>
<li>redis 查询速度很快，所以短时间内攻击者可以尝试很多次</li>
<li>密码以明文的形式配置在 <code>redis.conf</code> 文件中，所以即使很复杂也不必担心忘记</li>
</ul>
<p>但 <code>AUTH</code> 命令和其他 redis 命令一样是不加密处理的。所以还是抵御不了一些有足够权限的攻击者。</p>
<h3 id="数据加密支持"><a href="#数据加密支持" class="headerlink" title="数据加密支持"></a>数据加密支持</h3><p>redis 本身不支持加密处理，但可以添加额外的层来实现，比如增加 SSL 代理，推荐使用 <a href="http://www.tarsnap.com/spiped.html" target="_blank" rel="external">spiped</a></p>
<h3 id="禁用指定命令"><a href="#禁用指定命令" class="headerlink" title="禁用指定命令"></a>禁用指定命令</h3><p>redis 有个 <code>CONFIG</code> 命令，用来操作 redis 的配置。如任何人都能操作这个命令那也是件很危险的事情。还好有两种方法可以解决这个问题：</p>
<ul>
<li>重命名 <code>CONFIG</code> 命令</li>
<li>隐藏 <code>CONFIG</code> 命令</li>
</ul>
<p>这两种方法实际上是同一种操作。redis 提供对命令的重命名操作：在 <code>redis.conf</code> 配置文件中通过添加如下一行即可对一个命令进行重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</div></pre></td></tr></table></figure></p>
<p>通过上面的配置之后 <code>redis-cli</code> 中就再也没有 <code>CONFIG</code> 这个命令了，取而代之的是 <code>b840fc02d524045429941cc15f59e41cb7be6c52</code>。蛤蛤，想不到吧，别人得猜到什么时候才能知道原来 <code>CONFIG</code> 的名字被改成了 <code>b840fc02d524045429941cc15f59e41cb7be6c52</code>。</p>
<p>当然如果你把 <code>CONFIG</code> 直接命名为 <code>&quot;&quot;</code>，那就是把这个命令隐藏了。</p>
<h3 id="字符串转义和-NoSQL-注入"><a href="#字符串转义和-NoSQL-注入" class="headerlink" title="字符串转义和 NoSQL 注入"></a>字符串转义和 NoSQL 注入</h3><p>redis 协议不存在字符串转义这个概念，所以对于一个正常的客户端来说，注入不存在的，都是安全的二进制。</p>
<h3 id="代码安全性"><a href="#代码安全性" class="headerlink" title="代码安全性"></a>代码安全性</h3><p>由于可以通过 <code>CONFIG</code> 命令来改变程序的工作目录或者改变 dump file 的名字。这也意味着客户端可能会随意地在任何地方写人 redis 的 RDB 文件。这个<a href="http://antirez.com/news/96" target="_blank" rel="external">安全问题</a>。</p>
<p>redis 的运行不需要 root 权限。redis 的作者正在调研是否要添加新的配置参数来禁止 <code>CONFIG SET/GET dir</code> 和类似的运行时配置。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis-安全&quot;&gt;&lt;a href=&quot;#Redis-安全&quot; class=&quot;headerlink&quot; title=&quot;Redis 安全&quot;&gt;&lt;/a&gt;Redis 安全&lt;/h2&gt;&lt;h3 id=&quot;普通安全模型&quot;&gt;&lt;a href=&quot;#普通安全模型&quot; class=&quot;headerlink&quot; title=&quot;普通安全模型&quot;&gt;&lt;/a&gt;普通安全模型&lt;/h3&gt;&lt;p&gt;redis 设计的初衷就是用来给在可信环境的可信客户端访问的，也就是说直接把 redis 实例暴露在网络或者不可信的环境中不是一个明智的选择。&lt;/p&gt;
&lt;p&gt;比如在一个普通的 web 应用上下文中，使用 redis 作为数据库、缓存、消息系统，位于 web 前端的客户端应用或者甚至是用户都可以通过查询 redis 来获取请求的操作页面。&lt;/p&gt;
&lt;p&gt;这种情况下，web 应用暴露在 redis 和不可信的客户端之间（用户通过 web 应用访问）。&lt;/p&gt;
&lt;p&gt;这是一个特殊案例，但通常对于连接到 redis 的不可信访问都必须通过一层 ACL 层来验证用户的输入，判断应该做出什么样的操作行为。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Django F对象</title>
    <link href="https://yuanblq.github.io/2018/01/05/Django-F%E5%AF%B9%E8%B1%A1/"/>
    <id>https://yuanblq.github.io/2018/01/05/Django-F对象/</id>
    <published>2018-01-05T06:55:55.000Z</published>
    <updated>2018-01-05T07:04:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="F-表达式"><a href="#F-表达式" class="headerlink" title="F() 表达式"></a>F() 表达式</h2><p>Django 常用的保存 model 对象的方法是 <code>save()</code>，但是这种做法并不是在所有情况下都适用的。</p>
<p>我们得先从数据库获取到对用对象的那条数据，转换成 Python 对象，对 Python 对象进行相应的操作，然后转换成相应数据保存到数据库中。</p>
<p>相当于先从数据库出来，在 Python 转一圈然后再回到数据库。这样难免会出一些问题。</p>
<a id="more"></a>
<p>相较于传统的 <code>save()</code> 操作，<code>F()</code> 对象，有以下几个特性：</p>
<h3 id="直接操作数据库"><a href="#直接操作数据库" class="headerlink" title="直接操作数据库"></a>直接操作数据库</h3><p>F() 对象能直接拿到 model 字段的值，并且不用将它们从数据库拉到 Python 的内存中，而可以直接在数据库层面操作。</p>
<p>实际上，Django 通过 F() 对象直接生成 SQL 表达式在数据库层级操作数据库。</p>
<p>通过下面的例子可以直观的理解这点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed += <span class="number">1</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>我们先从数据库中取出 <code>reporter.stories_field</code> 字段的值，然后经过熟悉的 Python 操作后再把对象存储到数据库中。</p>
<p>但我们同样可以这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</div><div class="line"></div><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>虽然这两种操作乍一看感觉不到什么区别，但是，前面我们说过，通过 F() 对象进行的操作是处于数据库层级的。所以，当我们进行 <code>reporter.stories_filed = F(&#39;stories_filed&#39;) + 1</code> 这一步操作的时候，其实并不像之前『把 model 字段值从数据库取出，经过对 Python 对象的一系列操作，最后把 model 对象保存进数据库。』实际上，使用 F() 对象时，我们是不会管当时的 <code>reporter.stories_filed</code> 这个字段的值的，而是会生成为该字段值加1的对应 SQL 语句。</p>
<p>之后要想获取该字段的新值必须得刷新该对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(pk=reporter.pk)</div><div class="line"><span class="comment"># 或者这种更简洁的做法:</span></div><div class="line">reporter.refresh_from_db()</div></pre></td></tr></table></figure></p>
<p>另外，还可以直接在 <code>filter()</code> 的 <code>update()</code> 中使用 F() 对象，这样就能避免先 get 到 model 对象，然后修改后 save 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Reporters.objects.filter(name=<span class="string">'Tintin'</span>).update(stories_filed=F(<span class="string">'stories_filed'</span>) + <span class="number">1</span>)</div></pre></td></tr></table></figure>
<h3 id="避免竞争情况"><a href="#避免竞争情况" class="headerlink" title="避免竞争情况"></a>避免竞争情况</h3><p>有这样一种情况：如果有两个 Python 线程执行上面那个例子中的代码，一条线程“获取”、“增加”、“保存”，另一条只是从数据库“获取”。“获取值”的那条线程获取的值可能是原始值，而不是第一条线程“增加”后的值。也就是说第一条线程所做的基本是无用功。</p>
<p>正如前面所说的，F() 对象是直接通过 SQL 语句来操作数据库的，所以由 F() 对象操作的话，相当于是在数据库层面，那么此操作更加健壮。当调用 <code>save()</code> 和 <code>update()</code> 时，会基于数据库中的值，而不是获取对象时候对象中的字段值。</p>
<h3 id="F-永远在-Model-save-之后执行"><a href="#F-永远在-Model-save-之后执行" class="headerlink" title="F() 永远在 Model.save() 之后执行"></a>F() 永远在 Model.save() 之后执行</h3><p>F() 会在每个 <code>save()</code>之后执行一遍，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">reporter = Reporters.objects.get(name=<span class="string">'Tintin'</span>)</div><div class="line">reporter.stories_filed = F(<span class="string">'stories_filed'</span>) + <span class="number">1</span></div><div class="line">reporter.save()</div><div class="line"></div><div class="line">reporter.name = <span class="string">'Tintin Jr.'</span></div><div class="line">reporter.save()</div></pre></td></tr></table></figure>
<p>如果 <code>stories_field</code> 的初始值为1，那么最后该值会变为3。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;F-表达式&quot;&gt;&lt;a href=&quot;#F-表达式&quot; class=&quot;headerlink&quot; title=&quot;F() 表达式&quot;&gt;&lt;/a&gt;F() 表达式&lt;/h2&gt;&lt;p&gt;Django 常用的保存 model 对象的方法是 &lt;code&gt;save()&lt;/code&gt;，但是这种做法并不是在所有情况下都适用的。&lt;/p&gt;
&lt;p&gt;我们得先从数据库获取到对用对象的那条数据，转换成 Python 对象，对 Python 对象进行相应的操作，然后转换成相应数据保存到数据库中。&lt;/p&gt;
&lt;p&gt;相当于先从数据库出来，在 Python 转一圈然后再回到数据库。这样难免会出一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="https://yuanblq.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅔</title>
    <link href="https://yuanblq.github.io/2017/08/25/channel-part5/"/>
    <id>https://yuanblq.github.io/2017/08/25/channel-part5/</id>
    <published>2017-08-25T02:22:57.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行带-Channels-的-Django-项目"><a href="#运行带-Channels-的-Django-项目" class="headerlink" title="运行带 Channels 的 Django 项目"></a>运行带 Channels 的 Django 项目</h2><p>当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 <code>channel layer</code>（你之前配置的）连接的一个或多个 <code>interface server</code> 以及 一个或多个 <code>worker server</code> 上运行。</p>
<a id="more"></a>
<p><code>interface server</code> 有多种类型，每一个都服务于不同类型的 request，比如同时能处理 WebSocket 和 HTTP 请求的，或者可能扮演一个 SMS 消息网关的角色。</p>
<p>Django 在不同 <code>worker server</code> 中，运行的逻辑是独立的，所以 <code>channel layer</code> 可以跨网络传输 channels 的内容。在生产环境中，你可能经常会把 <code>worker server</code> 和 <code>interface server</code> 独立开，作为一个独立的集群，但你当然可以把他们放在同一台机器的不同进程中运行。</p>
<p>默认情况下，Django 没有配置 <code>channel layer</code> —— 毕竟没必要用它来运行 WSGI 请求。所以，只要你添加了 consumer，你就需要配置一下。</p>
<p>在上面的例子中，我们使用 in-memory 形式的 <code>channel layer</code> 实现我们的默认 <code>channel layer</code>。它会把所有的 channel 数据以字典的形式存储在内存中，所以实际上不是跨进程的；它只能在 <code>runserver</code> 的进程中运行，也就是说它是在同一个进程中以多个线程的形式在运行。当我们部署到生产环境，你就需要使用 Redis 后端的 <code>channel layer</code>（<code>asgi_redis</code>）来实现跨进程工作。更多细节请看<a href="http://channels.readthedocs.io/en/latest/backends.html" target="_blank" rel="external">Channel Layer Types</a>。</p>
<p>当我们建立好 channel 后端之后，第二件需要我们考虑的事是，确保我们运行的 <code>interface server</code> 能处理 WebSocket。为了解决这个问题，<code>daphne</code> 应运而生，这是一个能同时处理 HTTP 和 WebSocket 的一个 <code>interface server</code>。前面你运行 <code>runserver</code> 的时候就已经和它绑定好了 —— 虽然看上去和 Django 的 <code>runserver</code> 没什么区别，但是有些配置还是不一样的。</p>
<blockquote>
<p>在处理引擎内部，<code>runserver</code> 现在在一个线程中运行着 Daphne，在另外一个线程中自动加载了一个 worker —— 这就是一个微型版本的部署，在一个进程中运行</p>
</blockquote>
<p>现在来试试 Redis 后端 —— Redis 几乎能在每一台机器上运行，而且开销很少，这就使得它很适合做这件事。</p>
<p>通过 <code>pip</code> 安装 <code>asgi_redis</code> 包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install asgi_redis</div></pre></td></tr></table></figure></p>
<p>在你的 channel layer 中做如下配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># setting.py</span></div><div class="line">CHANNEL_LAYERS = [</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgi_redis.RedisChannelLayer"</span>,</div><div class="line">        <span class="string">"CONFIG"</span>: &#123;</div><div class="line">            <span class="string">"hosts"</span>: [(<span class="string">"localhost"</span>, <span class="number">6379</span>)],</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>当然，在这之前你得安装过 Redis server，在 Ubuntu 中安装很方便，你只需：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install redis-server</div></pre></td></tr></table></figure></p>
<p>现在可以把 <code>runserver</code> 解雇了，当然你也可以用一种比较原生的方式实现跨进程，在两个终端中执行以下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver --noworker</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runworker</div></pre></td></tr></table></figure>
<p>你可能已经猜到，在 <code>runserver</code> 中禁止掉 <code>worker</code> 线程，然后在别的进程中开启 <code>worker</code> 来处理它们。如果你想在它运行 consumer 的时候查看日志，你可以给 <code>runwoker</code> 添加 <code>-v 2</code> 参数。</p>
<p>如果 Django 以 debug 模式运行（DEBUG=True），那么 <code>runworker</code> 会处理静态文件，就像以前 <code>runserver</code> 一样。和以前一样，如果你关闭了 <code>DEBUG</code> 模式，那你就需要配置你的静态文件服务。</p>
<h2 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h2><p>echo message 是一个很不错的简单案例，但是它忽略了像这样一个系统的一个实际需求 —— 为每个连接保存状态。</p>
<p>正如我们之前看到的，<code>reply_channel</code> 属性是指向打开 WebSocket 的唯一指针 —— 因为不同的客户端对应的 WebSocket 都是不同的。我们就是根据这个来追踪是谁发的消息。记住，Channels 是网络透明的并且可以在多个 worker 中运行，所以你不能只是以全局变量的形式来存储局部的信息。</p>
<p>解决的办法就是是以 <code>reply_channel</code> 为 key 把数据存储起来 —— 听起来很熟悉？Django 的session 框架就是使用一个 cookie 作为 key 来处理 HTTP 请求的。</p>
<p>如果我们使用 <code>reply_channel</code> 作为 key 来获取 session 会不会没用？</p>
<p>对此，Channels 提供了 <code>channel_session</code> 装饰器来解决这个问题 —— 它为你提供了一个叫 <code>message.channel_seesion</code> 的属性，就好像 Django 中的 session 一样。</p>
<p>现在，我们构建一个聊天服务，你可以在 WebSocket 的请求路径中传入一个聊天室的名字，以及用你用户名作为查询的一个字符串（暂时忽略验证一这块，这是我们接下来考虑的事）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 建立连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 解析 query string</span></div><div class="line">    params = parse_qs(message.content[<span class="string">"query_string"</span>])</div><div class="line">    <span class="keyword">if</span> <span class="string">b"username"</span> <span class="keyword">in</span> params:</div><div class="line">        <span class="comment"># 在 session 中设置 username</span></div><div class="line">        message.channel_session[<span class="string">"username"</span>] = params[<span class="string">b"username"</span>][<span class="number">0</span>].decode(<span class="string">"utf8"</span>)</div><div class="line">        <span class="comment"># 将用户加入到 room_name 组</span></div><div class="line">        Group(<span class="string">"chat-%s"</span> % room_name).add(message.reply_channel)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 关闭 connection</span></div><div class="line">        message.reply_channel.send(&#123;<span class="string">"close"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"text"</span>: message[<span class="string">"text"</span>],</div><div class="line">            <span class="string">"username"</span>: message.channel_session[<span class="string">"username"</span>],</div><div class="line">        &#125;),</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后更新下 <code>routing.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_connect, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_connect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>如果你能在 console 中控制它，或者用简单的 JavaScript 构建了一个聊天客户端，把收到的消息追加到一个 div 中，那你已经可以通过初始请求建立一个聊天室了。</p>
<h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>现在，WebSocket 的解决方案在某些方面可能还没法和你网站的其余部分共存 —— 特别是，我们想确保我们知道我们到底是在和谁聊天，万一我们有些私人聊天通道呢（我们不能通过让客户端自己请求正确的 channel 来解决这问题，因为这样任何人都可以通过输入私人聊天室名字进入其中）。</p>
<p>由于 WebSocket 是基于 HTTP 协议的，他们有很多相似的特征，包括 path、GET 参数以及 cookie。我们可以像使用 Django 的 session 和 验证系统一样来使用它们，毕竟如果我们无法分别他们是谁，或者无法安全地做事的话，那么 WebSocket 就不是个好东西。</p>
<p>另外，我们不想让 <code>interface server</code> 来存储数据或者执行验证，它们应该是简单、快速、可靠、无需过多状态的一个处理，我们需要在我们自己的 consumer 中做我们的验证逻辑。</p>
<p>辛运的是，Channels 对于 WebSocket 和 其他 message 有个底层规范（ASGI），它附带了一些装饰器，能帮你完成验证以及获取底层 Django 的 session。</p>
<p>Channels 可以从 cookies 中获取 Django 的 session （如果在同一域名内使用像 Daphne 这类来运行 WebSocket 服务），或者从 <code>session_key</code> 的 GET 参数中获取 Django 的 session （如果你想继续使用 WSGI 服务器来运行你的 HTTP 请求，并在另一个域名上运行一个服务进程来处理 WebSocket）。</p>
<p>你可以使用 <code>http_session</code> 装饰器来访问一个用户的 Django session —— 这个装饰器会给你提供一个 <code>message.http_session</code> 属性，就像 <code>request.session</code> 一样。你还可以使用 <code>http_seesion_user</code> 装饰器，这个会给你提供一个 <code>message.user</code> 属性，当然和之前 session 的那个属性一样。</p>
<p>现在，需要注意的是，你只能从 WebSocket 连接时的 <code>connect</code> message 中获取到详细的 HTTP 信息（你可能需要了解更多关于 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的规范）。也就意味着我们不会浪费带宽，去发送同样的信息。</p>
<p>这就意味着，我们需要在连接处理中抓取到用户的信息，并把它存在 session 中。幸好，Channels 自带的 <code>channel_session_user</code> 装饰器和上面我们提到的 <code>http_session_user</code> 装饰器差不多，但是它是从 <em>channel</em> 的 session 中加载用户信息，而不是从 <em>http</em> 的session。另外有个叫 <code>transfer_user</code> 的函数，能从一个 session 往另外一个 session 中复制用户信息。甚至有个更好的东西，<code>channel_session_user_from_http</code> 装饰器能把所有的这些集合在了一起。</p>
<p>现在，我们把这些组合起来，让我们的聊天服务器，只能是姓氏一样的用户才能在一个聊天室中聊天：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Channel, Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> channel_session_user, channel_session_user_from_http</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 连接</span></div><div class="line"><span class="meta">@channel_session_user_from_http</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把它们添加到合适的 group</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).send(&#123;</div><div class="line">        <span class="string">"text"</span>: message[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>如果你仅仅使用 <code>runserver</code>（或者 Daphne），你只需 connect，然后你的 cookie 就可以传递你的 auth 信息。如果你在不同的域上运行 WebSocket，那你就得像下边一样，在 URL 上提供 Django 的 sessionID：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:9000/?session_key=abcdefg"</span>);</div></pre></td></tr></table></figure></p>
<p>你可以在模板中使用 <code></code> 来获取当前的 session key。<strong>注意：</strong>对于已签名的 cookie session 没用 —— 因为只用 HTTP 响应才能设置 cookie，它需要一个后端来写入独立的存储你状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行带-Channels-的-Django-项目&quot;&gt;&lt;a href=&quot;#运行带-Channels-的-Django-项目&quot; class=&quot;headerlink&quot; title=&quot;运行带 Channels 的 Django 项目&quot;&gt;&lt;/a&gt;运行带 Channels 的 Django 项目&lt;/h2&gt;&lt;p&gt;当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 &lt;code&gt;channel layer&lt;/code&gt;（你之前配置的）连接的一个或多个 &lt;code&gt;interface server&lt;/code&gt; 以及 一个或多个 &lt;code&gt;worker server&lt;/code&gt; 上运行。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>celery 解决 web 耗时操作</title>
    <link href="https://yuanblq.github.io/2017/08/20/flask-celery/"/>
    <id>https://yuanblq.github.io/2017/08/20/flask-celery/</id>
    <published>2017-08-20T05:13:08.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>开发环境<br>flask 0.12.2、celery 4.1.0、redis 3.2.8</p>
</blockquote>
<p>进入虚拟环境，安装依赖：</p>
<ul>
<li>flask: pip install flask</li>
<li>celery: pip install celery</li>
<li>redis: sudo apt-get install redis-server</li>
<li>redis Python驱动包：pip install redis</li>
</ul>
<a id="more"></a>
<h2 id="配置-flask-主页路由"><a href="#配置-flask-主页路由" class="headerlink" title="配置 flask 主页路由"></a>配置 flask 主页路由</h2><p>创建项目文件夹:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir pro_demo</div></pre></td></tr></table></figure></p>
<p>创建 app 文件夹，以及 app/__init__.py、app/views.py 和 run.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># views.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line">flask_app.debug = <span class="keyword">True</span></div><div class="line">flask_app.run()</div></pre></td></tr></table></figure>
<h2 id="查看网页"><a href="#查看网页" class="headerlink" title="查看网页"></a>查看网页</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python run.py</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div><div class="line"> * Restarting with <span class="built_in">stat</span></div><div class="line"> * Debugger is active!</div><div class="line"> * Debugger PIN: 906-478-811</div></pre></td></tr></table></figure>
<p>在浏览器输入 127.0.0.1:5000，就会看见熟悉的“Hello world!”了。</p>
<h2 id="集成-celery"><a href="#集成-celery" class="headerlink" title="集成 celery"></a>集成 celery</h2><p>在 flask 中 celery 的简单使用很容易，不需要安装第三方插件。</p>
<h3 id="添加-celery-代码"><a href="#添加-celery-代码" class="headerlink" title="添加 celery 代码"></a>添加 celery 代码</h3><p>在 __init__.py 中添加我们的 celery 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line"></div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line">celery_app = Celery(</div><div class="line">	flask_app.name,</div><div class="line">	broker=<span class="string">"redis://localhost:6379/2"</span>,</div><div class="line">	backend=<span class="string">"redis://localhost:6379/3"</span>,</div><div class="line">	)</div><div class="line">celery_app.conf.update(flask_app.config)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure></p>
<p>其中 <code>broker</code> 中间人用 redis 的 2 号数据库，<code>backend</code> 结果存储在 redis 的 3 号数据库，当然你可以按自己需要选择其他数据库，不过 celery 官方推荐使用 RabbitMQ 和 Redis，如果使用其他数据库，官方不保证你会遇到什么 bug。</p>
<h3 id="添加-control-代码"><a href="#添加-control-代码" class="headerlink" title="添加 control 代码"></a>添加 control 代码</h3><p>新建 <code>control.py</code> 文件，并在 <code>control.py</code> 中添加我们的耗时操作任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># control.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> celery_app</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="meta">@celery_app.task</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_work</span><span class="params">(how_long=<span class="number">2</span>)</span>:</span></div><div class="line">	time.sleep(how_long)</div><div class="line">	print(<span class="string">"耗时任务已完成！"</span>)</div></pre></td></tr></table></figure>
<p>这里我们使用 <code>time.sleep()</code> 来模拟耗时任务。</p>
<h3 id="调用耗时任务"><a href="#调用耗时任务" class="headerlink" title="调用耗时任务"></a>调用耗时任务</h3><p>最后在我们的 view 视图中调用我们的耗时任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> control</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">"Hello world!"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/work/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></div><div class="line">	control.long_time_work.delay(<span class="number">5</span>)</div><div class="line">	<span class="keyword">return</span> <span class="string">"long time work!"</span></div></pre></td></tr></table></figure>
<h3 id="启动-celery"><a href="#启动-celery" class="headerlink" title="启动 celery"></a>启动 celery</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ celery -A app worker <span class="_">-l</span> info</div></pre></td></tr></table></figure>
<p>现在我们启动 flask 服务器，在浏览器中输入 <code>127.0.0.1:5000/work/</code>，我们发现页面会马上显示 <code>long time work</code>，不会阻塞 5 秒才返回响应。</p>
<p>5 秒之后，我们会在 celery 的终端看到任务完成打印的消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2017-08-20 12:37:35,528: INFO/MainProcess] Received task: app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1]  </div><div class="line">[2017-08-20 12:37:40,533: WARNING/ForkPoolWorker-4] 耗时任务已完成！</div><div class="line">[2017-08-20 12:37:40,540: INFO/ForkPoolWorker-4] Task app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1] succeeded <span class="keyword">in</span> 5.00878114400075s: None</div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开发环境&lt;br&gt;flask 0.12.2、celery 4.1.0、redis 3.2.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入虚拟环境，安装依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flask: pip install flask&lt;/li&gt;
&lt;li&gt;celery: pip install celery&lt;/li&gt;
&lt;li&gt;redis: sudo apt-get install redis-server&lt;/li&gt;
&lt;li&gt;redis Python驱动包：pip install redis&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="celery" scheme="https://yuanblq.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅓</title>
    <link href="https://yuanblq.github.io/2017/08/12/channel-part4/"/>
    <id>https://yuanblq.github.io/2017/08/12/channel-part4/</id>
    <published>2017-08-12T09:33:28.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始使用-Channels"><a href="#开始使用-Channels" class="headerlink" title="开始使用 Channels"></a>开始使用 Channels</h2><p>（确保你已经<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 Channels&nbsp;">&nbsp;安装了 Channels&nbsp;</a>）</p>
<p>我们先来写几个消费者。如果你还不了解，可以去看看<a href="/2017/08/06/channel-part2/" title="&nbsp;Channels 的概念&nbsp;">&nbsp;Channels 的概念&nbsp;</a>，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。</p>
<h2 id="第一个消费者"><a href="#第一个消费者" class="headerlink" title="第一个消费者"></a>第一个消费者</h2><p>当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ <code>http.request</code> channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 <code>runserver</code> 一样）</p>
<p>作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。</p>
<a id="more"></a>
<p>创建一个新项目，一个新 app，然后把这些代码添加到 app 的 <code>consumer.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="keyword">from</span> channels.handler <span class="keyword">import</span> AsgiHandler</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 生成标准的 HTTP response 响应 - 直接访问 ASGI 的 path 属性</span></div><div class="line">    response = HttpResponse(<span class="string">"Hello world! You asked for %s"</span> % message.content[<span class="string">'path'</span>])</div><div class="line">    <span class="comment"># 将 response 编码成 message 格式（ASGI）</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>我们发送的 message 必须是序列化的 JSON 对象，request 和 response 的 message 是 key-value 的键值对形式。你可以从 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI 规范</a>中查询更多细节，但你无需过多的关注；只需要知道有一个 <code>AsgiRequest</code> 类将 ASGI 转换成 Django 的 request 对象（上面已经用到了）。通常，当你使用普通的 views 视图时， 所有的事 Django 内置的代码都帮你做好了。</p>
<p>现在我们要再做些事，告诉 Django 这个消费者应该和哪个 <code>http.request</code> channel 绑定，而不是和 Django 的 view 视图系统绑定。这个需要在 settings 文件中配置，我们需要定义我们名为 <code>default</code> 的 channel 层以及它的路由。</p>
<p>channel 的路由配置和 URL 的路由配置有点像。channel 和 consumer 之间以字典的形式映射。比如像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># settings.py</span></div><div class="line">CHANNEL_LAYERS = &#123;</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgiref.inmemory.ChannelLayer"</span>,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"http.request"</span>, <span class="string">"myapp.consumers.http_consumer"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>这里大多数例子，使用的是“in memory” channel 层。方便刚开始使用 channel，但是无法实现跨进程的 channel 传输，而且只能用 <code>runserver</code>。在生产环境中，你需要选择其他的 backend 后端（后面将会讨论）。</p>
</blockquote>
<p>如你所见，这有点像 Django 的 <code>DATABASES</code> 配置，有一个名为 <code>default</code> 的 channel 层。每个层都需要一个 channel 层类、一些配置（如果该层需要的话）以及一个路由调度器，用来指向包含路由配置的列表。推荐你起名为 <code>routing.py</code> 并且放在你项目 <code>urls.py</code> 的旁边，但你也可以随便放在哪个地方，只要路径不错。</p>
<p>如果你用 <code>python manage.py runserver</code> 启动，然后在浏览器输入 <code>http://localhost:8000</code>，你会看见，一个 Django 页面，那就说明一切正常。如果你看不到响应，检查一下你是否正确<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 channels&nbsp;">&nbsp;安装了 channels&nbsp;</a>。</p>
<p>现在看起来没啥值得激动的地方，原生 HTTP 响应 Django 早就能做了。我们来试试 WebSocket，再做一个简单的聊天服务器～</p>
<p>我们先只做一个 echo 的简单服务器，将客户端发来的消息直接原样发回。虽然没啥用，不过用来入门 channel 还是不错的。</p>
<p>删除之前的 consumer 和 routing 路由 —— 现在开始，如果你不在 consumer 中特别指定去处理 <code>http.request</code> 那么，Django view 视图来处理 HTTP 请求。然后 consumer 来处理 WebSocket：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># ASGI WebSocket 包 —— 接收和发送消息的类型都有一个 “text” 键名</span></div><div class="line">    <span class="comment"># 对应他们的文本数据</span></div><div class="line">    message.reply_channel.send(&#123;</div><div class="line">        <span class="string">"text"</span>: message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>像下面，将它挂接到 <code>websocket.receive</code> channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_message</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们来看看都做了些什么。它和 <code>websocket.receive</code> channel 绑定，意味着当客户端发送一个 WebSocket 包的时候，它能收到一个 message。</p>
<p>当它收到这个 message 的时候，从中获取 <code>reply_channel</code> 属性，这是每个客户端都唯一的 response channel，然后通过 <code>send()</code> 方法把同样的内容发回给客户端。</p>
<p>运行 <code>runserver</code>，打开浏览器，进入该服务器的页面，在控制台输入以下代码来打开一个 WebSocket 连接，并发送一些数据（如果你使用的是 VM 或者类似的，你可能需要更改 socket 的地址）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该会立刻看见一个 “hello world” 的 alert。你的 message 在服务器绕了一圈又回来触发了 alert。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>现在，我们在一个真正的聊天服务器上实现我们的 echo 服务器，这样人们就可以互相聊天了。为了实现这个功能，我们需要用到 Groups，这是 Channels 的一个<a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">核心概念</a>，也是我们广播消息的基本方法。</p>
<p>为了实现这，我们要增加 <code>websocket.connect</code> 和 <code>websocket.disconnect</code> Channels 来往我们的 Groups 中添加或者移除客户端，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受进来的连接</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把他们加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>如果你重写了 connect，你需要通过 <code>accept: True</code> 来显式地接受 WebSocket 连接，当然，你也可以通过 <code>close: True</code> 来拒绝连接。</p>
</blockquote>
<p>当然，如果你读过<a href="/2017/08/06/channel-part2/" title="&nbsp;channels 概念&nbsp;">&nbsp;channels 概念&nbsp;</a>，你就知道如果添加到 groups 的 Channels 的 message 过期了，那么 Channels 也要过期（每个 Channel 的 message 都有一个过期时间，通常在 30 秒至 1 分钟，当然可以自己配置）。但是无论如何 <code>disconnect</code> 处理器都会调用。</p>
<blockquote>
<p><strong>注意：</strong><br>Channels 设计的前提是会失败的，它假设有一小部分的 message 会永远无法传送，所以所有的核心功能设计的时候都要考虑到当发送一个 message 的时候会无法传送，这样就不会使整个系统崩溃。</p>
<p>我们同样建议你也这么设计你的 app —— 不要期望 Channels 能 100% 可靠的帮你传送消息。查找每一个可能失败的地方，然后用自己用代码去处理 —— 可以是 retry 逻辑、处理部分内容或者不要同时做一些事。HTTP request 也是容易出错的，不然怎么会有人经常收到一个错误的页面！</p>
</blockquote>
<p>现在，我们来关心往 <code>chat</code> group 添加和移除 WebSocket；我们现在要做的就是 message 的发送。不像上面只是重复对话，我们要把它发送到整个 <code>Group</code> 中，也就意味着，所有添加到该 group 的客户端都能获取该消息。下边是所有的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 添加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.receive</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: <span class="string">"[user] %s"</span> % message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后，我们在路由 <code>routing.py</code> 中这么配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_add, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_add),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意，<code>http.request</code> 的路由不在这配置了 —— 如果我们不在这配，Django 将会以默认的 view 视图系统来路由 HTTP 请求，可能这就是你想要的。即使你在这配了 <code>http.request</code> 的路由，但是只匹配一部分的 path 或 method，那么其他不匹配的还是会由默认的处理器处理，也就是说还是会传到 URL 路由和 view 视图。</p>
<p>这些代码已经可以处理 chat 服务器了。现在运行 <code>runserver</code>，打开浏览器，在开发者控制台使用同样的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该能立刻看见一个“hello world” 的 alert，但这次，你可以再打开一个浏览器 tab 页，然后做同样的事，之后两个浏览器窗口都会显示 alert。任何发来的 message 都会由 <code>ws_message</code> 消费者发送到 <code>chat</code> group，然后你的浏览器 tab 页会在 connect 后加入到 <code>chat</code> group。</p>
<p>你可以在你的处理函数中加上一些 <code>print</code>，这样你或许能更理解是怎么调用的。你也可以使用 <code>pdb</code> 像普通的 Django 项目一样进行调试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始使用-Channels&quot;&gt;&lt;a href=&quot;#开始使用-Channels&quot; class=&quot;headerlink&quot; title=&quot;开始使用 Channels&quot;&gt;&lt;/a&gt;开始使用 Channels&lt;/h2&gt;&lt;p&gt;（确保你已经&lt;a href=&quot;/2017/08/07/channel-part3/&quot; title=&quot;&amp;nbsp;安装了 Channels&amp;nbsp;&quot;&gt;&amp;nbsp;安装了 Channels&amp;nbsp;&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;我们先来写几个消费者。如果你还不了解，可以去看看&lt;a href=&quot;/2017/08/06/channel-part2/&quot; title=&quot;&amp;nbsp;Channels 的概念&amp;nbsp;&quot;&gt;&amp;nbsp;Channels 的概念&amp;nbsp;&lt;/a&gt;，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。&lt;/p&gt;
&lt;h2 id=&quot;第一个消费者&quot;&gt;&lt;a href=&quot;#第一个消费者&quot; class=&quot;headerlink&quot; title=&quot;第一个消费者&quot;&gt;&lt;/a&gt;第一个消费者&lt;/h2&gt;&lt;p&gt;当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ &lt;code&gt;http.request&lt;/code&gt; channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 &lt;code&gt;runserver&lt;/code&gt; 一样）&lt;/p&gt;
&lt;p&gt;作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 3</title>
    <link href="https://yuanblq.github.io/2017/08/07/channel-part3/"/>
    <id>https://yuanblq.github.io/2017/08/07/channel-part3/</id>
    <published>2017-08-07T07:59:02.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接在 PyPI 上获取 Channels —— 安装，只需运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -U channels</div></pre></td></tr></table></figure>
<p>安装完之后，你需要把 <code>Channels</code> 添加到你 settings 的 <code>INSTALLED_APPS</code> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = [</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.sites'</span>,</div><div class="line">    ...</div><div class="line">    <span class="string">'channels'</span>,</div><div class="line">]</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>就这样！完成之后，<code>Channels</code> 会自己集成到 Django，并且接管 <code>runserver</code> 命令。详情见 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a>。</p>
<blockquote>
<p><strong>注意</strong><br>注意其他会替换/重载 <code>runserver</code> 命令的第三方 app。Channels 提供了一个独立的 <code>runserver</code> 命令，可能会引起冲突。有这么一个冲突的例子：<a href="https://github.com/evansd/whitenoise" target="_blank" rel="external">whitenoise</a> 的 <a href="https://github.com/evansd/whitenoise/issues/77" target="_blank" rel="external">whitenoise.runserver_nostatic</a>。为了解决这个问题，可以尝试把 <code>channels</code> 移到你 <code>INSTALLED——APPS</code> 的最上面，或者把其他冲突的 app 删了。</p>
</blockquote>
<h2 id="安装最新的开发版"><a href="#安装最新的开发版" class="headerlink" title="安装最新的开发版"></a>安装最新的开发版</h2><p>要想安装最新的开发版 Channels，克隆它的仓库，切换到仓库，更改仓库文件夹，然后安装到你的虚拟环境中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git@github.com:django/channels.git</div><div class="line">$ <span class="built_in">cd</span> channels</div><div class="line">$ &lt;activate your project’s virtual environment&gt;</div><div class="line">(environment) $ pip install <span class="_">-e</span> .  <span class="comment"># . 表示当前仓库</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;可以直接在 PyPI 上获取 Channels —— 安装，只需运行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install -U channels&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完之后，你需要把 &lt;code&gt;Channels&lt;/code&gt; 添加到你 settings 的 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 中：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;INSTALLED_APPS = [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.auth&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.contenttypes&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sessions&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sites&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;channels&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 2</title>
    <link href="https://yuanblq.github.io/2017/08/06/channel-part2/"/>
    <id>https://yuanblq.github.io/2017/08/06/channel-part2/</id>
    <published>2017-08-06T13:28:37.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channels-概念"><a href="#Channels-概念" class="headerlink" title="Channels 概念"></a>Channels 概念</h2><p>Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。</p>
<p>在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。</p>
<p>除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。</p>
<p>它将 Django 的运行模式从简单的 <code>response to request</code>请求响应，改变为 <code>event oriented</code>面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。</p>
<p>我们先来看看什么是 channels 吧。</p>
<a id="more"></a>
<h2 id="什么是-channel？"><a href="#什么是-channel？" class="headerlink" title="什么是 channel？"></a>什么是 channel？</h2><p>该系统的核心就是一个叫做 channel 的数据结构。什么是 channel？这是一个有序的、先进先出的、有时效的以及一次只能传递给一个监听器的队列。</p>
<p>你可以认为它就是个任务队列 —— 生产者将消息存入 channel，然后给监听该 channel 的一个消费者监听器。</p>
<p>“最多一次”假设，要么一个消费者获得该消息，要么就没人获得消息（假设 channel 实现崩溃了）。“至少一次”假设，通常一个消费者获得消息，但当崩溃的时候，不止一个消费者收到消息，这不是我们想要的。</p>
<p>还有其他一些限制 —— 消息必须是序列化类型，并在指定大小以内。不过在你使用高级用法之前，这些实现细节都不需要你担心。</p>
<p>channels 有一定的容量，所有生产者可以先往一个 channel 中写入大量信息，消费者可以之后再去消费这些队列消息。</p>
<p>如果你在 <a href="https://gobyexample.com/channels" target="_blank" rel="external">Go 语言中使用过 channels</a>：Go channels 和 Django 的差不多。主要的不同点是，Django 的 channels 是网络透明的，我们提供的 channel，消费者和不同进程或者不同服务器的生产者都可以通过网络访问。</p>
<p>在一个网络中，我们根据 channel 的唯一字符串名字来区分 channels —— 你可以把消息发送到，连接在同一 channel 后端的，来自任何服务器的任一已命名的 channel 上。如果两台不同的服务器都往 <code>http.request</code> channel 上写，那么他们写的就是同一个 channel。</p>
<h2 id="如何使用-channels？"><a href="#如何使用-channels？" class="headerlink" title="如何使用 channels？"></a>如何使用 channels？</h2><p>所以，Django 到底该如何使用 channels 呢？在 Django 中，你可以写一个函数来消费一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>然后在 channel routing 路由中给它指定一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">channel_routing = &#123;</div><div class="line">    <span class="string">"some-channel"</span>: <span class="string">"myapp.consumer.my_consumer"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说 channel 中的每一个 message，Django 都会通过消息对象来调用消费者函数（message 对象有 <code>content</code> 属性，是一个字典，还有一个 <code>channel</code> 属性，就是该消息所在的 channel）。</p>
<p>与传统的 request—response 模式不同，channels 将 Django 改为 worker 模式运行 —— 它监听消费者指定的所有 channels，当有消息来时，就运行相应的消费者函数。所以，不单单在绑定的 WSGI 服务器上运行单个进程，Django 运行了三个不同的层：</p>
<ul>
<li>interface servers，Django 和外部网络通信的层。包括一个 WSGI 适配器和一个独立的 WebSocket 服务器，具体细节看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#run-interface-servers" target="_blank" rel="external">Run interface servers</a>。</li>
<li>channel backend，是可插拔的 Python 代码和数据存储库（比如 Redis 或者共享的内存段）负责传输 messages。</li>
<li>workers，监听所有相关的 channels，当 message 准备好的时候，运行对应的消费者函数。</li>
</ul>
<p>这看起来可能比较简单，但这是设计的一部分。我们只是引入一个轻量的比 Django 视图更复杂、抽象的函数，而不是采用一个完整的异步框架。</p>
<p>一个 view 视图接受 request 参数，然后返回一个 response 响应；一个 consumer 消费者接受 channel message 参数，并可以向其他通道写消息。</p>
<p>现在，我们做一个通道来接受 request 请求（叫做 <code>http.request</code>），做一个给每个客户端 response 响应的通道（比如 <code>http.response.o4F2h2Fd</code>），response 响应通道是 request 消息的一个属性（<code>reply_channel</code>）。这样的话，一个 view 视图差不多就是一个 consumer 例子了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 message 中将 request 解码成一个 Request 对象</span></div><div class="line">    django_request = AsgiRequest(message)</div><div class="line">    <span class="comment"># 运行 view</span></div><div class="line">    django_response = view(django_request)</div><div class="line">    <span class="comment"># 将 response 转成 message 格式</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(django_response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p>实际上，这就是 channel 所干的活。interface 服务器将来自外部的连接（HTTP、WebSocket 等等）转换成 channel 中的 message，然后你写 worker 代码去处理这些消息。通常普通的 HTTP 由 Django view/template 内置的 consumer 处理，但你也可以重写添加功能。</p>
<p>然而，关键部分是你可以对任何事件做出响应。你可以触发模型保存、其他输入的 message 或者来自 view 和 form 的代码。解决推送形式的代码 —— 用 WebSocket 或者 HTTP 长轮询通知客户端以实时的方式改变。</p>
<h2 id="Channel-类型"><a href="#Channel-类型" class="headerlink" title="Channel 类型"></a>Channel 类型</h2><p>在这个模型中只要有两种使用方法。第一个也是最主要的一个，给消费者分发任务 —— 添加到 channel 中的消息，任何一个 worker 都能从中取出来给消费者。</p>
<p>第二种类型的 channel 是用来回复的。值得注意的是，这些只监听一个东西 —— interface server。每个回复通道都是独立命名的，当它的客户端结束时会路由回 interface server。</p>
<p>他们之间的差异不是很大 —— 他们都要遵守 channel 的核心定义。但是当扩展规模时就会有一些差异。很高兴，在服务器和工作群集中能随机负载均衡 —— 毕竟任一 worker 都可以处理 message —— 但是 response channel 要把 message 发送到他们监听的 channel 服务器中。</p>
<p>所以，channel 会分这两种类型，然后在名字中带有 <code>!</code> 的表示回复通道 —— 比如 <code>http.response!f5G3fE21f</code>。普通的 channel 没有这个字符，但是只能包含字母数字下划线，并且不能超过 200 个字符。</p>
<p>只是实现后端的话不需要懂 —— 毕竟只有在扩展的时候才会用到。更多关于扩展以及在写后端或 interface server 的时候如何处理 channel 类型的信息，请看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#scaling-up" target="_blank" rel="external">Scaling Up</a>。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>因为 channels 只接通一个接听器，他们不能进行广播。如果你想在一组客户端中随意发送消息，你需要去跟踪这些回复通道。</p>
<p>如果我有一个实时博客，当我保存了一个新的博客，然后我想推送时，我可以给 <code>post_save</code> 信号注册一个处理器，然后给一系列 channel （本处使用 Redis）发送更新消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">redis_conn = redis.Redis(<span class="string">"localhost"</span>, <span class="number">6379</span>)</div><div class="line"></div><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 循环所有的回复通道，然后发送更新消息</span></div><div class="line">    <span class="keyword">for</span> reply_channel <span class="keyword">in</span> redis_conn.smembers(<span class="string">"readers"</span>):</div><div class="line">        Channel(reply_channel).send(&#123;</div><div class="line">            <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">                <span class="string">"id"</span>: instance.id,</div><div class="line">                <span class="string">"content"</span>: instance.content</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到读者集合</span></div><div class="line">    redis_conn.sadd(<span class="string">"readers"</span>, message.reply_channel.name)</div></pre></td></tr></table></figure>
<p>尽管这能工作，但是有一个小问题 —— 当他们断开连接时，我们从没有把人从 <code>readers</code> 集合中删除。我们可以添加一个消费者去监听 <code>websocket.disconnect</code> 来完成这事，但是我们也需要设置过期时间，避免在发出 disconnect 信号前 interface server 突然退出或者断电。</p>
<p>因为 channel 的基本设计是无状态的，如果一个 interface server 消失，channel 服务器没有“关闭”一个通道这概念 —— 毕竟，通道只是用来传输消息的。</p>
<p>我们没必要关心客户端断开连接后有没有把消息发送给群组 —— 毕竟它都已经断开了。我们关心的是这些不存在的客户端是否会扰乱我们的 channel 后端（可能最终回复通道的名字会起冲突，并把消息发送给不是我们想要的客户端，尽管发生这个情况至少得到几周后）。</p>
<p>现在，我们可以回到上面的例子，并且增加过期集合以及跟踪过期时间，但是这个做的一个框架是什么样的？Channel 以一个叫做 Group 的核心概念来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"id"</span>: instance.id,</div><div class="line">            <span class="string">"content"</span>: instance.content</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到 reader group</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).add(message.reply_channel)</div><div class="line">    <span class="comment"># 接受 connection request 请求</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 reader group 移除</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>Group 不止拥有自己的 <code>send()</code> 方法，他还能自动管理 group 成员的过期事务 —— 当channel 由于非消费开始有过期消息时，我们将它从 group 中移除。当然你仍可以在 disconnect 的时候将它从 group 中移除；过期的代码只是为了防止由于某些原因 disconnect 消息不起作用。</p>
<p>Group 通常只对回复通道有用（包含 <code>!</code> 字符的那个），因为它们对于每个客户端都是唯一的，但如果你愿意的话也可以用于普通 channel。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>这只是高层视角下对 channel 和 group 的概览，以及你在一开始该如何考虑使用。记住，Django 虽然提供了一些通道，但你可以自定义自己的 consumer 和 channel。</p>
<p>有件事时 channel 无法做到的，就是保证传输。如果你需要确保任务完成，使用一个系统，在失败的时候重新尝试（比如 celery）或者用一个管理命令来检查是否完成，如果没有完成就重新提交消息（你自己的重试逻辑）。</p>
<p>在接下来的文档中，我们将覆盖更多关于 channel 的一些任务，但现在，我们继续 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a> 然后写一些代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Channels-概念&quot;&gt;&lt;a href=&quot;#Channels-概念&quot; class=&quot;headerlink&quot; title=&quot;Channels 概念&quot;&gt;&lt;/a&gt;Channels 概念&lt;/h2&gt;&lt;p&gt;Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。&lt;/p&gt;
&lt;p&gt;在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。&lt;/p&gt;
&lt;p&gt;除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。&lt;/p&gt;
&lt;p&gt;它将 Django 的运行模式从简单的 &lt;code&gt;response to request&lt;/code&gt;请求响应，改变为 &lt;code&gt;event oriented&lt;/code&gt;面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。&lt;/p&gt;
&lt;p&gt;我们先来看看什么是 channels 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 1</title>
    <link href="https://yuanblq.github.io/2017/08/04/channel-part1/"/>
    <id>https://yuanblq.github.io/2017/08/04/channel-part1/</id>
    <published>2017-08-04T11:22:14.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Channels？"><a href="#什么是-Channels？" class="headerlink" title="什么是 Channels？"></a>什么是 Channels？</h2><p>通过 Channels，给 Django 添加了一个新的<a href="http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels" target="_blank" rel="external">传输中间层</a>，通过该层，能实现两个重要的特性：</p>
<ul>
<li><a href="http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example" target="_blank" rel="external">像普通 view 视图一样</a>，处理 WebSocket</li>
<li>作为 Django 的一部分，在同样的服务器中，能运行后台任务</li>
</ul>
<p>当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。</p>
<a id="more"></a>
<h2 id="如何使用呢？"><a href="#如何使用呢？" class="headerlink" title="如何使用呢？"></a>如何使用呢？</h2><p>他将 Django 的处理过程分成了两类：</p>
<ul>
<li>一是处理 HTTP 和 WebSocket</li>
<li>另一个是运行 view 视图函数、websocket 处理器和后台任务（consumers 消费者）</li>
</ul>
<p>他们通过一个叫 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的协议通信。它和 WSGI 很相似，不过 ASGI 能兼容更多协议类型。</p>
<p>Channels 不会往你的 Django 代码中引入 asyncio、gevent 或者其他任何异步代码。你的所有业务逻辑都是以同步的方式运行在工作进程/线程。</p>
<h2 id="我要改变-Django-的运行方式吗？"><a href="#我要改变-Django-的运行方式吗？" class="headerlink" title="我要改变 Django 的运行方式吗？"></a>我要改变 Django 的运行方式吗？</h2><p><strong>不</strong>，所有的额外工作都完全是可选的。如果你愿意，你可以将运行在 WSGI 服务器下的 Django 更改为如下运行方式：</p>
<ul>
<li>一个 ASGI 服务器，你可能会选择 <a href="http://github.com/django/daphne/" target="_blank" rel="external">Daphne</a></li>
<li>Django 的工作服务器，通过 <code>manage.py runworker</code> 来使用</li>
<li>用来路由 ASGI 请求的东西，比如 Redis</li>
</ul>
<p>当你使用 Channels 时，如果默认把所有的 HTTP 请求都路由给 Django view 视图系统，那它就和之前几乎没有任何差异。</p>
<h2 id="Channels-还能给我什么惊喜？"><a href="#Channels-还能给我什么惊喜？" class="headerlink" title="Channels 还能给我什么惊喜？"></a>Channels 还能给我什么惊喜？</h2><p>还包括如下特性：</p>
<ul>
<li>同一时刻，支持上千个简单的 HTTP 长轮询</li>
<li>对于 websocket，提供完整的 session 和 auth 支持</li>
<li>对于 websocket，基于站点 cookie 自动完成用户登录</li>
<li>对于大量的触发事件，拥有内置 primitive 支持（聊天、实时博客…）</li>
<li>工作服务不停，浏览器暂停的零停机部署</li>
<li>基于 per-URL 的可选低级 HTTP 控制</li>
<li>可以扩展到其他协议或事件源（比如：WebRTC、原生 UDP、SMS）</li>
</ul>
<h2 id="能扩展吗？"><a href="#能扩展吗？" class="headerlink" title="能扩展吗？"></a>能扩展吗？</h2><p><strong>当然可以，</strong>你可以运行任意数量的协议服务（用于同时处理 HTTP 和 WebSocket）和工作服务（用来运行你的 Django 代码）来满足你的使用案例。</p>
<p>ASGI 规范这两个部件之间插入允许大量的不同功能特性的 channel 层。而且它被设计用来支持简单分片以及使用自己的协议和服务器运行单独的集群。</p>
<h2 id="为什么不采用我最喜欢的消息队列？"><a href="#为什么不采用我最喜欢的消息队列？" class="headerlink" title="为什么不采用我最喜欢的消息队列？"></a>为什么不采用我最喜欢的消息队列？</h2><p>Channel 的设计目的优先于低延迟（目标是几毫秒），并且超过保证传送的高吞吐量，这与某些消息队列设计不匹配。</p>
<p>一些像<a href="http://channels.readthedocs.io/en/latest/getting-started.html#enforcing-ordering" target="_blank" rel="external">保证消息顺序</a>的特性会降低性能，但它能使它更像个消息队列。</p>
<h2 id="我需要把我所有的代码都变成异步吗？"><a href="#我需要把我所有的代码都变成异步吗？" class="headerlink" title="我需要把我所有的代码都变成异步吗？"></a>我需要把我所有的代码都变成异步吗？</h2><p>不，如果没有任何 socket 或 事件循环阻塞，你的代码都可以同步运行。你也可以在一些 Django 的 view 视图或 channel 的 consumer 消费者函数中使用异步代码 —— 比如，并行获取大量 URL，但这不会影响整个站点的部署。</p>
<h2 id="Channel-支持哪些-Django-版本？"><a href="#Channel-支持哪些-Django-版本？" class="headerlink" title="Channel 支持哪些 Django 版本？"></a>Channel 支持哪些 Django 版本？</h2><p>你可以在 Django &gt;= 1.8 的版本上将 Channels 最为一个库来安装。另外，它可能需要一些额外的依赖，不过你都可以通过 <code>pip</code> 安装。</p>
<p>一开始的时候，Channels 并不在 Django 的核心功能中，不过自从 2016.9 月以后，它就成为了 Django 的官方项目。更多关于 Channels 被采纳为 官方项目的信息可以从 <a href="https://www.djangoproject.com/weblog/2016/sep/09/channels-adopted-official-django-project/" target="_blank" rel="external">Django blog</a> 中查询。</p>
<h2 id="接下来我该读什么？"><a href="#接下来我该读什么？" class="headerlink" title="接下来我该读什么？"></a>接下来我该读什么？</h2><p>首先阅读关于 <a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">Channel 的一些概念</a>，然后继续阅读我们的<a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">示例教程</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Channels？&quot;&gt;&lt;a href=&quot;#什么是-Channels？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Channels？&quot;&gt;&lt;/a&gt;什么是 Channels？&lt;/h2&gt;&lt;p&gt;通过 Channels，给 Django 添加了一个新的&lt;a href=&quot;http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels&quot;&gt;传输中间层&lt;/a&gt;，通过该层，能实现两个重要的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example&quot;&gt;像普通 view 视图一样&lt;/a&gt;，处理 WebSocket&lt;/li&gt;
&lt;li&gt;作为 Django 的一部分，在同样的服务器中，能运行后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part4</title>
    <link href="https://yuanblq.github.io/2017/07/31/asyncio4/"/>
    <id>https://yuanblq.github.io/2017/07/31/asyncio4/</id>
    <published>2017-07-31T07:08:14.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同线程的事件循环"><a href="#不同线程的事件循环" class="headerlink" title="不同线程的事件循环"></a>不同线程的事件循环</h2><p>通过前面的介绍，我们现在能在单线程中实现多协程的工作。</p>
<p>这节就说说怎么在多线程中管理协程。</p>
<p>对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work start --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(now() - start))</div></pre></td></tr></table></figure>
<pre><code>TIME: 0.0023021697998046875
More work start --&gt; 6
Finished more work 6
More work start --&gt; 3
Finished more work 3
</code></pre><p>可见，当前线程不会阻塞。新的线程会按顺序执行 <code>call_soon_threadsafe()</code> 方法中注册的函数，因为注册的方法不是协程，所以新开的线程大概会执行 6+3 s。</p>
<p>那么，多线程实现协程的过程大致也是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line">    </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    print(<span class="string">'&#123;&#125; Done after &#123;&#125;s'</span>.format(x, x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">6</span>), new_loop)</div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">3</span>), new_loop)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>TIME:  0.0006730556488037109
More work --&gt; 6
More work --&gt; 3
3 Done after 3s
6 Done after 6s
</code></pre><p>由于我们在子线程开启的是协程任务，所以子线程大概耗时 6s。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不同线程的事件循环&quot;&gt;&lt;a href=&quot;#不同线程的事件循环&quot; class=&quot;headerlink&quot; title=&quot;不同线程的事件循环&quot;&gt;&lt;/a&gt;不同线程的事件循环&lt;/h2&gt;&lt;p&gt;通过前面的介绍，我们现在能在单线程中实现多协程的工作。&lt;/p&gt;
&lt;p&gt;这节就说说怎么在多线程中管理协程。&lt;/p&gt;
&lt;p&gt;对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part3</title>
    <link href="https://yuanblq.github.io/2017/07/30/asyncio3/"/>
    <id>https://yuanblq.github.io/2017/07/30/asyncio3/</id>
    <published>2017-07-30T03:27:31.000Z</published>
    <updated>2017-09-20T15:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="停止协程"><a href="#停止协程" class="headerlink" title="停止协程"></a>停止协程</h2><p><code>Future</code> 对象有几种状态：</p>
<ul>
<li>pending</li>
<li>running</li>
<li>done</li>
<li>cancelled</li>
</ul>
<p><code>Future</code> 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<h3 id="逐个停止"><a href="#逐个停止" class="headerlink" title="逐个停止"></a>逐个停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</div><div class="line">        print(task.cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;wait() running at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:355&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
True
True
True
TIME:  1.8798322677612305
</code></pre><p><code>True</code> 表示取消成功。</p>
<p>上述方法是逐个 <code>cancel</code>。也可以像之前提到的，把所有的 task 封装在一个函数中，这样，该函数就相当于是最外面的一个 task，那么可以对该函数处理：</p>
<h3 id="打包停止"><a href="#打包停止" class="headerlink" title="打包停止"></a>打包停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</div><div class="line">        print(<span class="string">'Task result: '</span>, task.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line">task = asyncio.ensure_future(main())</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(task)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    print(asyncio.gather(*asyncio.Task.all_tasks()).cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line">    </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;main() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:17&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
TIME:  0.649970531463623
</code></pre><p>到目前为止，我们已经能够简单地开启多个协程，管理多个协程，可是，如果一个协程耗时过长，那么整个线程依旧会阻塞，这时我们只有开启多线程或者多进程来实现并行操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;停止协程&quot;&gt;&lt;a href=&quot;#停止协程&quot; class=&quot;headerlink&quot; title=&quot;停止协程&quot;&gt;&lt;/a&gt;停止协程&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象有几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pending&lt;/li&gt;
&lt;li&gt;running&lt;/li&gt;
&lt;li&gt;done&lt;/li&gt;
&lt;li&gt;cancelled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part2</title>
    <link href="https://yuanblq.github.io/2017/07/29/asyncio2/"/>
    <id>https://yuanblq.github.io/2017/07/29/asyncio2/</id>
    <published>2017-07-29T01:14:37.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h2><p>要想使用 <code>asyncio</code> 实现异步，和 <code>gevent</code> 差不多，都需要相应的代码支持。<code>gevent</code> 是通过打上“猴子补丁”来实现的，而 <code>asyncio</code> 和 <code>yield from</code> 有着千丝万缕的关系，所以先实现就比较简单了。</p>
<p>你可以自己用 <code>yield from</code> 写个协程方法，要么就只能用用别人实现的协程模块。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment"># 完成一个任务打印一个</span></div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    task.add_done_callback(done_callback)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 将协程 task 任务列表添加到事件循环中</span></div><div class="line"><span class="comment"># 这两种方法都能实现添加事件循环</span></div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="comment"># loop.run_until_complete(asyncio.gather(*tasks))</span></div><div class="line"></div><div class="line"><span class="comment"># 最后一个任务完成的时候一起打印</span></div><div class="line"><span class="comment"># for task in tasks:</span></div><div class="line"><span class="comment">#     print("Task result: ", task.result())</span></div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Callback:  work 2 Done after 2s
Callback:  work 3 Done after 3s
Callback:  work 4 Done after 4s
TIME:  4.004777193069458
</code></pre><p>总计花了 4s 多点的时间，如果是同步的话，至少 9s。可见，我们通过 <code>asyncio</code> 实现了并发功能。</p>
<h2 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h2><p>在协程的嵌套中，如何处理协程返回的数据是件很灵活的事。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="comment"># dones, pendings = await asyncio.wait(tasks)</span></div><div class="line">    <span class="comment"># print(dones)</span></div><div class="line">    <span class="comment"># print(pendings)</span></div><div class="line">    <span class="comment"># for task in dones:</span></div><div class="line">    <span class="comment">#     print('Task result: ', task.result())</span></div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.0052490234375
</code></pre><p>在 <code>main()</code> 协程函数中，可以不直接处理结果，直接返回 <code>await</code> 内容，那么，<code>run_until_complete()</code> 将会接受返回的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">dones, pendings = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> done <span class="keyword">in</span> dones:</div><div class="line">    print(<span class="string">"Task result: "</span>, done.result())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 4 Done after 4s
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
TIME:  4.0036780834198
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(<span class="string">"Task result: "</span>, result)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.003807544708252
</code></pre><p>除此之外，还可以使用 asyncio 的 <code>as_completed()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</div><div class="line">        result = <span class="keyword">await</span> task</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.002615690231323
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步实现&quot;&gt;&lt;a href=&quot;#异步实现&quot; class=&quot;headerlink&quot; title=&quot;异步实现&quot;&gt;&lt;/a&gt;异步实现&lt;/h2&gt;&lt;p&gt;要想使用 &lt;code&gt;asyncio&lt;/code&gt; 实现异步，和 &lt;code&gt;gevent&lt;/code&gt; 差不多，都需要相应的代码支持。&lt;code&gt;gevent&lt;/code&gt; 是通过打上“猴子补丁”来实现的，而 &lt;code&gt;asyncio&lt;/code&gt; 和 &lt;code&gt;yield from&lt;/code&gt; 有着千丝万缕的关系，所以先实现就比较简单了。&lt;/p&gt;
&lt;p&gt;你可以自己用 &lt;code&gt;yield from&lt;/code&gt; 写个协程方法，要么就只能用用别人实现的协程模块。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part1</title>
    <link href="https://yuanblq.github.io/2017/07/28/asyncio1/"/>
    <id>https://yuanblq.github.io/2017/07/28/asyncio1/</id>
    <published>2017-07-28T04:59:48.000Z</published>
    <updated>2017-09-20T15:36:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个协程"><a href="#创建一个协程" class="headerlink" title="创建一个协程"></a>创建一个协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"></div><div class="line"><span class="comment"># 定义协程函数</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">获取协程对象，协程对象的调用不会立刻执行函数</div><div class="line">协程对象需要注册到事件循环上，由事件循环调用</div><div class="line">"""</div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取事件循环对象</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 调用协程对象</span></div><div class="line">loop.run_until_complete(coroutine)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
TIME:  0.0010256767272949219
</code></pre><h2 id="创建一个-task"><a href="#创建一个-task" class="headerlink" title="创建一个 task"></a>创建一个 task</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">3</span>)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">ensure_future() 返回的也是 Furure 对象，</div><div class="line">内部同样是调用的 create_task()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">"""</div><div class="line">task = loop.create_task(coroutine)</div><div class="line"></div><div class="line">print(task)</div><div class="line">loop.run_until_complete(task)</div><div class="line">print(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt;&gt;
Waiting:  3
&lt;Task finished coro=&lt;do_some_work() done, defined at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt; result=None&gt;
TIME:  0.0009589195251464844
</code></pre><p>所谓 task 对象本质上是一个 <code>Future</code> 对象（是 <code>Future</code> 的子类）。<code>Future</code> 类保存了协程运行后的状态，用于未来获取协程的结果。</p>
<p>task 在加入事件循环之前是 pending 状态。执行完成之后为 finished 状态。</p>
<p><code>asyncio.ensure_future(coroutine)</code> 和 <code>loop.create_task(coroutine)</code> 都可以创建一个 task，<code>asyncio.ensure_future(coroutine)</code> 内部就是通过调用 <code>loop.create_task(coroutine)</code> 返回的 task 对象。</p>
<h2 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h2><p>我们修改一下 <code>do_some_work()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line">task.add_done_callback(done_callback)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  Done after 2s
TIME:  0.0015606880187988281
</code></pre><p><code>Future</code> 对象的 <code>add_done_callback()</code> 方法接受一个回调函数对象，并且会把自己也传过去。等 task 调用结束时，就可以通过 task 对象的 <code>result()</code> 方法获取调用返回值。</p>
<p>如果有这么一种需求，当回调的时候，我们还需要往回调函数传入多个参数。这种情况可以通过偏函数解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback_part</span><span class="params">(op, future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, op, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line">task.add_done_callback(functools.partial(done_callback_part, <span class="string">"other param"</span>))</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  other param Done after 2s
TIME:  0.00046443939208984375
</code></pre><h2 id="阻塞和-await"><a href="#阻塞和-await" class="headerlink" title="阻塞和 await"></a>阻塞和 await</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">"Task result: "</span>, task.result())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Task result:  Done after 2s
TIME:  2.0026657581329346
</code></pre><p>当 sleep 的时候，使用 <code>await</code> 让出控制权。即当程序执行到耗时操作时，使用 <code>await</code> 方法将协程的控制权让出，以便 <code>loop</code> 调用其他协程。</p>
<p>上面的例子都只有一个协程，所以看不出有什么效果。接下来我们就上多个协程瞧瞧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个协程&quot;&gt;&lt;a href=&quot;#创建一个协程&quot; class=&quot;headerlink&quot; title=&quot;创建一个协程&quot;&gt;&lt;/a&gt;创建一个协程&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; asyncio&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;now = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt;: time.time()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义协程函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_some_work&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Waiting: &#39;&lt;/span&gt;, x)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
</feed>
