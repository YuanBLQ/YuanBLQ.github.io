<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yuan</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuanblq.github.io/"/>
  <updated>2017-09-07T02:27:53.006Z</updated>
  <id>https://yuanblq.github.io/</id>
  
  <author>
    <name>Yuan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅔</title>
    <link href="https://yuanblq.github.io/2017/08/25/channel-part5/"/>
    <id>https://yuanblq.github.io/2017/08/25/channel-part5/</id>
    <published>2017-08-25T02:22:57.000Z</published>
    <updated>2017-09-07T02:27:53.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运行带-Channels-的-Django-项目"><a href="#运行带-Channels-的-Django-项目" class="headerlink" title="运行带 Channels 的 Django 项目"></a>运行带 Channels 的 Django 项目</h2><p>当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 <code>channel layer</code>（你之前配置的）连接的一个或多个 <code>interface server</code> 以及 一个或多个 <code>worker server</code> 上运行。</p>
<a id="more"></a>
<p><code>interface server</code> 有多种类型，每一个都服务于不同类型的 request，比如同时能处理 WebSocket 和 HTTP 请求的，或者可能扮演一个 SMS 消息网关的角色。</p>
<p>Django 在不同 <code>worker server</code> 中，运行的逻辑是独立的，所以 <code>channel layer</code> 可以跨网络传输 channels 的内容。在生产环境中，你可能经常会把 <code>worker server</code> 和 <code>interface server</code> 独立开，作为一个独立的集群，但你当然可以把他们放在同一台机器的不同进程中运行。</p>
<p>默认情况下，Django 没有配置 <code>channel layer</code> —— 毕竟没必要用它来运行 WSGI 请求。所以，只要你添加了 consumer，你就需要配置一下。</p>
<p>在上面的例子中，我们使用 in-memory 形式的 <code>channel layer</code> 实现我们的默认 <code>channel layer</code>。它会把所有的 channel 数据以字典的形式存储在内存中，所以实际上不是跨进程的；它只能在 <code>runserver</code> 的进程中运行，也就是说它是在同一个进程中以多个线程的形式在运行。当我们部署到生产环境，你就需要使用 Redis 后端的 <code>channel layer</code>（<code>asgi_redis</code>）来实现跨进程工作。更多细节请看<a href="http://channels.readthedocs.io/en/latest/backends.html" target="_blank" rel="external">Channel Layer Types</a>。</p>
<p>当我们建立好 channel 后端之后，第二件需要我们考虑的事是，确保我们运行的 <code>interface server</code> 能处理 WebSocket。为了解决这个问题，<code>daphne</code> 应运而生，这是一个能同时处理 HTTP 和 WebSocket 的一个 <code>interface server</code>。前面你运行 <code>runserver</code> 的时候就已经和它绑定好了 —— 虽然看上去和 Django 的 <code>runserver</code> 没什么区别，但是有些配置还是不一样的。</p>
<blockquote>
<p>在处理引擎内部，<code>runserver</code> 现在在一个线程中运行着 Daphne，在另外一个线程中自动加载了一个 worker —— 这就是一个微型版本的部署，在一个进程中运行</p>
</blockquote>
<p>现在来试试 Redis 后端 —— Redis 几乎能在每一台机器上运行，而且开销很少，这就使得它很适合做这件事。</p>
<p>通过 <code>pip</code> 安装 <code>asgi_redis</code> 包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install asgi_redis</div></pre></td></tr></table></figure></p>
<p>在你的 channel layer 中做如下配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># setting.py</span></div><div class="line">CHANNEL_LAYERS = [</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgi_redis.RedisChannelLayer"</span>,</div><div class="line">        <span class="string">"CONFIG"</span>: &#123;</div><div class="line">            <span class="string">"hosts"</span>: [(<span class="string">"localhost"</span>, <span class="number">6379</span>)],</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure>
<p>当然，在这之前你得安装过 Redis server，在 Ubuntu 中安装很方便，你只需：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install redis-server</div></pre></td></tr></table></figure></p>
<p>现在可以把 <code>runserver</code> 解雇了，当然你也可以用一种比较原生的方式实现跨进程，在两个终端中执行以下两条命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runserver --noworker</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python manage.py runworker</div></pre></td></tr></table></figure>
<p>你可能已经猜到，在 <code>runserver</code> 中禁止掉 <code>worker</code> 线程，然后在别的进程中开启 <code>worker</code> 来处理它们。如果你想在它运行 consumer 的时候查看日志，你可以给 <code>runwoker</code> 添加 <code>-v 2</code> 参数。</p>
<p>如果 Django 以 debug 模式运行（DEBUG=True），那么 <code>runworker</code> 会处理静态文件，就像以前 <code>runserver</code> 一样。和以前一样，如果你关闭了 <code>DEBUG</code> 模式，那你就需要配置你的静态文件服务。</p>
<h2 id="持久化数据"><a href="#持久化数据" class="headerlink" title="持久化数据"></a>持久化数据</h2><p>echo message 是一个很不错的简单案例，但是它忽略了像这样一个系统的一个实际需求 —— 为每个连接保存状态。</p>
<p>正如我们之前看到的，<code>reply_channel</code> 属性是指向打开 WebSocket 的唯一指针 —— 因为不同的客户端对应的 WebSocket 都是不同的。我们就是根据这个来追踪是谁发的消息。记住，Channels 是网络透明的并且可以在多个 worker 中运行，所以你不能只是以全局变量的形式来存储局部的信息。</p>
<p>解决的办法就是是以 <code>reply_channel</code> 为 key 把数据存储起来 —— 听起来很熟悉？Django 的session 框架就是使用一个 cookie 作为 key 来处理 HTTP 请求的。</p>
<p>如果我们使用 <code>reply_channel</code> 作为 key 来获取 session 会不会没用？</p>
<p>对此，Channels 提供了 <code>channel_session</code> 装饰器来解决这个问题 —— 它为你提供了一个叫 <code>message.channel_seesion</code> 的属性，就好像 Django 中的 session 一样。</p>
<p>现在，我们构建一个聊天服务，你可以在 WebSocket 的请求路径中传入一个聊天室的名字，以及用你用户名作为查询的一个字符串（暂时忽略验证一这块，这是我们接下来考虑的事）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 建立连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 解析 query string</span></div><div class="line">    params = parse_qs(message.content[<span class="string">"query_string"</span>])</div><div class="line">    <span class="keyword">if</span> <span class="string">b"username"</span> <span class="keyword">in</span> params:</div><div class="line">        <span class="comment"># 在 session 中设置 username</span></div><div class="line">        message.channel_session[<span class="string">"username"</span>] = params[<span class="string">b"username"</span>][<span class="number">0</span>].decode(<span class="string">"utf8"</span>)</div><div class="line">        <span class="comment"># 将用户加入到 room_name 组</span></div><div class="line">        Group(<span class="string">"chat-%s"</span> % room_name).add(message.reply_channel)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># 关闭 connection</span></div><div class="line">        message.reply_channel.send(&#123;<span class="string">"close"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"text"</span>: message[<span class="string">"text"</span>],</div><div class="line">            <span class="string">"username"</span>: message.channel_session[<span class="string">"username"</span>],</div><div class="line">        &#125;),</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message, room_name)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % room_name).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后更新下 <code>routing.py</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_connect, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_connect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect, path=<span class="string">r"^/(?P&lt;room_name&gt;[a-zA-Z0-9_]+)/$"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>如果你能在 console 中控制它，或者用简单的 JavaScript 构建了一个聊天客户端，把收到的消息追加到一个 div 中，那你已经可以通过初始请求建立一个聊天室了。</p>
<h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>现在，WebSocket 的解决方案在某些方面可能还没法和你网站的其余部分共存 —— 特别是，我们想确保我们知道我们到底是在和谁聊天，万一我们有些私人聊天通道呢（我们不能通过让客户端自己请求正确的 channel 来解决这问题，因为这样任何人都可以通过输入私人聊天室名字进入其中）。</p>
<p>由于 WebSocket 是基于 HTTP 协议的，他们有很多相似的特征，包括 path、GET 参数以及 cookie。我们可以像使用 Django 的 session 和 验证系统一样来使用它们，毕竟如果我们无法分别他们是谁，或者无法安全地做事的话，那么 WebSocket 就不是个好东西。</p>
<p>另外，我们不想让 <code>interface server</code> 来存储数据或者执行验证，它们应该是简单、快速、可靠、无需过多状态的一个处理，我们需要在我们自己的 consumer 中做我们的验证逻辑。</p>
<p>辛运的是，Channels 对于 WebSocket 和 其他 message 有个底层规范（ASGI），它附带了一些装饰器，能帮你完成验证以及获取底层 Django 的 session。</p>
<p>Channels 可以从 cookies 中获取 Django 的 session （如果在同一域名内使用像 Daphne 这类来运行 WebSocket 服务），或者从 <code>session_key</code> 的 GET 参数中获取 Django 的 session （如果你想继续使用 WSGI 服务器来运行你的 HTTP 请求，并在另一个域名上运行一个服务进程来处理 WebSocket）。</p>
<p>你可以使用 <code>http_session</code> 装饰器来访问一个用户的 Django session —— 这个装饰器会给你提供一个 <code>message.http_session</code> 属性，就像 <code>request.session</code> 一样。你还可以使用 <code>http_seesion_user</code> 装饰器，这个会给你提供一个 <code>message.user</code> 属性，当然和之前 session 的那个属性一样。</p>
<p>现在，需要注意的是，你只能从 WebSocket 连接时的 <code>connect</code> message 中获取到详细的 HTTP 信息（你可能需要了解更多关于 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的规范）。也就意味着我们不会浪费带宽，去发送同样的信息。</p>
<p>这就意味着，我们需要在连接处理中抓取到用户的信息，并把它存在 session 中。幸好，Channels 自带的 <code>channel_session_user</code> 装饰器和上面我们提到的 <code>http_session_user</code> 装饰器差不多，但是它是从 <em>channel</em> 的 session 中加载用户信息，而不是从 <em>http</em> 的session。另外有个叫 <code>transfer_user</code> 的函数，能从一个 session 往另外一个 session 中复制用户信息。甚至有个更好的东西，<code>channel_session_user_from_http</code> 装饰器能把所有的这些集合在了一起。</p>
<p>现在，我们把这些组合起来，让我们的聊天服务器，只能是姓氏一样的用户才能在一个聊天室中聊天：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Channel, Group</div><div class="line"><span class="keyword">from</span> channels.sessions <span class="keyword">import</span> channel_session</div><div class="line"><span class="keyword">from</span> channels.auth <span class="keyword">import</span> channel_session_user, channel_session_user_from_http</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.connect 连接</span></div><div class="line"><span class="meta">@channel_session_user_from_http</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把它们添加到合适的 group</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.receive 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).send(&#123;</div><div class="line">        <span class="string">"text"</span>: message[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 与 websocket.disconnect 连接</span></div><div class="line"><span class="meta">@channel_session_user</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat-%s"</span> % message.user.username[<span class="number">0</span>]).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>如果你仅仅使用 <code>runserver</code>（或者 Daphne），你只需 connect，然后你的 cookie 就可以传递你的 auth 信息。如果你在不同的域上运行 WebSocket，那你就得像下边一样，在 URL 上提供 Django 的 sessionID：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://127.0.0.1:9000/?session_key=abcdefg"</span>);</div></pre></td></tr></table></figure></p>
<p>你可以在模板中使用 <code></code> 来获取当前的 session key。<strong>注意：</strong>对于已签名的 cookie session 没用 —— 因为只用 HTTP 响应才能设置 cookie，它需要一个后端来写入独立的存储你状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运行带-Channels-的-Django-项目&quot;&gt;&lt;a href=&quot;#运行带-Channels-的-Django-项目&quot; class=&quot;headerlink&quot; title=&quot;运行带 Channels 的 Django 项目&quot;&gt;&lt;/a&gt;运行带 Channels 的 Django 项目&lt;/h2&gt;&lt;p&gt;当然，Channels 使 Django 引进了多进程的模型，你不再使用 WSGI 服务器以进程的形式来运行所有的东西（当然，如果你不想使用 Channels 的话，也是可以这么做的）。现在，你会在通过 &lt;code&gt;channel layer&lt;/code&gt;（你之前配置的）连接的一个或多个 &lt;code&gt;interface server&lt;/code&gt; 以及 一个或多个 &lt;code&gt;worker server&lt;/code&gt; 上运行。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>celery 解决 web 耗时操作</title>
    <link href="https://yuanblq.github.io/2017/08/20/flask-celery/"/>
    <id>https://yuanblq.github.io/2017/08/20/flask-celery/</id>
    <published>2017-08-20T05:13:08.000Z</published>
    <updated>2017-09-04T05:46:27.631Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>开发环境<br>flask 0.12.2、celery 4.1.0、redis 3.2.8</p>
</blockquote>
<p>进入虚拟环境，安装依赖：</p>
<ul>
<li>flask: pip install flask</li>
<li>celery: pip install celery</li>
<li>redis: sudo apt-get install redis-server</li>
<li>redis Python驱动包：pip install redis</li>
</ul>
<a id="more"></a>
<h2 id="配置-flask-主页路由"><a href="#配置-flask-主页路由" class="headerlink" title="配置 flask 主页路由"></a>配置 flask 主页路由</h2><p>创建项目文件夹:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mkdir pro_demo</div></pre></td></tr></table></figure></p>
<p>创建 app 文件夹，以及 app/__init__.py、app/views.py 和 run.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># views.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line"><span class="meta">@app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"Hello world!"</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># run.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"></div><div class="line">flask_app.debug = <span class="keyword">True</span></div><div class="line">flask_app.run()</div></pre></td></tr></table></figure>
<h2 id="查看网页"><a href="#查看网页" class="headerlink" title="查看网页"></a>查看网页</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python run.py</div><div class="line"> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</div><div class="line"> * Restarting with <span class="built_in">stat</span></div><div class="line"> * Debugger is active!</div><div class="line"> * Debugger PIN: 906-478-811</div></pre></td></tr></table></figure>
<p>在浏览器输入 127.0.0.1:5000，就会看见熟悉的“Hello world!”了。</p>
<h2 id="集成-celery"><a href="#集成-celery" class="headerlink" title="集成 celery"></a>集成 celery</h2><p>在 flask 中 celery 的简单使用很容易，不需要安装第三方插件。</p>
<h3 id="添加-celery-代码"><a href="#添加-celery-代码" class="headerlink" title="添加 celery 代码"></a>添加 celery 代码</h3><p>在 __init__.py 中添加我们的 celery 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># __init__.py</span></div><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div><div class="line"></div><div class="line"></div><div class="line">flask_app = Flask(__name__)</div><div class="line">celery_app = Celery(</div><div class="line">	flask_app.name,</div><div class="line">	broker=<span class="string">"redis://localhost:6379/2"</span>,</div><div class="line">	backend=<span class="string">"redis://localhost:6379/3"</span>,</div><div class="line">	)</div><div class="line">celery_app.conf.update(flask_app.config)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> views</div></pre></td></tr></table></figure></p>
<p>其中 <code>broker</code> 中间人用 redis 的 2 号数据库，<code>backend</code> 结果存储在 redis 的 3 号数据库，当然你可以按自己需要选择其他数据库，不过 celery 官方推荐使用 RabbitMQ 和 Redis，如果使用其他数据库，官方不保证你会遇到什么 bug。</p>
<h3 id="添加-control-代码"><a href="#添加-control-代码" class="headerlink" title="添加 control 代码"></a>添加 control 代码</h3><p>新建 <code>control.py</code> 文件，并在 <code>control.py</code> 中添加我们的耗时操作任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># control.py</span></div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> celery_app</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="meta">@celery_app.task</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_work</span><span class="params">(how_long=<span class="number">2</span>)</span>:</span></div><div class="line">	time.sleep(how_long)</div><div class="line">	print(<span class="string">"耗时任务已完成！"</span>)</div></pre></td></tr></table></figure>
<p>这里我们使用 <code>time.sleep()</code> 来模拟耗时任务。</p>
<h3 id="调用耗时任务"><a href="#调用耗时任务" class="headerlink" title="调用耗时任务"></a>调用耗时任务</h3><p>最后在我们的 view 视图中调用我们的耗时任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> flask_app</div><div class="line"><span class="keyword">from</span> app <span class="keyword">import</span> control</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></div><div class="line">	<span class="keyword">return</span> <span class="string">"Hello world!"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@flask_app.route("/work/")</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">()</span>:</span></div><div class="line">	control.long_time_work.delay(<span class="number">5</span>)</div><div class="line">	<span class="keyword">return</span> <span class="string">"long time work!"</span></div></pre></td></tr></table></figure>
<h3 id="启动-celery"><a href="#启动-celery" class="headerlink" title="启动 celery"></a>启动 celery</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ celery -A app worker <span class="_">-l</span> info</div></pre></td></tr></table></figure>
<p>现在我们启动 flask 服务器，在浏览器中输入 <code>127.0.0.1:5000/work/</code>，我们发现页面会马上显示 <code>long time work</code>，不会阻塞 5 秒才返回响应。</p>
<p>5 秒之后，我们会在 celery 的终端看到任务完成打印的消息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[2017-08-20 12:37:35,528: INFO/MainProcess] Received task: app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1]  </div><div class="line">[2017-08-20 12:37:40,533: WARNING/ForkPoolWorker-4] 耗时任务已完成！</div><div class="line">[2017-08-20 12:37:40,540: INFO/ForkPoolWorker-4] Task app.control.long_time_work[062766ef-5e20-4453-8d53-3d1290eaacc1] succeeded <span class="keyword">in</span> 5.00878114400075s: None</div></pre></td></tr></table></figure></p>
<p>以上</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开发环境&lt;br&gt;flask 0.12.2、celery 4.1.0、redis 3.2.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入虚拟环境，安装依赖：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flask: pip install flask&lt;/li&gt;
&lt;li&gt;celery: pip install celery&lt;/li&gt;
&lt;li&gt;redis: sudo apt-get install redis-server&lt;/li&gt;
&lt;li&gt;redis Python驱动包：pip install redis&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="celery" scheme="https://yuanblq.github.io/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 4⅓</title>
    <link href="https://yuanblq.github.io/2017/08/12/channel-part4/"/>
    <id>https://yuanblq.github.io/2017/08/12/channel-part4/</id>
    <published>2017-08-12T09:33:28.000Z</published>
    <updated>2017-09-07T02:24:11.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始使用-Channels"><a href="#开始使用-Channels" class="headerlink" title="开始使用 Channels"></a>开始使用 Channels</h2><p>（确保你已经<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 Channels&nbsp;">&nbsp;安装了 Channels&nbsp;</a>）</p>
<p>我们先来写几个消费者。如果你还不了解，可以去看看<a href="/2017/08/06/channel-part2/" title="&nbsp;Channels 的概念&nbsp;">&nbsp;Channels 的概念&nbsp;</a>，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。</p>
<h2 id="第一个消费者"><a href="#第一个消费者" class="headerlink" title="第一个消费者"></a>第一个消费者</h2><p>当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ <code>http.request</code> channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 <code>runserver</code> 一样）</p>
<p>作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。</p>
<a id="more"></a>
<p>创建一个新项目，一个新 app，然后把这些代码添加到 app 的 <code>consumer.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"><span class="keyword">from</span> channels.handler <span class="keyword">import</span> AsgiHandler</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 生成标准的 HTTP response 响应 - 直接访问 ASGI 的 path 属性</span></div><div class="line">    response = HttpResponse(<span class="string">"Hello world! You asked for %s"</span> % message.content[<span class="string">'path'</span>])</div><div class="line">    <span class="comment"># 将 response 编码成 message 格式（ASGI）</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p><strong>注意：</strong>我们发送的 message 必须是序列化的 JSON 对象，request 和 response 的 message 是 key-value 的键值对形式。你可以从 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI 规范</a>中查询更多细节，但你无需过多的关注；只需要知道有一个 <code>AsgiRequest</code> 类将 ASGI 转换成 Django 的 request 对象（上面已经用到了）。通常，当你使用普通的 views 视图时， 所有的事 Django 内置的代码都帮你做好了。</p>
<p>现在我们要再做些事，告诉 Django 这个消费者应该和哪个 <code>http.request</code> channel 绑定，而不是和 Django 的 view 视图系统绑定。这个需要在 settings 文件中配置，我们需要定义我们名为 <code>default</code> 的 channel 层以及它的路由。</p>
<p>channel 的路由配置和 URL 的路由配置有点像。channel 和 consumer 之间以字典的形式映射。比如像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># settings.py</span></div><div class="line">CHANNEL_LAYERS = &#123;</div><div class="line">    <span class="string">"default"</span>: &#123;</div><div class="line">        <span class="string">"BACKEND"</span>: <span class="string">"asgiref.inmemory.ChannelLayer"</span>,</div><div class="line">        <span class="string">"ROUTING"</span>: <span class="string">"myproject.routing.channel_routing"</span>,</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"http.request"</span>, <span class="string">"myapp.consumers.http_consumer"</span>),</div><div class="line">]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>这里大多数例子，使用的是“in memory” channel 层。方便刚开始使用 channel，但是无法实现跨进程的 channel 传输，而且只能用 <code>runserver</code>。在生产环境中，你需要选择其他的 backend 后端（后面将会讨论）。</p>
</blockquote>
<p>如你所见，这有点像 Django 的 <code>DATABASES</code> 配置，有一个名为 <code>default</code> 的 channel 层。每个层都需要一个 channel 层类、一些配置（如果该层需要的话）以及一个路由调度器，用来指向包含路由配置的列表。推荐你起名为 <code>routing.py</code> 并且放在你项目 <code>urls.py</code> 的旁边，但你也可以随便放在哪个地方，只要路径不错。</p>
<p>如果你用 <code>python manage.py runserver</code> 启动，然后在浏览器输入 <code>http://localhost:8000</code>，你会看见，一个 Django 页面，那就说明一切正常。如果你看不到响应，检查一下你是否正确<a href="/2017/08/07/channel-part3/" title="&nbsp;安装了 channels&nbsp;">&nbsp;安装了 channels&nbsp;</a>。</p>
<p>现在看起来没啥值得激动的地方，原生 HTTP 响应 Django 早就能做了。我们来试试 WebSocket，再做一个简单的聊天服务器～</p>
<p>我们先只做一个 echo 的简单服务器，将客户端发来的消息直接原样发回。虽然没啥用，不过用来入门 channel 还是不错的。</p>
<p>删除之前的 consumer 和 routing 路由 —— 现在开始，如果你不在 consumer 中特别指定去处理 <code>http.request</code> 那么，Django view 视图来处理 HTTP 请求。然后 consumer 来处理 WebSocket：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># ASGI WebSocket 包 —— 接收和发送消息的类型都有一个 “text” 键名</span></div><div class="line">    <span class="comment"># 对应他们的文本数据</span></div><div class="line">    message.reply_channel.send(&#123;</div><div class="line">        <span class="string">"text"</span>: message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>像下面，将它挂接到 <code>websocket.receive</code> channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># routing.py</span></div><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_message</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>我们来看看都做了些什么。它和 <code>websocket.receive</code> channel 绑定，意味着当客户端发送一个 WebSocket 包的时候，它能收到一个 message。</p>
<p>当它收到这个 message 的时候，从中获取 <code>reply_channel</code> 属性，这是每个客户端都唯一的 response channel，然后通过 <code>send()</code> 方法把同样的内容发回给客户端。</p>
<p>运行 <code>runserver</code>，打开浏览器，进入该服务器的页面，在控制台输入以下代码来打开一个 WebSocket 连接，并发送一些数据（如果你使用的是 VM 或者类似的，你可能需要更改 socket 的地址）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该会立刻看见一个 “hello world” 的 alert。你的 message 在服务器绕了一圈又回来触发了 alert。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>现在，我们在一个真正的聊天服务器上实现我们的 echo 服务器，这样人们就可以互相聊天了。为了实现这个功能，我们需要用到 Groups，这是 Channels 的一个<a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">核心概念</a>，也是我们广播消息的基本方法。</p>
<p>为了实现这，我们要增加 <code>websocket.connect</code> 和 <code>websocket.disconnect</code> Channels 来往我们的 Groups 中添加或者移除客户端，就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受进来的连接</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 把他们加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>如果你重写了 connect，你需要通过 <code>accept: True</code> 来显式地接受 WebSocket 连接，当然，你也可以通过 <code>close: True</code> 来拒绝连接。</p>
</blockquote>
<p>当然，如果你读过<a href="/2017/08/06/channel-part2/" title="&nbsp;channels 概念&nbsp;">&nbsp;channels 概念&nbsp;</a>，你就知道如果添加到 groups 的 Channels 的 message 过期了，那么 Channels 也要过期（每个 Channel 的 message 都有一个过期时间，通常在 30 秒至 1 分钟，当然可以自己配置）。但是无论如何 <code>disconnect</code> 处理器都会调用。</p>
<blockquote>
<p><strong>注意：</strong><br>Channels 设计的前提是会失败的，它假设有一小部分的 message 会永远无法传送，所以所有的核心功能设计的时候都要考虑到当发送一个 message 的时候会无法传送，这样就不会使整个系统崩溃。</p>
<p>我们同样建议你也这么设计你的 app —— 不要期望 Channels 能 100% 可靠的帮你传送消息。查找每一个可能失败的地方，然后用自己用代码去处理 —— 可以是 retry 逻辑、处理部分内容或者不要同时做一些事。HTTP request 也是容易出错的，不然怎么会有人经常收到一个错误的页面！</p>
</blockquote>
<p>现在，我们来关心往 <code>chat</code> group 添加和移除 WebSocket；我们现在要做的就是 message 的发送。不像上面只是重复对话，我们要把它发送到整个 <code>Group</code> 中，也就意味着，所有添加到该 group 的客户端都能获取该消息。下边是所有的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># consumers.py</span></div><div class="line"><span class="keyword">from</span> channels <span class="keyword">import</span> Group</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_add</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 接受 connection</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line">    <span class="comment"># 添加到 chat group</span></div><div class="line">    Group(<span class="string">"chat"</span>).add(message.reply_channel)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.receive</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_message</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: <span class="string">"[user] %s"</span> % message.content[<span class="string">'text'</span>],</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    Group(<span class="string">"chat"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>然后，我们在路由 <code>routing.py</code> 中这么配置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> channels.routing <span class="keyword">import</span> route</div><div class="line"><span class="keyword">from</span> myapp.consumers <span class="keyword">import</span> ws_add, ws_message, ws_disconnect</div><div class="line"></div><div class="line">channel_routing = [</div><div class="line">    route(<span class="string">"websocket.connect"</span>, ws_add),</div><div class="line">    route(<span class="string">"websocket.receive"</span>, ws_message),</div><div class="line">    route(<span class="string">"websocket.disconnect"</span>, ws_disconnect),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意，<code>http.request</code> 的路由不在这配置了 —— 如果我们不在这配，Django 将会以默认的 view 视图系统来路由 HTTP 请求，可能这就是你想要的。即使你在这配了 <code>http.request</code> 的路由，但是只匹配一部分的 path 或 method，那么其他不匹配的还是会由默认的处理器处理，也就是说还是会传到 URL 路由和 view 视图。</p>
<p>这些代码已经可以处理 chat 服务器了。现在运行 <code>runserver</code>，打开浏览器，在开发者控制台使用同样的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// path 和路由没关系; WebSocket连接都是和 consumer 绑定的</span></div><div class="line">socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://"</span> + <span class="built_in">window</span>.location.host + <span class="string">"/chat/"</span>);</div><div class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    alert(e.data);</div><div class="line">&#125;</div><div class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    socket.send(<span class="string">"hello world"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果 socket 打开了，就直接调用 onopen 回调</span></div><div class="line"><span class="keyword">if</span> (socket.readyState == WebSocket.OPEN) socket.onopen();</div></pre></td></tr></table></figure>
<p>你应该能立刻看见一个“hello world” 的 alert，但这次，你可以再打开一个浏览器 tab 页，然后做同样的事，之后两个浏览器窗口都会显示 alert。任何发来的 message 都会由 <code>ws_message</code> 消费者发送到 <code>chat</code> group，然后你的浏览器 tab 页会在 connect 后加入到 <code>chat</code> group。</p>
<p>你可以在你的处理函数中加上一些 <code>print</code>，这样你或许能更理解是怎么调用的。你也可以使用 <code>pdb</code> 像普通的 Django 项目一样进行调试。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开始使用-Channels&quot;&gt;&lt;a href=&quot;#开始使用-Channels&quot; class=&quot;headerlink&quot; title=&quot;开始使用 Channels&quot;&gt;&lt;/a&gt;开始使用 Channels&lt;/h2&gt;&lt;p&gt;（确保你已经&lt;a href=&quot;/2017/08/07/channel-part3/&quot; title=&quot;&amp;nbsp;安装了 Channels&amp;nbsp;&quot;&gt;&amp;nbsp;安装了 Channels&amp;nbsp;&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;我们先来写几个消费者。如果你还不了解，可以去看看&lt;a href=&quot;/2017/08/06/channel-part2/&quot; title=&quot;&amp;nbsp;Channels 的概念&amp;nbsp;&quot;&gt;&amp;nbsp;Channels 的概念&amp;nbsp;&lt;/a&gt;，里面介绍了 channels 和 groups 的基本概念以及阐述了一些重要的实现模式和注意事项。&lt;/p&gt;
&lt;h2 id=&quot;第一个消费者&quot;&gt;&lt;a href=&quot;#第一个消费者&quot; class=&quot;headerlink&quot; title=&quot;第一个消费者&quot;&gt;&lt;/a&gt;第一个消费者&lt;/h2&gt;&lt;p&gt;当你安装完 Channels 第一次运行 Django 的时候，它会以默认的布局配置 —— 所有的 HTTP 请求（ &lt;code&gt;http.request&lt;/code&gt; channel 中的）都会路由到 Django 的 view 层 —— 和以前基于 Django、views 和静态文件服务的 WSGI 工作方式一样。（就像正常的 &lt;code&gt;runserver&lt;/code&gt; 一样）&lt;/p&gt;
&lt;p&gt;作为一个基本介绍，我们写一个覆盖内置处理器的 consumer 来直接处理所有的 HTTP 请求。通常你在一个项目中不会这么做，但是能了解 channels 如何在 DJango 核心下工作 —— 直接在现存的 view 层下添加了一整个新的层。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 3</title>
    <link href="https://yuanblq.github.io/2017/08/07/channel-part3/"/>
    <id>https://yuanblq.github.io/2017/08/07/channel-part3/</id>
    <published>2017-08-07T07:59:02.000Z</published>
    <updated>2017-09-03T15:09:53.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以直接在 PyPI 上获取 Channels —— 安装，只需运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -U channels</div></pre></td></tr></table></figure>
<p>安装完之后，你需要把 <code>Channels</code> 添加到你 settings 的 <code>INSTALLED_APPS</code> 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = [</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.sites'</span>,</div><div class="line">    ...</div><div class="line">    <span class="string">'channels'</span>,</div><div class="line">]</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>就这样！完成之后，<code>Channels</code> 会自己集成到 Django，并且接管 <code>runserver</code> 命令。详情见 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a>。</p>
<blockquote>
<p><strong>注意</strong><br>注意其他会替换/重载 <code>runserver</code> 命令的第三方 app。Channels 提供了一个独立的 <code>runserver</code> 命令，可能会引起冲突。有这么一个冲突的例子：<a href="https://github.com/evansd/whitenoise" target="_blank" rel="external">whitenoise</a> 的 <a href="https://github.com/evansd/whitenoise/issues/77" target="_blank" rel="external">whitenoise.runserver_nostatic</a>。为了解决这个问题，可以尝试把 <code>channels</code> 移到你 <code>INSTALLED——APPS</code> 的最上面，或者把其他冲突的 app 删了。</p>
</blockquote>
<h2 id="安装最新的开发版"><a href="#安装最新的开发版" class="headerlink" title="安装最新的开发版"></a>安装最新的开发版</h2><p>要想安装最新的开发版 Channels，克隆它的仓库，切换到仓库，更改仓库文件夹，然后安装到你的虚拟环境中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git@github.com:django/channels.git</div><div class="line">$ <span class="built_in">cd</span> channels</div><div class="line">$ &lt;activate your project’s virtual environment&gt;</div><div class="line">(environment) $ pip install <span class="_">-e</span> .  <span class="comment"># . 表示当前仓库</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;可以直接在 PyPI 上获取 Channels —— 安装，只需运行：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;pip install -U channels&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完之后，你需要把 &lt;code&gt;Channels&lt;/code&gt; 添加到你 settings 的 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 中：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;INSTALLED_APPS = [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.auth&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.contenttypes&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sessions&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;django.contrib.sites&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;channels&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 2</title>
    <link href="https://yuanblq.github.io/2017/08/06/channel-part2/"/>
    <id>https://yuanblq.github.io/2017/08/06/channel-part2/</id>
    <published>2017-08-06T13:28:37.000Z</published>
    <updated>2017-09-03T15:09:59.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Channels-概念"><a href="#Channels-概念" class="headerlink" title="Channels 概念"></a>Channels 概念</h2><p>Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。</p>
<p>在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。</p>
<p>除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。</p>
<p>它将 Django 的运行模式从简单的 <code>response to request</code>请求响应，改变为 <code>event oriented</code>面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。</p>
<p>我们先来看看什么是 channels 吧。</p>
<a id="more"></a>
<h2 id="什么是-channel？"><a href="#什么是-channel？" class="headerlink" title="什么是 channel？"></a>什么是 channel？</h2><p>该系统的核心就是一个叫做 channel 的数据结构。什么是 channel？这是一个有序的、先进先出的、有时效的以及一次只能传递给一个监听器的队列。</p>
<p>你可以认为它就是个任务队列 —— 生产者将消息存入 channel，然后给监听该 channel 的一个消费者监听器。</p>
<p>“最多一次”假设，要么一个消费者获得该消息，要么就没人获得消息（假设 channel 实现崩溃了）。“至少一次”假设，通常一个消费者获得消息，但当崩溃的时候，不止一个消费者收到消息，这不是我们想要的。</p>
<p>还有其他一些限制 —— 消息必须是序列化类型，并在指定大小以内。不过在你使用高级用法之前，这些实现细节都不需要你担心。</p>
<p>channels 有一定的容量，所有生产者可以先往一个 channel 中写入大量信息，消费者可以之后再去消费这些队列消息。</p>
<p>如果你在 <a href="https://gobyexample.com/channels" target="_blank" rel="external">Go 语言中使用过 channels</a>：Go channels 和 Django 的差不多。主要的不同点是，Django 的 channels 是网络透明的，我们提供的 channel，消费者和不同进程或者不同服务器的生产者都可以通过网络访问。</p>
<p>在一个网络中，我们根据 channel 的唯一字符串名字来区分 channels —— 你可以把消息发送到，连接在同一 channel 后端的，来自任何服务器的任一已命名的 channel 上。如果两台不同的服务器都往 <code>http.request</code> channel 上写，那么他们写的就是同一个 channel。</p>
<h2 id="如何使用-channels？"><a href="#如何使用-channels？" class="headerlink" title="如何使用 channels？"></a>如何使用 channels？</h2><p>所以，Django 到底该如何使用 channels 呢？在 Django 中，你可以写一个函数来消费一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>然后在 channel routing 路由中给它指定一个 channel：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">channel_routing = &#123;</div><div class="line">    <span class="string">"some-channel"</span>: <span class="string">"myapp.consumer.my_consumer"</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说 channel 中的每一个 message，Django 都会通过消息对象来调用消费者函数（message 对象有 <code>content</code> 属性，是一个字典，还有一个 <code>channel</code> 属性，就是该消息所在的 channel）。</p>
<p>与传统的 request—response 模式不同，channels 将 Django 改为 worker 模式运行 —— 它监听消费者指定的所有 channels，当有消息来时，就运行相应的消费者函数。所以，不单单在绑定的 WSGI 服务器上运行单个进程，Django 运行了三个不同的层：</p>
<ul>
<li>interface servers，Django 和外部网络通信的层。包括一个 WSGI 适配器和一个独立的 WebSocket 服务器，具体细节看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#run-interface-servers" target="_blank" rel="external">Run interface servers</a>。</li>
<li>channel backend，是可插拔的 Python 代码和数据存储库（比如 Redis 或者共享的内存段）负责传输 messages。</li>
<li>workers，监听所有相关的 channels，当 message 准备好的时候，运行对应的消费者函数。</li>
</ul>
<p>这看起来可能比较简单，但这是设计的一部分。我们只是引入一个轻量的比 Django 视图更复杂、抽象的函数，而不是采用一个完整的异步框架。</p>
<p>一个 view 视图接受 request 参数，然后返回一个 response 响应；一个 consumer 消费者接受 channel message 参数，并可以向其他通道写消息。</p>
<p>现在，我们做一个通道来接受 request 请求（叫做 <code>http.request</code>），做一个给每个客户端 response 响应的通道（比如 <code>http.response.o4F2h2Fd</code>），response 响应通道是 request 消息的一个属性（<code>reply_channel</code>）。这样的话，一个 view 视图差不多就是一个 consumer 例子了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_consumer</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 message 中将 request 解码成一个 Request 对象</span></div><div class="line">    django_request = AsgiRequest(message)</div><div class="line">    <span class="comment"># 运行 view</span></div><div class="line">    django_response = view(django_request)</div><div class="line">    <span class="comment"># 将 response 转成 message 格式</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> AsgiHandler.encode_response(django_response):</div><div class="line">        message.reply_channel.send(chunk)</div></pre></td></tr></table></figure>
<p>实际上，这就是 channel 所干的活。interface 服务器将来自外部的连接（HTTP、WebSocket 等等）转换成 channel 中的 message，然后你写 worker 代码去处理这些消息。通常普通的 HTTP 由 Django view/template 内置的 consumer 处理，但你也可以重写添加功能。</p>
<p>然而，关键部分是你可以对任何事件做出响应。你可以触发模型保存、其他输入的 message 或者来自 view 和 form 的代码。解决推送形式的代码 —— 用 WebSocket 或者 HTTP 长轮询通知客户端以实时的方式改变。</p>
<h2 id="Channel-类型"><a href="#Channel-类型" class="headerlink" title="Channel 类型"></a>Channel 类型</h2><p>在这个模型中只要有两种使用方法。第一个也是最主要的一个，给消费者分发任务 —— 添加到 channel 中的消息，任何一个 worker 都能从中取出来给消费者。</p>
<p>第二种类型的 channel 是用来回复的。值得注意的是，这些只监听一个东西 —— interface server。每个回复通道都是独立命名的，当它的客户端结束时会路由回 interface server。</p>
<p>他们之间的差异不是很大 —— 他们都要遵守 channel 的核心定义。但是当扩展规模时就会有一些差异。很高兴，在服务器和工作群集中能随机负载均衡 —— 毕竟任一 worker 都可以处理 message —— 但是 response channel 要把 message 发送到他们监听的 channel 服务器中。</p>
<p>所以，channel 会分这两种类型，然后在名字中带有 <code>!</code> 的表示回复通道 —— 比如 <code>http.response!f5G3fE21f</code>。普通的 channel 没有这个字符，但是只能包含字母数字下划线，并且不能超过 200 个字符。</p>
<p>只是实现后端的话不需要懂 —— 毕竟只有在扩展的时候才会用到。更多关于扩展以及在写后端或 interface server 的时候如何处理 channel 类型的信息，请看 <a href="http://channels.readthedocs.io/en/latest/deploying.html#scaling-up" target="_blank" rel="external">Scaling Up</a>。</p>
<h2 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h2><p>因为 channels 只接通一个接听器，他们不能进行广播。如果你想在一组客户端中随意发送消息，你需要去跟踪这些回复通道。</p>
<p>如果我有一个实时博客，当我保存了一个新的博客，然后我想推送时，我可以给 <code>post_save</code> 信号注册一个处理器，然后给一系列 channel （本处使用 Redis）发送更新消息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">redis_conn = redis.Redis(<span class="string">"localhost"</span>, <span class="number">6379</span>)</div><div class="line"></div><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 循环所有的回复通道，然后发送更新消息</span></div><div class="line">    <span class="keyword">for</span> reply_channel <span class="keyword">in</span> redis_conn.smembers(<span class="string">"readers"</span>):</div><div class="line">        Channel(reply_channel).send(&#123;</div><div class="line">            <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">                <span class="string">"id"</span>: instance.id,</div><div class="line">                <span class="string">"content"</span>: instance.content</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到读者集合</span></div><div class="line">    redis_conn.sadd(<span class="string">"readers"</span>, message.reply_channel.name)</div></pre></td></tr></table></figure>
<p>尽管这能工作，但是有一个小问题 —— 当他们断开连接时，我们从没有把人从 <code>readers</code> 集合中删除。我们可以添加一个消费者去监听 <code>websocket.disconnect</code> 来完成这事，但是我们也需要设置过期时间，避免在发出 disconnect 信号前 interface server 突然退出或者断电。</p>
<p>因为 channel 的基本设计是无状态的，如果一个 interface server 消失，channel 服务器没有“关闭”一个通道这概念 —— 毕竟，通道只是用来传输消息的。</p>
<p>我们没必要关心客户端断开连接后有没有把消息发送给群组 —— 毕竟它都已经断开了。我们关心的是这些不存在的客户端是否会扰乱我们的 channel 后端（可能最终回复通道的名字会起冲突，并把消息发送给不是我们想要的客户端，尽管发生这个情况至少得到几周后）。</p>
<p>现在，我们可以回到上面的例子，并且增加过期集合以及跟踪过期时间，但是这个做的一个框架是什么样的？Channel 以一个叫做 Group 的核心概念来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@receiver(post_save, sender=BlogUpdate)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_update</span><span class="params">(sender, instance, **kwargs)</span>:</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).send(&#123;</div><div class="line">        <span class="string">"text"</span>: json.dumps(&#123;</div><div class="line">            <span class="string">"id"</span>: instance.id,</div><div class="line">            <span class="string">"content"</span>: instance.content</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.connect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_connect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 添加到 reader group</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).add(message.reply_channel)</div><div class="line">    <span class="comment"># 接受 connection request 请求</span></div><div class="line">    message.reply_channel.send(&#123;<span class="string">"accept"</span>: <span class="keyword">True</span>&#125;)</div><div class="line"></div><div class="line"><span class="comment"># 连接到 websocket.disconnect</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ws_disconnect</span><span class="params">(message)</span>:</span></div><div class="line">    <span class="comment"># 从 reader group 移除</span></div><div class="line">    Group(<span class="string">"liveblog"</span>).discard(message.reply_channel)</div></pre></td></tr></table></figure>
<p>Group 不止拥有自己的 <code>send()</code> 方法，他还能自动管理 group 成员的过期事务 —— 当channel 由于非消费开始有过期消息时，我们将它从 group 中移除。当然你仍可以在 disconnect 的时候将它从 group 中移除；过期的代码只是为了防止由于某些原因 disconnect 消息不起作用。</p>
<p>Group 通常只对回复通道有用（包含 <code>!</code> 字符的那个），因为它们对于每个客户端都是唯一的，但如果你愿意的话也可以用于普通 channel。</p>
<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>这只是高层视角下对 channel 和 group 的概览，以及你在一开始该如何考虑使用。记住，Django 虽然提供了一些通道，但你可以自定义自己的 consumer 和 channel。</p>
<p>有件事时 channel 无法做到的，就是保证传输。如果你需要确保任务完成，使用一个系统，在失败的时候重新尝试（比如 celery）或者用一个管理命令来检查是否完成，如果没有完成就重新提交消息（你自己的重试逻辑）。</p>
<p>在接下来的文档中，我们将覆盖更多关于 channel 的一些任务，但现在，我们继续 <a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">Getting Started with Channels</a> 然后写一些代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Channels-概念&quot;&gt;&lt;a href=&quot;#Channels-概念&quot; class=&quot;headerlink&quot; title=&quot;Channels 概念&quot;&gt;&lt;/a&gt;Channels 概念&lt;/h2&gt;&lt;p&gt;Django 的传统视图围绕着 request 和 response 工作。一个 request 进来，Django 就去服务它，生成一个 response 响应，然后 Django 再等待下一个 request。&lt;/p&gt;
&lt;p&gt;在简单的浏览器交互的时候这么做是可以的，但是在像 WebSocket、HTTP2 服务器推送的现代 Web 模式下，网站还需在这个传统循环外进行通信。&lt;/p&gt;
&lt;p&gt;除此之外，我们的应用能在下一个 response 发送前，轻松卸载大量的非关键任务，比如将一些东西保存进缓存或者给新上传的图片做个缩略图。&lt;/p&gt;
&lt;p&gt;它将 Django 的运行模式从简单的 &lt;code&gt;response to request&lt;/code&gt;请求响应，改变为 &lt;code&gt;event oriented&lt;/code&gt;面向事件，这样 Django 就能处理发送到 channels 通道中的大量事件。但这样的话对于每个 event handler 事件处理器或者 consumer 消费者还是没有一个持久的状态，能够像一个 view 视图函数一样独立调用。&lt;/p&gt;
&lt;p&gt;我们先来看看什么是 channels 吧。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Django也能玩实时 —— chapter 1</title>
    <link href="https://yuanblq.github.io/2017/08/04/channel-part1/"/>
    <id>https://yuanblq.github.io/2017/08/04/channel-part1/</id>
    <published>2017-08-04T11:22:14.000Z</published>
    <updated>2017-09-03T15:10:05.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Channels？"><a href="#什么是-Channels？" class="headerlink" title="什么是 Channels？"></a>什么是 Channels？</h2><p>通过 Channels，给 Django 添加了一个新的<a href="http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels" target="_blank" rel="external">传输中间层</a>，通过该层，能实现两个重要的特性：</p>
<ul>
<li><a href="http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example" target="_blank" rel="external">像普通 view 视图一样</a>，处理 WebSocket</li>
<li>作为 Django 的一部分，在同样的服务器中，能运行后台任务</li>
</ul>
<p>当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。</p>
<a id="more"></a>
<h2 id="如何使用呢？"><a href="#如何使用呢？" class="headerlink" title="如何使用呢？"></a>如何使用呢？</h2><p>他将 Django 的处理过程分成了两类：</p>
<ul>
<li>一是处理 HTTP 和 WebSocket</li>
<li>另一个是运行 view 视图函数、websocket 处理器和后台任务（consumers 消费者）</li>
</ul>
<p>他们通过一个叫 <a href="http://channels.readthedocs.io/en/latest/asgi.html" target="_blank" rel="external">ASGI</a> 的协议通信。它和 WSGI 很相似，不过 ASGI 能兼容更多协议类型。</p>
<p>Channels 不会往你的 Django 代码中引入 asyncio、gevent 或者其他任何异步代码。你的所有业务逻辑都是以同步的方式运行在工作进程/线程。</p>
<h2 id="我要改变-Django-的运行方式吗？"><a href="#我要改变-Django-的运行方式吗？" class="headerlink" title="我要改变 Django 的运行方式吗？"></a>我要改变 Django 的运行方式吗？</h2><p><strong>不</strong>，所有的额外工作都完全是可选的。如果你愿意，你可以将运行在 WSGI 服务器下的 Django 更改为如下运行方式：</p>
<ul>
<li>一个 ASGI 服务器，你可能会选择 <a href="http://github.com/django/daphne/" target="_blank" rel="external">Daphne</a></li>
<li>Django 的工作服务器，通过 <code>manage.py runworker</code> 来使用</li>
<li>用来路由 ASGI 请求的东西，比如 Redis</li>
</ul>
<p>当你使用 Channels 时，如果默认把所有的 HTTP 请求都路由给 Django view 视图系统，那它就和之前几乎没有任何差异。</p>
<h2 id="Channels-还能给我什么惊喜？"><a href="#Channels-还能给我什么惊喜？" class="headerlink" title="Channels 还能给我什么惊喜？"></a>Channels 还能给我什么惊喜？</h2><p>还包括如下特性：</p>
<ul>
<li>同一时刻，支持上千个简单的 HTTP 长轮询</li>
<li>对于 websocket，提供完整的 session 和 auth 支持</li>
<li>对于 websocket，基于站点 cookie 自动完成用户登录</li>
<li>对于大量的触发事件，拥有内置 primitive 支持（聊天、实时博客…）</li>
<li>工作服务不停，浏览器暂停的零停机部署</li>
<li>基于 per-URL 的可选低级 HTTP 控制</li>
<li>可以扩展到其他协议或事件源（比如：WebRTC、原生 UDP、SMS）</li>
</ul>
<h2 id="能扩展吗？"><a href="#能扩展吗？" class="headerlink" title="能扩展吗？"></a>能扩展吗？</h2><p><strong>当然可以，</strong>你可以运行任意数量的协议服务（用于同时处理 HTTP 和 WebSocket）和工作服务（用来运行你的 Django 代码）来满足你的使用案例。</p>
<p>ASGI 规范这两个部件之间插入允许大量的不同功能特性的 channel 层。而且它被设计用来支持简单分片以及使用自己的协议和服务器运行单独的集群。</p>
<h2 id="为什么不采用我最喜欢的消息队列？"><a href="#为什么不采用我最喜欢的消息队列？" class="headerlink" title="为什么不采用我最喜欢的消息队列？"></a>为什么不采用我最喜欢的消息队列？</h2><p>Channel 的设计目的优先于低延迟（目标是几毫秒），并且超过保证传送的高吞吐量，这与某些消息队列设计不匹配。</p>
<p>一些像<a href="http://channels.readthedocs.io/en/latest/getting-started.html#enforcing-ordering" target="_blank" rel="external">保证消息顺序</a>的特性会降低性能，但它能使它更像个消息队列。</p>
<h2 id="我需要把我所有的代码都变成异步吗？"><a href="#我需要把我所有的代码都变成异步吗？" class="headerlink" title="我需要把我所有的代码都变成异步吗？"></a>我需要把我所有的代码都变成异步吗？</h2><p>不，如果没有任何 socket 或 事件循环阻塞，你的代码都可以同步运行。你也可以在一些 Django 的 view 视图或 channel 的 consumer 消费者函数中使用异步代码 —— 比如，并行获取大量 URL，但这不会影响整个站点的部署。</p>
<h2 id="Channel-支持哪些-Django-版本？"><a href="#Channel-支持哪些-Django-版本？" class="headerlink" title="Channel 支持哪些 Django 版本？"></a>Channel 支持哪些 Django 版本？</h2><p>你可以在 Django &gt;= 1.8 的版本上将 Channels 最为一个库来安装。另外，它可能需要一些额外的依赖，不过你都可以通过 <code>pip</code> 安装。</p>
<p>一开始的时候，Channels 并不在 Django 的核心功能中，不过自从 2016.9 月以后，它就成为了 Django 的官方项目。更多关于 Channels 被采纳为 官方项目的信息可以从 <a href="https://www.djangoproject.com/weblog/2016/sep/09/channels-adopted-official-django-project/" target="_blank" rel="external">Django blog</a> 中查询。</p>
<h2 id="接下来我该读什么？"><a href="#接下来我该读什么？" class="headerlink" title="接下来我该读什么？"></a>接下来我该读什么？</h2><p>首先阅读关于 <a href="http://channels.readthedocs.io/en/latest/concepts.html" target="_blank" rel="external">Channel 的一些概念</a>，然后继续阅读我们的<a href="http://channels.readthedocs.io/en/latest/getting-started.html" target="_blank" rel="external">示例教程</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Channels？&quot;&gt;&lt;a href=&quot;#什么是-Channels？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Channels？&quot;&gt;&lt;/a&gt;什么是 Channels？&lt;/h2&gt;&lt;p&gt;通过 Channels，给 Django 添加了一个新的&lt;a href=&quot;http://channels.readthedocs.io/en/latest/concepts.html#what-are-channels&quot;&gt;传输中间层&lt;/a&gt;，通过该层，能实现两个重要的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://channels.readthedocs.io/en/latest/getting-started.html#websocket-example&quot;&gt;像普通 view 视图一样&lt;/a&gt;，处理 WebSocket&lt;/li&gt;
&lt;li&gt;作为 Django 的一部分，在同样的服务器中，能运行后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有其他特性，不过在刚开始时，这两个是我们用的最多的。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Django" scheme="https://yuanblq.github.io/tags/Django/"/>
    
      <category term="WebSocket" scheme="https://yuanblq.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part4</title>
    <link href="https://yuanblq.github.io/2017/07/31/asyncio4/"/>
    <id>https://yuanblq.github.io/2017/07/31/asyncio4/</id>
    <published>2017-07-31T07:08:14.000Z</published>
    <updated>2017-09-03T15:10:27.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不同线程的事件循环"><a href="#不同线程的事件循环" class="headerlink" title="不同线程的事件循环"></a>不同线程的事件循环</h2><p>通过前面的介绍，我们现在能在单线程中实现多协程的工作。</p>
<p>这节就说说怎么在多线程中管理协程。</p>
<p>对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work start --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(now() - start))</div></pre></td></tr></table></figure>
<pre><code>TIME: 0.0023021697998046875
More work start --&gt; 6
Finished more work 6
More work start --&gt; 3
Finished more work 3
</code></pre><p>可见，当前线程不会阻塞。新的线程会按顺序执行 <code>call_soon_threadsafe()</code> 方法中注册的函数，因为注册的方法不是协程，所以新开的线程大概会执行 6+3 s。</p>
<p>那么，多线程实现协程的过程大致也是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line">    </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work --&gt; &#123;&#125;'</span>.format(x))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    print(<span class="string">'&#123;&#125; Done after &#123;&#125;s'</span>.format(x, x))</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line"></div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">6</span>), new_loop)</div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">3</span>), new_loop)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>TIME:  0.0006730556488037109
More work --&gt; 6
More work --&gt; 3
3 Done after 3s
6 Done after 6s
</code></pre><p>由于我们在子线程开启的是协程任务，所以子线程大概耗时 6s。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;不同线程的事件循环&quot;&gt;&lt;a href=&quot;#不同线程的事件循环&quot; class=&quot;headerlink&quot; title=&quot;不同线程的事件循环&quot;&gt;&lt;/a&gt;不同线程的事件循环&lt;/h2&gt;&lt;p&gt;通过前面的介绍，我们现在能在单线程中实现多协程的工作。&lt;/p&gt;
&lt;p&gt;这节就说说怎么在多线程中管理协程。&lt;/p&gt;
&lt;p&gt;对于多线程中的协程操作，我们一般把一个线程当做管理线程，而另一个当做工作线程，其中有多个协程进行不同的 task 操作。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part3</title>
    <link href="https://yuanblq.github.io/2017/07/30/asyncio3/"/>
    <id>https://yuanblq.github.io/2017/07/30/asyncio3/</id>
    <published>2017-07-30T03:27:31.000Z</published>
    <updated>2017-09-03T01:29:31.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="停止协程"><a href="#停止协程" class="headerlink" title="停止协程"></a>停止协程</h2><p><code>Future</code> 对象有几种状态：</p>
<ul>
<li>pending</li>
<li>running</li>
<li>done</li>
<li>cancelled</li>
</ul>
<p><code>Future</code> 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<h3 id="逐个停止"><a href="#逐个停止" class="headerlink" title="逐个停止"></a>逐个停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</div><div class="line">        print(task.cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;wait() running at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:355&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-d349a09958ba&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
True
True
True
TIME:  1.8798322677612305
</code></pre><p><code>True</code> 表示取消成功。</p>
<p>上述方法是逐个 <code>cancel</code>。也可以像之前提到的，把所有的 task 封装在一个函数中，这样，该函数就相当于是最外面的一个 task，那么可以对该函数处理：</p>
<h3 id="打包停止"><a href="#打包停止" class="headerlink" title="打包停止"></a>打包停止</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</div><div class="line">        print(<span class="string">'Task result: '</span>, task.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line">task = asyncio.ensure_future(main())</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(task)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    print(asyncio.gather(*asyncio.Task.all_tasks()).cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line">    </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
{&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;main() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:17&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_run_until_complete_cb() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/base_events.py:176]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;, &lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-2-daa7e16e8aa3&gt;:3&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /home/chy/.pyenv/versions/3.5.3/lib/python3.5/asyncio/tasks.py:422]&gt;}
True
TIME:  0.649970531463623
</code></pre><p>到目前为止，我们已经能够简单地开启多个协程，管理多个协程，可是，如果一个协程耗时过长，那么整个线程依旧会阻塞，这时我们只有开启多线程或者多进程来实现并行操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;停止协程&quot;&gt;&lt;a href=&quot;#停止协程&quot; class=&quot;headerlink&quot; title=&quot;停止协程&quot;&gt;&lt;/a&gt;停止协程&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象有几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pending&lt;/li&gt;
&lt;li&gt;running&lt;/li&gt;
&lt;li&gt;done&lt;/li&gt;
&lt;li&gt;cancelled&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Future&lt;/code&gt; 对象刚创建的时候是 pending 状态，处于调用状态为 running，执行完毕就是 done，如果在执行期间停止事件，则是 cancelled。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part2</title>
    <link href="https://yuanblq.github.io/2017/07/29/asyncio2/"/>
    <id>https://yuanblq.github.io/2017/07/29/asyncio2/</id>
    <published>2017-07-29T01:14:37.000Z</published>
    <updated>2017-09-03T01:29:31.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h2><p>要想使用 <code>asyncio</code> 实现异步，和 <code>gevent</code> 差不多，都需要相应的代码支持。<code>gevent</code> 是通过打上“猴子补丁”来实现的，而 <code>asyncio</code> 和 <code>yield from</code> 有着千丝万缕的关系，所以先实现就比较简单了。</p>
<p>你可以自己用 <code>yield from</code> 写个协程方法，要么就只能用用别人实现的协程模块。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3),</div><div class="line">]</div><div class="line"></div><div class="line"><span class="comment"># 完成一个任务打印一个</span></div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    task.add_done_callback(done_callback)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 将协程 task 任务列表添加到事件循环中</span></div><div class="line"><span class="comment"># 这两种方法都能实现添加事件循环</span></div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="comment"># loop.run_until_complete(asyncio.gather(*tasks))</span></div><div class="line"></div><div class="line"><span class="comment"># 最后一个任务完成的时候一起打印</span></div><div class="line"><span class="comment"># for task in tasks:</span></div><div class="line"><span class="comment">#     print("Task result: ", task.result())</span></div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Callback:  work 2 Done after 2s
Callback:  work 3 Done after 3s
Callback:  work 4 Done after 4s
TIME:  4.004777193069458
</code></pre><p>总计花了 4s 多点的时间，如果是同步的话，至少 9s。可见，我们通过 <code>asyncio</code> 实现了并发功能。</p>
<h2 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h2><p>在协程的嵌套中，如何处理协程返回的数据是件很灵活的事。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'work &#123;0&#125; Done after &#123;1&#125;s'</span>.format(x, x)</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="comment"># dones, pendings = await asyncio.wait(tasks)</span></div><div class="line">    <span class="comment"># print(dones)</span></div><div class="line">    <span class="comment"># print(pendings)</span></div><div class="line">    <span class="comment"># for task in dones:</span></div><div class="line">    <span class="comment">#     print('Task result: ', task.result())</span></div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.0052490234375
</code></pre><p>在 <code>main()</code> 协程函数中，可以不直接处理结果，直接返回 <code>await</code> 内容，那么，<code>run_until_complete()</code> 将会接受返回的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line">    </div><div class="line">    <span class="comment"># wait 返回 task 对象</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">dones, pendings = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> done <span class="keyword">in</span> dones:</div><div class="line">    print(<span class="string">"Task result: "</span>, done.result())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 4 Done after 4s
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
TIME:  4.0036780834198
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="comment"># gather 直接返回的是协程运行结果</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">results = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(<span class="string">"Task result: "</span>, result)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.003807544708252
</code></pre><p>除此之外，还可以使用 asyncio 的 <code>as_completed()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">3</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"></div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3),</div><div class="line">    ]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</div><div class="line">        result = <span class="keyword">await</span> task</div><div class="line">        print(<span class="string">"Task result: "</span>, result)</div><div class="line">    </div><div class="line">    </div><div class="line">start = now()</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Waiting:  3
Waiting:  4
Task result:  work 2 Done after 2s
Task result:  work 3 Done after 3s
Task result:  work 4 Done after 4s
TIME:  4.002615690231323
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异步实现&quot;&gt;&lt;a href=&quot;#异步实现&quot; class=&quot;headerlink&quot; title=&quot;异步实现&quot;&gt;&lt;/a&gt;异步实现&lt;/h2&gt;&lt;p&gt;要想使用 &lt;code&gt;asyncio&lt;/code&gt; 实现异步，和 &lt;code&gt;gevent&lt;/code&gt; 差不多，都需要相应的代码支持。&lt;code&gt;gevent&lt;/code&gt; 是通过打上“猴子补丁”来实现的，而 &lt;code&gt;asyncio&lt;/code&gt; 和 &lt;code&gt;yield from&lt;/code&gt; 有着千丝万缕的关系，所以先实现就比较简单了。&lt;/p&gt;
&lt;p&gt;你可以自己用 &lt;code&gt;yield from&lt;/code&gt; 写个协程方法，要么就只能用用别人实现的协程模块。&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>影分身术之-asyncio_part1</title>
    <link href="https://yuanblq.github.io/2017/07/28/asyncio1/"/>
    <id>https://yuanblq.github.io/2017/07/28/asyncio1/</id>
    <published>2017-07-28T04:59:48.000Z</published>
    <updated>2017-09-03T01:29:31.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建一个协程"><a href="#创建一个协程" class="headerlink" title="创建一个协程"></a>创建一个协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"></div><div class="line"><span class="comment"># 定义协程函数</span></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div></pre></td></tr></table></figure>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">获取协程对象，协程对象的调用不会立刻执行函数</div><div class="line">协程对象需要注册到事件循环上，由事件循环调用</div><div class="line">"""</div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取事件循环对象</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="comment"># 调用协程对象</span></div><div class="line">loop.run_until_complete(coroutine)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
TIME:  0.0010256767272949219
</code></pre><h2 id="创建一个-task"><a href="#创建一个-task" class="headerlink" title="创建一个 task"></a>创建一个 task</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">3</span>)</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">ensure_future() 返回的也是 Furure 对象，</div><div class="line">内部同样是调用的 create_task()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">"""</div><div class="line">task = loop.create_task(coroutine)</div><div class="line"></div><div class="line">print(task)</div><div class="line">loop.run_until_complete(task)</div><div class="line">print(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>&lt;Task pending coro=&lt;do_some_work() running at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt;&gt;
Waiting:  3
&lt;Task finished coro=&lt;do_some_work() done, defined at &lt;ipython-input-12-3ef64d36efb6&gt;:7&gt; result=None&gt;
TIME:  0.0009589195251464844
</code></pre><p>所谓 task 对象本质上是一个 <code>Future</code> 对象（是 <code>Future</code> 的子类）。<code>Future</code> 类保存了协程运行后的状态，用于未来获取协程的结果。</p>
<p>task 在加入事件循环之前是 pending 状态。执行完成之后为 finished 状态。</p>
<p><code>asyncio.ensure_future(coroutine)</code> 和 <code>loop.create_task(coroutine)</code> 都可以创建一个 task，<code>asyncio.ensure_future(coroutine)</code> 内部就是通过调用 <code>loop.create_task(coroutine)</code> 返回的 task 对象。</p>
<h2 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h2><p>我们修改一下 <code>do_some_work()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line">task.add_done_callback(done_callback)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  Done after 2s
TIME:  0.0015606880187988281
</code></pre><p><code>Future</code> 对象的 <code>add_done_callback()</code> 方法接受一个回调函数对象，并且会把自己也传过去。等 task 调用结束时，就可以通过 task 对象的 <code>result()</code> 方法获取调用返回值。</p>
<p>如果有这么一种需求，当回调的时候，我们还需要往回调函数传入多个参数。这种情况可以通过偏函数解决：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> functools</div><div class="line"></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">done_callback_part</span><span class="params">(op, future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, op, future.result())</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"></div><div class="line"><span class="comment"># 给 task 对象添加回调函数</span></div><div class="line"><span class="comment"># 注意参数传入的顺序</span></div><div class="line">task.add_done_callback(functools.partial(done_callback_part, <span class="string">"other param"</span>))</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Callback:  other param Done after 2s
TIME:  0.00046443939208984375
</code></pre><h2 id="阻塞和-await"><a href="#阻塞和-await" class="headerlink" title="阻塞和 await"></a>阻塞和 await</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"></div><div class="line">start = now()</div><div class="line"></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">loop.run_until_complete(task)</div><div class="line"></div><div class="line">print(<span class="string">"Task result: "</span>, task.result())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure>
<pre><code>Waiting:  2
Task result:  Done after 2s
TIME:  2.0026657581329346
</code></pre><p>当 sleep 的时候，使用 <code>await</code> 让出控制权。即当程序执行到耗时操作时，使用 <code>await</code> 方法将协程的控制权让出，以便 <code>loop</code> 调用其他协程。</p>
<p>上面的例子都只有一个协程，所以看不出有什么效果。接下来我们就上多个协程瞧瞧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;创建一个协程&quot;&gt;&lt;a href=&quot;#创建一个协程&quot; class=&quot;headerlink&quot; title=&quot;创建一个协程&quot;&gt;&lt;/a&gt;创建一个协程&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; asyncio&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;now = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt;: time.time()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义协程函数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;do_some_work&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Waiting: &#39;&lt;/span&gt;, x)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="异步" scheme="https://yuanblq.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL-Redis</title>
    <link href="https://yuanblq.github.io/2017/07/26/Redis/"/>
    <id>https://yuanblq.github.io/2017/07/26/Redis/</id>
    <published>2017-07-26T06:18:49.000Z</published>
    <updated>2017-09-04T04:28:41.764Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是键值对存储的，通过键存入的值会永久存储。<a href="http://try.redis.io/" target="_blank" rel="external">入门 Redis 最好的网站</a></p>
<h2 id="set-get"><a href="#set-get" class="headerlink" title="set / get"></a>set / get</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set name &quot;fido&quot;</div></pre></td></tr></table></figure>
<p><code>set</code> 设置键值对。然后就可以通过 <code>get</code> 键名来获取对应的键值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get name</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; &quot;fido&quot;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="del-incr-decr"><a href="#del-incr-decr" class="headerlink" title="del / incr / decr"></a>del / incr / decr</h2><p><code>del</code> : 通过键名删除对应的键值。<br><code>incr</code> : 自增键名所对应的键值（如果键名对应的键值不存在，自动设置对应的键值为 1）。<br><code>decr</code> : 自减键名所对应的键值（如果键名对应的键值不存在，自动设置对应的键值为 -1）。</p>
<p>像 <code>incr</code> 和 <code>decr</code> 这种操作明明可以通过一些简单的操作运算就能完成，为什么 Redis 还要提供这样的操作呢？</p>
<p>因为当同时操作同一个键名对应的键值时（所谓的并发），就可能会发生错误。所以像 <code>incr</code> 这种操作，在 Redis 中是 <code>atomic</code> 原子性操作，Redis 还有很多类似的操作。</p>
<h2 id="expire-ttl"><a href="#expire-ttl" class="headerlink" title="expire / ttl"></a>expire / ttl</h2><p><code>expire</code> : 设置键名的存活时间。<br><code>ttl</code> : 查询键名是否存活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) -1</div></pre></td></tr></table></figure>
<p><code>-1</code> 表示该键名永不过期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">expire name 120</div><div class="line">// 设置 name 的存活时间为 120 秒</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) 120</div></pre></td></tr></table></figure>
<p>如果 <code>ttl</code> 的键名没过期，则返回该键名还能存活的时间（秒）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 120s 后</div><div class="line">ttl name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; (integer) -2</div></pre></td></tr></table></figure>
<p><code>-2</code> 表示对应的键名已过期 / 不存在。</p>
<h2 id="rpush-lpush-lrange-lpop-rpop-llen"><a href="#rpush-lpush-lrange-lpop-rpop-llen" class="headerlink" title="rpush / lpush / lrange / lpop / rpop / llen"></a>rpush / lpush / lrange / lpop / rpop / llen</h2><p>Redis 能够操作很多复杂的数据结构，比如列表：</p>
<p><code>rpush</code> : 在列表最后添加新值。<br><code>lrange</code> : 列表的切片操作。<br><code>lpop</code> : 删除列表起始值，并返回删除的值。<br><code>rpop</code> : 删除列表末尾值，并返回删除的值。<br><code>llen</code> : 返回列表长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rpush friends &quot;Alice&quot;</div><div class="line">rpush friends &quot;Bob&quot;</div><div class="line">lpush friends &quot;Sam&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lrange friends 0 -1  =&gt;  1)&quot;Sam&quot; 2)&quot;Alice&quot; 3)&quot;Bob&quot;</div><div class="line">lrange friends 1 2  =&gt;  1)&quot;Alice&quot; 2)&quot;Bob&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lpop friends  =&gt;  &quot;Sam&quot;</div><div class="line">rpop friends  =&gt;  &quot;Bob&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">llen friends  =&gt;  1</div></pre></td></tr></table></figure>
<h2 id="sadd-srem-sismember-smembers-sunion"><a href="#sadd-srem-sismember-smembers-sunion" class="headerlink" title="sadd / srem / sismember / smembers / sunion"></a>sadd / srem / sismember / smembers / sunion</h2><p>在比如说，set 集合这个数据结构。集合除了无序，不重复外，其他与列表很像。</p>
<p><code>sadd</code> : 往集合中添加元素。<br><code>srem</code> : 从集合中删除元素。<br><code>sismember</code> : 测试所给的值是否在该集合中，返回 1 表示存在，0 表示不存在。<br><code>smembers</code> : 返回集合中所有元素的一个列表。<br><code>sunion</code> : 联合两个或很多个集合，并返回所有元素的一个列表。</p>
<h2 id="zadd-zrange"><a href="#zadd-zrange" class="headerlink" title="zadd / zrange"></a>zadd / zrange</h2><p>虽然集合在某些方面很便利，但是集合无法排序，所以 Redis 提供了一种有序的集合。</p>
<p>有序集合与一般的集合差别不大，只是在创建新值的时候需要制定该值相关的分数（用作排序依据）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ZADD hackers 1940 &quot;Alan Kay&quot;</div><div class="line">ZADD hackers 1906 &quot;Grace Hopper&quot;</div><div class="line">ZADD hackers 1953 &quot;Richard Stallman&quot;</div><div class="line">ZADD hackers 1965 &quot;Yukihiro Matsumoto&quot;</div><div class="line">ZADD hackers 1916 &quot;Claude Shannon&quot;</div><div class="line">ZADD hackers 1969 &quot;Linus Torvalds&quot;</div><div class="line">ZADD hackers 1957 &quot;Sophie Wilson&quot;</div><div class="line">ZADD hackers 1912 &quot;Alan Turing&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zrange hackers 2 4  =&gt;  1) &quot;Claude Shannon&quot;, 2) &quot;Alan Kay&quot;, 3) &quot;Richard Stallman&quot;</div></pre></td></tr></table></figure>
<p>切片的用法和列表很像。</p>
<h2 id="hset-hgetall-hget"><a href="#hset-hgetall-hget" class="headerlink" title="hset / hgetall / hget"></a>hset / hgetall / hget</h2><p>Redis 中有一中数据结构和字典和相似：<code>Hashes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hset user name &quot;John Smith&quot;</div><div class="line">hset user email &quot;john.smith@example.com&quot;</div><div class="line">hset user password &quot;s3cret&quot;</div></pre></td></tr></table></figure>
<p>通过 <code>hgetall</code> 获取所有的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hgetall user</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1) &quot;name&quot;</div><div class="line">2) &quot;John Smith&quot;</div><div class="line">3) &quot;email&quot;</div><div class="line">4) &quot;john.smith@example.com&quot;</div><div class="line">5) &quot;password&quot;</div><div class="line">6) &quot;s3cret&quot;</div></pre></td></tr></table></figure>
<p>或者通过 <code>hget</code> 获取单个字段的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hget user name  =&gt;  “John Smith&quot;</div></pre></td></tr></table></figure></p>
<p>hash 字段中的数字，也能像普通数字字段一样，能进行原子自增自减操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hset user visits 10</div><div class="line">hincrby user visits 1  =&gt;  11</div><div class="line">hdecrby user visits 2  =&gt;  9</div><div class="line">hdel user visits</div><div class="line">hincrby user visits 1  =&gt; 1</div></pre></td></tr></table></figure>
<pre><code>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis 是键值对存储的，通过键存入的值会永久存储。&lt;a href=&quot;http://try.redis.io/&quot;&gt;入门 Redis 最好的网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;set-get&quot;&gt;&lt;a href=&quot;#set-get&quot; class=&quot;headerlink&quot; title=&quot;set / get&quot;&gt;&lt;/a&gt;set / get&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;set name &amp;quot;fido&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt; 设置键值对。然后就可以通过 &lt;code&gt;get&lt;/code&gt; 键名来获取对应的键值：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;get name&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &amp;quot;fido&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL-MongoDB</title>
    <link href="https://yuanblq.github.io/2017/07/26/MongoDB/"/>
    <id>https://yuanblq.github.io/2017/07/26/MongoDB/</id>
    <published>2017-07-26T04:43:02.000Z</published>
    <updated>2017-09-04T04:28:38.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="show-dbs-db-use-xx"><a href="#show-dbs-db-use-xx" class="headerlink" title="show dbs / db / use xx"></a>show dbs / db / use xx</h3><ul>
<li><code>show dbs</code> 显示当前所有数据库</li>
<li><code>db</code> 显示当前所选数据库</li>
<li><code>use xx</code> 选择 xx 数据库，如果当前没有该数据库，则自动创建</li>
</ul>
<h3 id="db-dropDatabase"><a href="#db-dropDatabase" class="headerlink" title="db.dropDatabase()"></a>db.dropDatabase()</h3><p>删除当前数据库</p>
<a id="more"></a>
<h2 id="集合和文档的操作"><a href="#集合和文档的操作" class="headerlink" title="集合和文档的操作"></a>集合和文档的操作</h2><h3 id="insert-save-update"><a href="#insert-save-update" class="headerlink" title="insert / save / update"></a>insert / save / update</h3><p><code>db.集合名字.insert(文档)</code><br>往该集合中插入一个文档，如果该集合不存在，会自动创建该集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.coll.insert(&#123;</div><div class="line">    name: &quot;Zhang&quot;,</div><div class="line">    age: 12,</div><div class="line">    addr: [&quot;beijng&quot;, &quot;tianjing&quot;],</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><code>save()</code> 方法：</p>
<ul>
<li>如果不指定 <code>_id</code> 字段，则和 <code>insert()</code> 方法一样</li>
<li>如果指定 <code>_id</code> 字段，则更新该文档的数据</li>
</ul>
<p><code>update()</code> 语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">db.coll.update(</div><div class="line">    &lt;query&gt;,</div><div class="line">    &lt;update&gt;,</div><div class="line">    &#123;</div><div class="line">        upsert: &lt;boolean&gt;,</div><div class="line">        multi: &lt;boolean&gt;,</div><div class="line">        writeConcern: &lt;document&gt;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li><code>query</code>：update 的查询条件，类似 sql update 中的 where</li>
<li><code>update</code>：update 的对象，类似 sql update 中的 set</li>
<li><code>upsert</code>：可选（默认 false），如果 update 的记录不存在是否将其新增进去</li>
<li><code>multi</code>：可选（默认 false），有相同的记录是否全部找出来</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
<p>比如我们通过 update() 方法更新上面的姓名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.coll.update(</div><div class="line">    &#123;&quot;name&quot;: &quot;Zhang&quot;&#125;,</div><div class="line">    &#123;$set: &#123;&quot;name&quot;: &quot;Li&quot;&#125;&#125;,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>更多实例：</p>
<p>只更新第一条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; );</div></pre></td></tr></table></figure></p>
<p>全部更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true );</div></pre></td></tr></table></figure></p>
<p>只添加第一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false );</div></pre></td></tr></table></figure></p>
<p>全部添加加进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true );</div></pre></td></tr></table></figure></p>
<p>全部更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true );</div></pre></td></tr></table></figure></p>
<p>只更新第一条记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false );</div></pre></td></tr></table></figure></p>
<h3 id="find-pretty"><a href="#find-pretty" class="headerlink" title="find / pretty"></a>find / pretty</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.coll.find()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;), &quot;name&quot; : &quot;Zhang&quot;, &quot;age&quot; : 12, &quot;addr&quot; : [ &quot;beijng&quot;, &quot;tianjing&quot; ] &#125;</div></pre></td></tr></table></figure>
<p>在 <code>find()</code> 方法后面加上 <code>pretty()</code> 则以格式化的形式，显示所查询的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find().pretty()</div><div class="line">&#123;</div><div class="line">	&quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;),</div><div class="line">	&quot;name&quot; : &quot;Zhang&quot;,</div><div class="line">	&quot;age&quot; : 12,</div><div class="line">	&quot;addr&quot; : [</div><div class="line">		&quot;beijng&quot;, </div><div class="line">        &quot;tianjing&quot;</div><div class="line">	]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove()</code> 方法的基本语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">db.coll.remove(</div><div class="line">    &lt;query&gt;,</div><div class="line">    &#123;</div><div class="line">        justOne: &lt;boolean&gt;,</div><div class="line">        writeConcern: &lt;document&gt;</div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>参数说明：</p>
<ul>
<li><code>query</code>：可选，删除文档的条件</li>
<li><code>justOne</code>：可选，如果设为 true，则只删除一个文档</li>
<li><code>writeConcern</code>：可选，抛出异常的级别</li>
</ul>
<p>我们再插入一个文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">db.coll.insert(&#123;</div><div class="line">    name: &quot;Wang&quot;,</div><div class="line">    age: 25,</div><div class="line">    addr: [&quot;henan&quot;, &quot;hunan&quot;],</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>使用 <code>find()</code> 查询数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;5992f9bfe81188c3e5ce8c72&quot;), &quot;name&quot; : &quot;zhang&quot;, &quot;age&quot; : 12, &quot;addr&quot; : [ &quot;beijng&quot;, &quot;tianjing&quot; ] &#125;</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59930244e81188c3e5ce8c73&quot;), &quot;name&quot; : &quot;Wang&quot;, &quot;age&quot; : 25, &quot;addr&quot; : [ &quot;henan&quot;, &quot;hunan&quot; ] &#125;</div></pre></td></tr></table></figure></p>
<p>接下来我们移除 name 为 Zhang 的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">db.coll.remove(</div><div class="line">    &#123;&quot;name&quot;: &quot;zhang&quot;&#125;</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>现在数据文档只剩下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; db.coll.find()</div><div class="line">&#123; &quot;_id&quot; : ObjectId(&quot;59930244e81188c3e5ce8c73&quot;), &quot;name&quot; : &quot;Wang&quot;, &quot;age&quot; : 25, &quot;addr&quot; : [ &quot;henan&quot;, &quot;hunan&quot; ] &#125;</div></pre></td></tr></table></figure></p>
<h2 id="MongoDB-与-RDBMS-where-语句比较"><a href="#MongoDB-与-RDBMS-where-语句比较" class="headerlink" title="MongoDB 与 RDBMS where 语句比较"></a>MongoDB 与 RDBMS where 语句比较</h2><table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">范例</th>
<th style="text-align:center">RDBMS中的类似语句</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: &lt;value&gt;}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;name&quot;: &quot;zhang&quot;})</code></td>
<td style="text-align:center"><code>where by = &quot;zhang&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">小于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$lt: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$lt: 18}})</code></td>
<td style="text-align:center"><code>where age &lt; 18</code></td>
</tr>
<tr>
<td style="text-align:center">小于或等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$lte: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$lte: 18}})</code></td>
<td style="text-align:center"><code>where age &lt;= 18</code></td>
</tr>
<tr>
<td style="text-align:center">大于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$gt: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$gt: 18}})</code></td>
<td style="text-align:center"><code>where age &gt; 18</code></td>
</tr>
<tr>
<td style="text-align:center">大于或等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$gte: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$gte: 18}})</code></td>
<td style="text-align:center"><code>where age &gt;= 18</code></td>
</tr>
<tr>
<td style="text-align:center">不等于</td>
<td style="text-align:center"><code>{&lt;key&gt;: {$ne: &lt;value&gt;}}</code></td>
<td style="text-align:center"><code>db.coll.find({&quot;age&quot;: {$ne: 18}})</code></td>
<td style="text-align:center"><code>where age != 18</code></td>
</tr>
</tbody>
</table>
<h2 id="MongoDB-and-条件"><a href="#MongoDB-and-条件" class="headerlink" title="MongoDB and 条件"></a>MongoDB and 条件</h2><p>MongoDB 的 <code>find()</code> 方法可以传入多个键，每个键以逗号分隔：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.col.find(&#123;key1:value1, key2:value2&#125;).pretty()</div></pre></td></tr></table></figure></p>
<h2 id="MongoDB-or-条件"><a href="#MongoDB-or-条件" class="headerlink" title="MongoDB or 条件"></a>MongoDB or 条件</h2><p>MongoDB or 条件使用了关键字 <code>$or</code>，语法格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;db.coll.find(&#123;$or: [&#123;key1: value1&#125;, &#123;key2: value2&#125;]&#125;).pretty()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库操作&quot;&gt;&lt;a href=&quot;#数据库操作&quot; class=&quot;headerlink&quot; title=&quot;数据库操作&quot;&gt;&lt;/a&gt;数据库操作&lt;/h2&gt;&lt;h3 id=&quot;show-dbs-db-use-xx&quot;&gt;&lt;a href=&quot;#show-dbs-db-use-xx&quot; class=&quot;headerlink&quot; title=&quot;show dbs / db / use xx&quot;&gt;&lt;/a&gt;show dbs / db / use xx&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;show dbs&lt;/code&gt; 显示当前所有数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;db&lt;/code&gt; 显示当前所选数据库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use xx&lt;/code&gt; 选择 xx 数据库，如果当前没有该数据库，则自动创建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;db-dropDatabase&quot;&gt;&lt;a href=&quot;#db-dropDatabase&quot; class=&quot;headerlink&quot; title=&quot;db.dropDatabase()&quot;&gt;&lt;/a&gt;db.dropDatabase()&lt;/h3&gt;&lt;p&gt;删除当前数据库&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="MongoDB" scheme="https://yuanblq.github.io/tags/MongoDB/"/>
    
      <category term="Database" scheme="https://yuanblq.github.io/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-归并排序</title>
    <link href="https://yuanblq.github.io/2017/07/16/merger-sort/"/>
    <id>https://yuanblq.github.io/2017/07/16/merger-sort/</id>
    <published>2017-07-16T11:18:30.000Z</published>
    <updated>2017-09-03T14:59:43.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>有很多算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决相关的若干子问题。</p>
<p>这是典型的分治法思想：将原问题分解为几个规模较小，但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
<a id="more"></a>
<p>归并排序算法完全遵循分治模式。直观上操作如下：</p>
<ul>
<li><strong>分解：</strong>分解待排序的 n 个元素的序列成各具 n/2 个元素的 2 个子序列</li>
<li><strong>解决：</strong>使用归并排序递归地排序 2 个子序列</li>
<li><strong>合并：</strong>合并两个已排序的子序列以产生已排序的答案</li>
</ul>
<p>层层往下分解的时候，当待排序的序列长度为 1 时，递归“开始回升”，这种情况下不要做任何工作，因为长度为 1 的每个序列都已排好序。</p>
<p>归并算法的关键操作是“合并”步骤中，两个已排序序列的合并。</p>
<p>回到插入排序中我们所举的扑克牌的例子，假设桌面上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶上。</p>
<p>我们希望把这两堆牌合并成单一的排好序的输出堆。我们可以这么做：</p>
<p>在牌面朝上的两堆牌的顶上选取较小的一张，将该牌从其堆中移开，并将牌面向下地放置到最终的输出堆。重复这个步骤，直到一个输出堆为空，这时，我们只需将剩余的一堆牌朝下地放置到输出堆。</p>
<p>因为我们之比较顶上的两张牌，所以合并步骤只需 O(n) 的时间。</p>
<p>下面以伪代码的形式实现上面的思想：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A: 数组  p、q、r是数组的下表，满足 p &lt;= q &lt; r</span></div><div class="line">MERAGE(A, p, q, r)</div><div class="line">n1 = q - p + <span class="number">1</span></div><div class="line">n2 = r - q</div><div class="line"><span class="comment"># let L[1, n1+1] and R[1, n2+1] be new arrays</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n1):</div><div class="line">    L[i] = A[p+i<span class="number">-1</span>]</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n2):</div><div class="line">    R[j] = A[q+j]</div><div class="line">L[n1+<span class="number">1</span>] = ∞</div><div class="line">R[n2+<span class="number">1</span>] = ∞</div><div class="line">i = <span class="number">1</span></div><div class="line">j = <span class="number">1</span></div><div class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(p, r):</div><div class="line">    <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">        A[k] = L[i]</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        A[k] = R[j]</div><div class="line">        j += <span class="number">1</span></div></pre></td></tr></table></figure>
<p>下面为两个已排好序的列表，进行合并操作的示意图：</p>
<p><img src="/2017/07/16/merger-sort/2-3.png" alt="合并示意图"></p>
<p>然后我们把这个合并操作作为归并算法中的一个子程序来用。</p>
<p>下面过程中 <code>merger-sort(A, p, r)</code> 排序子数组 A[p..r] 中的元素。若 p &gt;= r，则该子数组最多有一个元素，所以已经排好序。否则，分解步骤简单地计算一个下标 q，将 A[p..r] 分成两个子数组 A[p..q] 和 A[q+1..r]，前者包含 n/2 个元素，后者包含 n/2 个元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># merger-sort(A, p, r)</span></div><div class="line"><span class="keyword">if</span> p &lt; r:</div><div class="line">    q = (p+r) / <span class="number">2</span></div><div class="line">    <span class="comment"># 对这两数组进行归并排序</span></div><div class="line">    merger-sort(A, p, q)</div><div class="line">    merger-sort(A, q+<span class="number">1</span>, r)</div><div class="line">    <span class="comment"># 将排好序的两个数组合并</span></div><div class="line">    merger(A, p, q, r)</div></pre></td></tr></table></figure>
<p>以下是 Python 实现的完整归并算法，仅供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merger</span><span class="params">(ls, rs)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    用于合并两个列表</div><div class="line">    '''</div><div class="line">    B = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ls:</div><div class="line">            B.extend(rs)</div><div class="line">            <span class="keyword">return</span> B</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rs:</div><div class="line">            B.extend(ls)</div><div class="line">            <span class="keyword">return</span> B</div><div class="line">        <span class="keyword">if</span> ls[<span class="number">0</span>] &lt; rs[<span class="number">0</span>]:</div><div class="line">            B.append(ls.pop(<span class="number">0</span>))</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            B.append(rs.pop(<span class="number">0</span>))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merger_sort</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    归并排序</div><div class="line">    '''</div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</div><div class="line">        <span class="keyword">return</span> A</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        mid = length // <span class="number">2</span></div><div class="line">    La = merger_sort(A[:mid])</div><div class="line">    Ra = merger_sort(A[mid:])</div><div class="line">    <span class="keyword">return</span> merger(La, Ra)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>]</div><div class="line">print(merger_sort(a))</div></pre></td></tr></table></figure>
<pre><code>[0, 1, 2, 3, 4, 6, 7, 7, 9]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;p&gt;有很多算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决相关的若干子问题。&lt;/p&gt;
&lt;p&gt;这是典型的分治法思想：将原问题分解为几个规模较小，但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。&lt;/p&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Algorithms" scheme="https://yuanblq.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>排序算法-插入排序</title>
    <link href="https://yuanblq.github.io/2017/07/03/insertion-sort/"/>
    <id>https://yuanblq.github.io/2017/07/03/insertion-sort/</id>
    <published>2017-07-02T17:15:11.000Z</published>
    <updated>2017-09-03T15:00:32.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对于少量元素的排序，插入排序算是一个比较有效的算法。</p>
<p>它的执行流程和打扑克摸牌时候的插牌差不多。</p>
<p><img src="/2017/07/03/insertion-sort/2-1.png" alt="使用插入排序来排序手中扑克牌"></p>
<p>打扑克插牌的时候，首先手上没有牌，从桌上扣着的牌里不断抓取。每抓一张牌，都会与手中已有的牌进行比对，然后插入合适的位置。</p>
<a id="more"></a>
<p>上面的流程，可以用 Python 的伪代码这么表示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># A 为总共可以抓取的扑克牌数，四人斗地主的话，即 25 张牌</span></div><div class="line"><span class="comment"># 因为从第 2 次抓牌开始，才算进行真正的排序</span></div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">2</span>, len(A)]:</div><div class="line">    <span class="comment"># poke 为当前抓取的牌</span></div><div class="line">    poke = A[j]</div><div class="line">    <span class="comment"># 把当前抓到的牌插入之前已经排序好的牌中</span></div><div class="line">    <span class="comment"># 即，将 A[j] 插在 A[1..j-1] 的合适位置</span></div><div class="line">    <span class="comment"># 假设从小到大排序</span></div><div class="line">    <span class="comment"># 从当前牌的最后一张开始比对，如果比当前牌大，就调个个</span></div><div class="line">    i = j - <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; poke:</div><div class="line">        A[i+<span class="number">1</span>] = A[i]</div><div class="line">        i = i - <span class="number">1</span></div><div class="line">    <span class="comment"># 真正的插入操作 =&gt; 将抓取的牌，插在合适的位置</span></div><div class="line">    A[i+<span class="number">1</span>] = poke</div></pre></td></tr></table></figure></p>
<p>在 for 循环中，每次迭代开始的时候，A[1, j-1] 总是已经排好序的牌，这个特性叫做循环不变式。</p>
<p>下图表明了对于 A=[5, 2, 4, 6, 1, 3] 该算法如何工作的：</p>
<p><img src="/2017/07/03/insertion-sort/2-2.png" alt="插入排序工作原理"></p>
<p>循环不变式主要用来帮助我们理解算法的正确性。关于循环不变式，我们必须证明三条性质：</p>
<ul>
<li><strong>初始化：</strong>循环的第一次迭代之前，它为真。</li>
<li><strong>保持：</strong>如果循环在某次开始前它为真，那么下次迭代开始之前，他也为真。</li>
<li><strong>终止：</strong>在循环结束的时候，不变式所提供的特性仍未改变，该特性有助于证明算法是正确的。</li>
</ul>
<p>以下是用 Python 完整实现的代码，仅供参考：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>]</div><div class="line">A</div></pre></td></tr></table></figure>
<pre><code>[5, 2, 4, 6, 1, 3]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort1</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</div><div class="line">        poke = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; poke:</div><div class="line">            A[i], A[i+<span class="number">1</span>] = A[i+<span class="number">1</span>], A[i]</div><div class="line">            i -= <span class="number">1</span></div><div class="line">        A[i+<span class="number">1</span>] = poke</div><div class="line">    <span class="keyword">return</span> A</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(insertion_sort1(A))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre><p>如果将插入数据和搜索数据合并到一起操作，那么代码就变成这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort2</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(A)):</div><div class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i<span class="number">-1</span>] &gt; A[i]:</div><div class="line">            A[i<span class="number">-1</span>], A[i] = A[i], A[i<span class="number">-1</span>]</div><div class="line">            i -= <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> A</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(insertion_sort2(A))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6]
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h2&gt;&lt;p&gt;对于少量元素的排序，插入排序算是一个比较有效的算法。&lt;/p&gt;
&lt;p&gt;它的执行流程和打扑克摸牌时候的插牌差不多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2017/07/03/insertion-sort/2-1.png&quot; alt=&quot;使用插入排序来排序手中扑克牌&quot;&gt;&lt;/p&gt;
&lt;p&gt;打扑克插牌的时候，首先手上没有牌，从桌上扣着的牌里不断抓取。每抓一张牌，都会与手中已有的牌进行比对，然后插入合适的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="小练习" scheme="https://yuanblq.github.io/categories/%E5%B0%8F%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Algorithms" scheme="https://yuanblq.github.io/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>名人的颜值有多高？</title>
    <link href="https://yuanblq.github.io/2017/06/22/%E5%90%8D%E4%BA%BA%E7%9A%84%E9%A2%9C%E5%80%BC%E6%9C%89%E5%A4%9A%E9%AB%98%EF%BC%9F/"/>
    <id>https://yuanblq.github.io/2017/06/22/名人的颜值有多高？/</id>
    <published>2017-06-22T14:22:37.000Z</published>
    <updated>2017-09-04T04:32:34.094Z</updated>
    
    <content type="html"><![CDATA[<p>玩弄微软小冰的时候发现有个颜值查询功能，作为一枚颜值正无穷的帅比简直高处不胜寒。<br>后来突发奇想：是不是要想被人民群众记住，不仅仅要有才华，而且颜值也必须得高？</p>
<a id="more"></a>
<p>通过抓取百度百科里面的500多位艺术家信息，传给微软小冰评分后得出如下的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">(&apos;安德里亚·阿诺德&apos;, &apos;9.5&apos;), (&apos;许翰英&apos;, &apos;9.4&apos;), (&apos;李国静&apos;, &apos;8.9&apos;), (&apos;让·维果&apos;, &apos;8.8&apos;),</div><div class="line"> (&apos;斯潘塞·图尼克&apos;, &apos;8.7&apos;), (&apos;缪晓铮&apos;, &apos;8.6&apos;), (&apos;叶福海&apos;, &apos;8.5&apos;), (&apos;李吉瑞&apos;, &apos;8.5&apos;),</div><div class="line"> (&apos;刘翠霞&apos;, &apos;8.5&apos;), (&apos;亨利·金&apos;, &apos;8.4&apos;), (&apos;谢冬雪&apos;, &apos;8.4&apos;), (&apos;孟科娟&apos;, &apos;8.3&apos;),</div><div class="line"> (&apos;白淑贤&apos;, &apos;8.3&apos;), (&apos;King Crimson&apos;, &apos;8.3&apos;), (&apos;魏景山&apos;, &apos;8.2&apos;), (&apos;李壬林&apos;, &apos;8.2&apos;),</div><div class="line"> (&apos;赵庭景美&apos;, &apos;8.1&apos;), (&apos;侯宗辰&apos;, &apos;8.1&apos;), (&apos;章遏云&apos;, &apos;8.1&apos;), (&apos;安波&apos;, &apos;8.0&apos;),</div><div class="line"> (&apos;黎灼灼&apos;, &apos;8.0&apos;), (&apos;杜吉刚&apos;, &apos;8.0&apos;), (&apos;王少舫&apos;, &apos;8.0&apos;), (&apos;张映哲&apos;, &apos;8.0&apos;),</div><div class="line"> (&apos;玛丽·布莱尔&apos;, &apos;7.9&apos;), (&apos;赫伯特·克格尔&apos;, &apos;7.9&apos;), (&apos;路易·德·菲耐斯&apos;, &apos;7.9&apos;), (&apos;张伐&apos;, &apos;7.8&apos;),</div><div class="line"> (&apos;朱端钧&apos;, &apos;7.8&apos;), (&apos;王泉奎&apos;, &apos;7.8&apos;), (&apos;朱利安·施纳贝尔&apos;, &apos;7.8&apos;), (&apos;石筱英&apos;, &apos;7.7&apos;),</div><div class="line"> (&apos;沈冠初&apos;, &apos;7.7&apos;), (&apos;潘亚文&apos;, &apos;7.7&apos;), (&apos;买鸿钧&apos;, &apos;7.7&apos;), (&apos;启骧&apos;, &apos;7.7&apos;),</div><div class="line"> (&apos;刘令华&apos;, &apos;7.6&apos;), (&apos;张荣培&apos;, &apos;7.6&apos;), (&apos;林忠&apos;, &apos;7.6&apos;), (&apos;胡安·格里斯&apos;, &apos;7.6&apos;),</div><div class="line"> (&apos;于万增&apos;, &apos;7.6&apos;), (&apos;邱霁&apos;, &apos;7.6&apos;), (&apos;王梦云&apos;, &apos;7.5&apos;), (&apos;贾堂霞&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;曾妮&apos;, &apos;7.5&apos;), (&apos;詹泽&apos;, &apos;7.5&apos;), (&apos;刘中华&apos;, &apos;7.5&apos;), (&apos;郑硕希&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;丁辰&apos;, &apos;7.5&apos;), (&apos;庄学本&apos;, &apos;7.5&apos;), (&apos;沙蒙&apos;, &apos;7.5&apos;), (&apos;史蒂芬·戴德利&apos;, &apos;7.5&apos;),</div><div class="line"> (&apos;江其虎&apos;, &apos;7.5&apos;), (&apos;张书范&apos;, &apos;7.5&apos;), (&apos;康斯特布尔&apos;, &apos;7.5&apos;), (&apos;钱杏邨&apos;, &apos;7.4&apos;),</div><div class="line"> (&apos;李帆&apos;, &apos;7.4&apos;), (&apos;陆小雅&apos;, &apos;7.4&apos;), (&apos;陈富瑞&apos;, &apos;7.4&apos;), (&apos;万俊彦&apos;, &apos;7.3&apos;),</div><div class="line"> (&apos;李雪峰&apos;, &apos;7.3&apos;), (&apos;胡仙&apos;, &apos;7.3&apos;), (&apos;武兆堤&apos;, &apos;7.3&apos;), (&apos;庚斯博罗&apos;, &apos;7.3&apos;),</div><div class="line"> (&apos;郑天任&apos;, &apos;7.2&apos;), (&apos;新罗山人&apos;, &apos;7.2&apos;), (&apos;让·奥诺雷·弗拉贡纳尔&apos;, &apos;7.2&apos;), (&apos;倪华&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;吴晓明&apos;, &apos;7.2&apos;), (&apos;汪燕燕&apos;, &apos;7.2&apos;), (&apos;林景亮&apos;, &apos;7.2&apos;), (&apos;朱桂芳&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;龙行&apos;, &apos;7.2&apos;), (&apos;丁力&apos;, &apos;7.2&apos;), (&apos;海兹&apos;, &apos;7.2&apos;), (&apos;柳新生&apos;, &apos;7.2&apos;),</div><div class="line"> (&apos;李瑞芳&apos;, &apos;7.2&apos;), (&apos;王凤卿&apos;, &apos;7.2&apos;), (&apos;阮兆辉&apos;, &apos;7.2&apos;), (&apos;吴宗锡&apos;, &apos;7.1&apos;),</div><div class="line"> (&apos;刘双印&apos;, &apos;7.1&apos;), (&apos;陈炳熙&apos;, &apos;7.1&apos;), (&apos;普皮·阿瓦蒂&apos;, &apos;7.1&apos;), (&apos;潘璟琍&apos;, &apos;7.1&apos;),</div><div class="line"> (&apos;曾山东&apos;, &apos;7.1&apos;), (&apos;邹为瑞&apos;, &apos;7.1&apos;), (&apos;李素雅&apos;, &apos;7.0&apos;), (&apos;卡尔·德莱叶&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;周锦堂&apos;, &apos;7.0&apos;), (&apos;罗伯特·劳森伯格&apos;, &apos;7.0&apos;), (&apos;侯永奎&apos;, &apos;7.0&apos;), (&apos;夏川&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;郭惠兰&apos;, &apos;7.0&apos;), (&apos;尼克·德雷克&apos;, &apos;7.0&apos;), (&apos;亚历山大·康斯坦丁诺维奇·格拉祖诺夫&apos;, &apos;7.0&apos;), (&apos;胡海涛&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;瞿同祖&apos;, &apos;7.0&apos;), (&apos;许磊然&apos;, &apos;7.0&apos;), (&apos;陶白莉&apos;, &apos;7.0&apos;), (&apos;蔡龙云&apos;, &apos;7.0&apos;),</div><div class="line"> (&apos;朱崇懋&apos;, &apos;7.0&apos;), (&apos;费之雄&apos;, &apos;7.0&apos;), (&apos;齐花坦&apos;, &apos;7.0&apos;), (&apos;辛沪光&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;黄虎威&apos;, &apos;6.9&apos;), (&apos;戈雅&apos;, &apos;6.9&apos;), (&apos;陈士和&apos;, &apos;6.9&apos;), (&apos;李东风&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;黄庆云&apos;, &apos;6.9&apos;), (&apos;刘江川&apos;, &apos;6.9&apos;), (&apos;刘广迎&apos;, &apos;6.9&apos;), (&apos;戴月琴&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;田纬钤&apos;, &apos;6.9&apos;), (&apos;杨和平&apos;, &apos;6.9&apos;), (&apos;马桂芬&apos;, &apos;6.9&apos;), (&apos;陈一&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;赵维莉&apos;, &apos;6.9&apos;), (&apos;杨隆寿&apos;, &apos;6.9&apos;), (&apos;黄准&apos;, &apos;6.9&apos;), (&apos;于俊波&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;李绪洪&apos;, &apos;6.9&apos;), (&apos;钟荣&apos;, &apos;6.9&apos;), (&apos;李家载&apos;, &apos;6.9&apos;), (&apos;拉斐尔·圣齐奥&apos;, &apos;6.9&apos;),</div><div class="line"> (&apos;佟长江&apos;, &apos;6.9&apos;), (&apos;尼古拉斯·卡洛维奇·梅特纳&apos;, &apos;6.9&apos;), (&apos;程玉菁&apos;, &apos;6.9&apos;), (&apos;查国钧&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;金开诚&apos;, &apos;6.8&apos;), (&apos;爱杜尔·马奈&apos;, &apos;6.8&apos;), (&apos;李延洲&apos;, &apos;6.8&apos;), (&apos;梁京武&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;尚游&apos;, &apos;6.8&apos;), (&apos;孙正阳&apos;, &apos;6.8&apos;), (&apos;康成元&apos;, &apos;6.8&apos;), (&apos;张少华&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;阿尔希波夫&apos;, &apos;6.8&apos;), (&apos;范雪朋&apos;, &apos;6.8&apos;), (&apos;梅熹&apos;, &apos;6.8&apos;), (&apos;胡朋&apos;, &apos;6.8&apos;),</div><div class="line"> (&apos;孟令云&apos;, &apos;6.8&apos;), (&apos;林耀光&apos;, &apos;6.8&apos;), (&apos;夏星&apos;, &apos;6.8&apos;), (&apos;徐正濂&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;宗其香&apos;, &apos;6.7&apos;), (&apos;张藜&apos;, &apos;6.7&apos;), (&apos;郑在石&apos;, &apos;6.7&apos;), (&apos;何迟&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;贯大元&apos;, &apos;6.7&apos;), (&apos;牟炫甫&apos;, &apos;6.7&apos;), (&apos;曹致友&apos;, &apos;6.7&apos;), (&apos;王开方&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;孙恩道&apos;, &apos;6.7&apos;), (&apos;马克辛&apos;, &apos;6.7&apos;), (&apos;孙佰钧&apos;, &apos;6.7&apos;), (&apos;康丁斯基&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;娄际成&apos;, &apos;6.7&apos;), (&apos;区志航&apos;, &apos;6.7&apos;), (&apos;刘云厚&apos;, &apos;6.7&apos;), (&apos;岑范&apos;, &apos;6.7&apos;),</div><div class="line"> (&apos;赵汝平&apos;, &apos;6.6&apos;), (&apos;佩佩·罗梅罗&apos;, &apos;6.6&apos;), (&apos;维拉斯奎兹&apos;, &apos;6.6&apos;), (&apos;雨农&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;吴兆南&apos;, &apos;6.6&apos;), (&apos;风雨同仁堂&apos;, &apos;6.6&apos;), (&apos;施本铭&apos;, &apos;6.6&apos;), (&apos;郝寿臣&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;赵开坤&apos;, &apos;6.6&apos;), (&apos;杭子和&apos;, &apos;6.6&apos;), (&apos;雅克·塔蒂&apos;, &apos;6.6&apos;), (&apos;尤金·奥曼迪&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;汪更新&apos;, &apos;6.6&apos;), (&apos;秦咏诚&apos;, &apos;6.6&apos;), (&apos;夏之秋&apos;, &apos;6.6&apos;), (&apos;洪磊&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;韩文中&apos;, &apos;6.6&apos;), (&apos;樊其辉&apos;, &apos;6.6&apos;), (&apos;张咏梅&apos;, &apos;6.6&apos;), (&apos;吴钊&apos;, &apos;6.6&apos;),</div><div class="line"> (&apos;冯梦波&apos;, &apos;6.6&apos;), (&apos;秦斌&apos;, &apos;6.6&apos;), (&apos;马云涛&apos;, &apos;6.5&apos;), (&apos;德弗乍克&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;旺忘望&apos;, &apos;6.5&apos;), (&apos;吴膺群&apos;, &apos;6.5&apos;), (&apos;李金凤&apos;, &apos;6.5&apos;), (&apos;廖辅叔&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;钟知一&apos;, &apos;6.5&apos;), (&apos;格哈德·里希特&apos;, &apos;6.5&apos;), (&apos;远藤实&apos;, &apos;6.5&apos;), (&apos;高保成&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;冯欣蕊&apos;, &apos;6.5&apos;), (&apos;萧盛萱&apos;, &apos;6.5&apos;), (&apos;甘特·萨克斯&apos;, &apos;6.5&apos;), (&apos;丁士青&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;张天志&apos;, &apos;6.5&apos;), (&apos;程熙&apos;, &apos;6.5&apos;), (&apos;艾伦·李&apos;, &apos;6.5&apos;), (&apos;梁小鸾&apos;, &apos;6.5&apos;),</div><div class="line"> (&apos;杨成兴&apos;, &apos;6.5&apos;), (&apos;爱德华·霍珀&apos;, &apos;6.5&apos;), (&apos;江和平&apos;, &apos;6.5&apos;), (&apos;李京盛&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;罗品超&apos;, &apos;6.4&apos;), (&apos;吴子复&apos;, &apos;6.4&apos;), (&apos;冷冰&apos;, &apos;6.4&apos;), (&apos;简庆福&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;罗伟&apos;, &apos;6.4&apos;), (&apos;曾竹韶&apos;, &apos;6.4&apos;), (&apos;蒲伯英&apos;, &apos;6.4&apos;), (&apos;马俊子&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;王晋元&apos;, &apos;6.4&apos;), (&apos;石少华&apos;, &apos;6.4&apos;), (&apos;王苏娅&apos;, &apos;6.4&apos;), (&apos;宋文元&apos;, &apos;6.4&apos;),</div><div class="line"> (&apos;张佩&apos;, &apos;6.4&apos;), (&apos;吴子熊&apos;, &apos;6.4&apos;), (&apos;韩中杰&apos;, &apos;6.3&apos;), (&apos;迭戈·里维拉&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;清冈纯子&apos;, &apos;6.3&apos;), (&apos;潘利国&apos;, &apos;6.3&apos;), (&apos;吕品昌&apos;, &apos;6.3&apos;), (&apos;黄绍芬&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;路易·卢米埃尔&apos;, &apos;6.3&apos;), (&apos;蒋碧微&apos;, &apos;6.3&apos;), (&apos;王西彦&apos;, &apos;6.3&apos;), (&apos;周正荣&apos;, &apos;6.3&apos;),</div><div class="line"> (&apos;李林峰&apos;, &apos;6.3&apos;), (&apos;雷开元&apos;, &apos;6.3&apos;), (&apos;华兰&apos;, &apos;6.3&apos;), (&apos;侯一波&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;陈云岗&apos;, &apos;6.2&apos;), (&apos;刘育熙&apos;, &apos;6.2&apos;), (&apos;杨振雄&apos;, &apos;6.2&apos;), (&apos;黄丰&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;陈锦芳&apos;, &apos;6.2&apos;), (&apos;谭建勋&apos;, &apos;6.2&apos;), (&apos;邱丽莉&apos;, &apos;6.2&apos;), (&apos;陈望衡&apos;, &apos;6.2&apos;),</div><div class="line"> (&apos;伦布兰特&apos;, &apos;6.2&apos;), (&apos;王向阳&apos;, &apos;6.2&apos;), (&apos;埃里克·罗麦尔&apos;, &apos;6.2&apos;), (&apos;于光华&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;唐柯&apos;, &apos;6.1&apos;), (&apos;张方明&apos;, &apos;6.1&apos;), (&apos;程继先&apos;, &apos;6.1&apos;), (&apos;叶楠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;解国平&apos;, &apos;6.1&apos;), (&apos;田春鸟&apos;, &apos;6.1&apos;), (&apos;陈云诰&apos;, &apos;6.1&apos;), (&apos;朱仲禄&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;汝龙&apos;, &apos;6.1&apos;), (&apos;燕守谷&apos;, &apos;6.1&apos;), (&apos;史晶歆&apos;, &apos;6.1&apos;), (&apos;丁荫楠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;王舜来&apos;, &apos;6.1&apos;), (&apos;袁一灵&apos;, &apos;6.1&apos;), (&apos;陈笑风&apos;, &apos;6.1&apos;), (&apos;赵建忠&apos;, &apos;6.1&apos;),</div><div class="line"> (&apos;刘金彪&apos;, &apos;6.1&apos;), (&apos;许幸之&apos;, &apos;6.1&apos;), (&apos;林子杰&apos;, &apos;6.0&apos;), (&apos;马少宣&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;阿道夫·门采尔&apos;, &apos;6.0&apos;), (&apos;鲜灵霞&apos;, &apos;6.0&apos;), (&apos;崔占一&apos;, &apos;6.0&apos;), (&apos;叶竹盛&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;王沂暖&apos;, &apos;6.0&apos;), (&apos;王天华&apos;, &apos;6.0&apos;), (&apos;薛建波&apos;, &apos;6.0&apos;), (&apos;温可铮&apos;, &apos;6.0&apos;),</div><div class="line"> (&apos;黄荣&apos;, &apos;5.9&apos;), (&apos;张安邦&apos;, &apos;5.9&apos;), (&apos;景荣庆&apos;, &apos;5.9&apos;), (&apos;周来&apos;, &apos;5.9&apos;),</div><div class="line"> (&apos;马明&apos;, &apos;5.9&apos;), (&apos;魏光庆&apos;, &apos;5.9&apos;), (&apos;司徒安&apos;, &apos;5.9&apos;), (&apos;路易齐·波凯里尼&apos;, &apos;5.9&apos;),</div><div class="line"> (&apos;张子康&apos;, &apos;5.9&apos;), (&apos;侯长喜&apos;, &apos;5.8&apos;), (&apos;曾俊逸&apos;, &apos;5.8&apos;), (&apos;魏荣元&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;杨志淳&apos;, &apos;5.8&apos;), (&apos;李苦寒&apos;, &apos;5.8&apos;), (&apos;彭薇&apos;, &apos;5.8&apos;), (&apos;赵焕章&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;郭春山&apos;, &apos;5.8&apos;), (&apos;埃米尔·库斯图里卡&apos;, &apos;5.8&apos;), (&apos;胡文&apos;, &apos;5.8&apos;), (&apos;朱宪民&apos;, &apos;5.8&apos;),</div><div class="line"> (&apos;陈亚莲&apos;, &apos;5.7&apos;), (&apos;吴志辉&apos;, &apos;5.7&apos;), (&apos;张广志&apos;, &apos;5.7&apos;), (&apos;土登&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;李晓梅&apos;, &apos;5.7&apos;), (&apos;刘正亮&apos;, &apos;5.7&apos;), (&apos;李味青&apos;, &apos;5.7&apos;), (&apos;小岚云&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;刘文清&apos;, &apos;5.7&apos;), (&apos;李志明&apos;, &apos;5.7&apos;), (&apos;张越男&apos;, &apos;5.7&apos;), (&apos;细江英公&apos;, &apos;5.7&apos;),</div><div class="line"> (&apos;赵大地&apos;, &apos;5.7&apos;), (&apos;周中华&apos;, &apos;5.6&apos;), (&apos;黄里&apos;, &apos;5.6&apos;), (&apos;吴国松&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;陈志清&apos;, &apos;5.6&apos;), (&apos;赵和平&apos;, &apos;5.6&apos;), (&apos;杨希雪&apos;, &apos;5.6&apos;), (&apos;严雪亭&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;许娜&apos;, &apos;5.6&apos;), (&apos;清水裕子&apos;, &apos;5.6&apos;), (&apos;袁克平&apos;, &apos;5.6&apos;), (&apos;钱妙花&apos;, &apos;5.6&apos;),</div><div class="line"> (&apos;卢雅文&apos;, &apos;5.5&apos;), (&apos;萧润德&apos;, &apos;5.5&apos;), (&apos;袁淑梅&apos;, &apos;5.5&apos;), (&apos;李荣威&apos;, &apos;5.5&apos;),</div><div class="line"> (&apos;黄汉&apos;, &apos;5.4&apos;), (&apos;俞金喜&apos;, &apos;5.4&apos;), (&apos;周企何&apos;, &apos;5.4&apos;), (&apos;黄鹤&apos;, &apos;5.3&apos;),</div><div class="line"> (&apos;张松林&apos;, &apos;5.3&apos;), (&apos;杨少斌&apos;, &apos;5.2&apos;), (&apos;沈西蒙&apos;, &apos;5.2&apos;), (&apos;侯月秋&apos;, &apos;5.2&apos;),</div><div class="line"> (&apos;徐小香&apos;, &apos;5.2&apos;), (&apos;李鑫荃&apos;, &apos;5.2&apos;), (&apos;刘改鱼&apos;, &apos;5.2&apos;), (&apos;姬鹤武&apos;, &apos;5.2&apos;),</div><div class="line"> (&apos;李岱江&apos;, &apos;5.2&apos;), (&apos;水禾田&apos;, &apos;5.1&apos;), (&apos;姚金芬&apos;, &apos;5.1&apos;), (&apos;兹德齐斯洛·贝克辛斯基&apos;, &apos;5.1&apos;),</div><div class="line"> (&apos;李开敏&apos;, &apos;5.0&apos;), (&apos;乔慷慨&apos;, &apos;5.0&apos;), (&apos;时宜&apos;, &apos;5.0&apos;), (&apos;李克寒&apos;, &apos;5.0&apos;),</div><div class="line"> (&apos;欧有才&apos;, &apos;4.9&apos;), (&apos;张义潜&apos;, &apos;4.9&apos;), (&apos;白沉&apos;, &apos;4.9&apos;), (&apos;张猛&apos;, &apos;4.9&apos;),</div><div class="line"> (&apos;荷加斯&apos;, &apos;4.9&apos;), (&apos;尤无曲&apos;, &apos;4.9&apos;), (&apos;刘福安&apos;, &apos;4.9&apos;), (&apos;刘延广&apos;, &apos;4.8&apos;),</div><div class="line"> (&apos;吴养木&apos;, &apos;4.8&apos;), (&apos;靳景祥&apos;, &apos;4.8&apos;), (&apos;田桂凤&apos;, &apos;4.8&apos;), (&apos;李洲&apos;, &apos;4.7&apos;),</div><div class="line"> (&apos;陈永玲&apos;, &apos;4.7&apos;), (&apos;尹小芳&apos;, &apos;3.9&apos;), (&apos;黄泉福&apos;, &apos;3.4&apos;), (&apos;胡晓平&apos;, &apos;2.1&apos;),</div><div class="line"> (&apos;筱桂花&apos;, &apos;2.0&apos;)</div></pre></td></tr></table></figure>
<p>在小冰眼里</p>
<p>长得最好看的是这样的：<br><img src="/2017/06/22/名人的颜值有多高？/640.png" alt="png"></p>
<p>还有这样的:<br><img src="/2017/06/22/名人的颜值有多高？/650.png" alt="png"></p>
<p>颜值低的是这样的<br><img src="/2017/06/22/名人的颜值有多高？/660.png" alt="png"></p>
<p>显然，小冰的识别系统是有问题的。巨硬爸爸还需努力啊！</p>
<p>最后简单总结一下：颜值5.0分以下的只占了4%，虽说小冰的识别系统有些地方还需改善，但是对于正常的图片来说，识别率还是很靠谱的。嗯，现实就是这么“残酷”，一直都是“看脸”的时代。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;玩弄微软小冰的时候发现有个颜值查询功能，作为一枚颜值正无穷的帅比简直高处不胜寒。&lt;br&gt;后来突发奇想：是不是要想被人民群众记住，不仅仅要有才华，而且颜值也必须得高？&lt;/p&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://yuanblq.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Django表单验证</title>
    <link href="https://yuanblq.github.io/2017/06/09/Django%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/"/>
    <id>https://yuanblq.github.io/2017/06/09/Django表单验证/</id>
    <published>2017-06-09T10:41:07.000Z</published>
    <updated>2017-09-03T15:01:37.666Z</updated>
    
    <content type="html"><![CDATA[<p>Django 的表单在调用 <code>is_valid()</code>、<code>errors</code>属性、<code>full_clean()</code> 时会对表单进行验证。</p>
<p>以上行为都有可能抛出 <code>ValidationError</code> 异常。如果每异常则会返回经过验证的正常 Python 对象。</p>
<a id="more"></a>
<h3 id="大多数的验证可以通过-validators-实现。"><a href="#大多数的验证可以通过-validators-实现。" class="headerlink" title="大多数的验证可以通过 validators 实现。"></a>大多数的验证可以通过 <code>validators</code> 实现。</h3><p><code>validators</code> 运行在字段的 <code>to_python()</code> 方法执行之后。</p>
<h3 id="对于一个表单的验证分为以下几步："><a href="#对于一个表单的验证分为以下几步：" class="headerlink" title="对于一个表单的验证分为以下几步："></a>对于一个表单的验证分为以下几步：</h3><h4 id="to-python-为任何验证的第一步。"><a href="#to-python-为任何验证的第一步。" class="headerlink" title="to_python 为任何验证的第一步。"></a><code>to_python</code> 为任何验证的第一步。</h4><p>该步验证的是数据的类型，数据类型不对则会抛出 <code>ValidationError</code> 异常。该方法接受的是表单部件的原始值。也就是说，如果该表单字段类型为 <code>FloatField</code>，那么该数据要么转成 Pyhton 的 <code>float</code> 要么抛出 <code>ValidationError</code> 异常。</p>
<h4 id="validate-方法，处理不适合用验证器验证的一些特定字段的验证。"><a href="#validate-方法，处理不适合用验证器验证的一些特定字段的验证。" class="headerlink" title="validate() 方法，处理不适合用验证器验证的一些特定字段的验证。"></a><code>validate()</code> 方法，处理不适合用验证器验证的一些特定字段的验证。</h4><p>该步验证接受已经被检验正确数据类型的值，接下来有任何错误的话，也会抛出 <code>ValidationError</code> 异常。该方法不反悔任何东西，所以不要修改传进来的值。该步就是用来处理你不能或不愿意在验证器里验证的一些验证逻辑</p>
<h4 id="run-validators-方法用来执行对应字段的所有验证器"><a href="#run-validators-方法用来执行对应字段的所有验证器" class="headerlink" title="run_validators()  方法用来执行对应字段的所有验证器"></a><code>run_validators()</code>  方法用来执行对应字段的所有验证器</h4><p>如果有异常抛出，则会把所有异常聚合成一个 <code>ValidationError</code> 异常抛出。该方法一般不应该重写。</p>
<h4 id="字段子类的-clean-负责以正确的顺序执行-to-python-，validate-，run-validators"><a href="#字段子类的-clean-负责以正确的顺序执行-to-python-，validate-，run-validators" class="headerlink" title="字段子类的 clean() 负责以正确的顺序执行 to_python()，validate()，run_validators()"></a>字段子类的 <code>clean()</code> 负责以正确的顺序执行 <code>to_python()</code>，<code>validate()</code>，<code>run_validators()</code></h4><p>该方法还会依次传递它们的错误信息。有一步发生异常，则会终止验证并抛出异常。该方法返回验证后的值，正确的值接下来会插入表单的 <code>cleaned_data</code> 字典。</p>
<h4 id="form-表单子类调用-clean-lt-fieldname-gt-方法"><a href="#form-表单子类调用-clean-lt-fieldname-gt-方法" class="headerlink" title="form 表单子类调用 clean_&lt;fieldname&gt;() 方法"></a><code>form</code> 表单子类调用 <code>clean_&lt;fieldname&gt;()</code> 方法</h4><p>该方法用来验证任何指定的属性，和字段的类型无关。该方法不传递任何参数，要想查字段的值，<code>self.cleaned_data</code> 中查找（这时候该变量为 Python 对象，因为已经经过通用的 <code>clean()</code> 方法处理过一次了。）</p>
<p>比如，你想验证名叫 <code>serialnumber</code> 的 <code>CharField</code> 的内容是否唯一。那么使用<code>clean_serialnumber()</code> 是最好的一个方法。该方法的返回值会替换掉原本在 <code>cleaned_data</code> 中的值。所以它必须是 <code>cleaned_data</code> 的一个字段值，或者一个新的验证过的值。</p>
<h4 id="表单子类的-clean-方法"><a href="#表单子类的-clean-方法" class="headerlink" title="表单子类的 clean() 方法"></a>表单子类的 <code>clean()</code> 方法</h4><p>该方法可以验证多字段的关系，比如可以验证“如果有 A 字段，那么 B 字段必须包含一个有效的邮箱地址”。该方法可以返回一个完全不同的字典，可以当成 <code>cleaned_data</code> 来用。</p>
<p>如果不是由特定字段（为 __all__字段）引起的异常，则可以通过 <code>non_field_errors()</code> 方法访问。如果想往特定字段添加错误信息可以使用 <code>add_error()</code>。</p>
<p>在重写 <code>ModelForm</code> 子类的 <code>clean()</code> 方法的时候还有一些其他注意事项，详情见 <a href="https://docs.djangoproject.com/en/1.11/topics/forms/modelforms/#overriding-modelform-clean-method" target="_blank" rel="external">ModelForm documentation</a></p>
<p>这些方法按上面指定的顺序执行。先验证表单中每个字段（按照它们在表单中定义的顺序），即 <code>field.clean()</code> 方法执行，然后执行 <code>clean_&lt;fieldname&gt;()</code> 方法，最后执行 <code>Form.clean()</code> 方法（无论前面字段验证过程有没有抛异常，表单验证都会进行）。</p>
<p>如果字段验证过程中，某一字段抛异常了，<code>clean_&lt;fieldname&gt;()</code> 不会再执行，而接下来的其他字段还是会接着执行。</p>
<h3 id="错误消息的编码风格"><a href="#错误消息的编码风格" class="headerlink" title="错误消息的编码风格"></a>错误消息的编码风格</h3><p>为了使错误信息灵活，方便改写，最好遵守一下规则：</p>
<ul>
<li>提供描述错误信息的 <code>code</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Good</span></div><div class="line">ValidationError(_(<span class="string">'Invalid value'</span>), code=<span class="string">'invalid'</span>)</div><div class="line"></div><div class="line"><span class="comment"># Bad</span></div><div class="line">ValidationError(_(<span class="string">'Invalid value'</span>))</div></pre></td></tr></table></figure>
<ul>
<li>不要在信息中传变量，使用 <code>params</code> 构造参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Good</span></div><div class="line">ValidationError(</div><div class="line">    _(<span class="string">'Invalid value: %(value)s'</span>),</div><div class="line">    params=&#123;<span class="string">'value'</span>: <span class="string">'42'</span>&#125;,</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># Bad</span></div><div class="line">ValidationError(_(<span class="string">'Invalid value: %s'</span>) % value)</div></pre></td></tr></table></figure>
<ul>
<li>使用关键字参数，而不是位置参数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Good</span></div><div class="line">ValidationError(</div><div class="line">    _(<span class="string">'Invalid value: %(value)s'</span>),</div><div class="line">    params=&#123;<span class="string">'value'</span>: <span class="string">'42'</span>&#125;,</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># Bad</span></div><div class="line">ValidationError(</div><div class="line">    _(<span class="string">'Invalid value: %s'</span>),</div><div class="line">    params=(<span class="string">'42'</span>,),</div><div class="line">)</div></pre></td></tr></table></figure>
<ul>
<li>使用 <code>gettext</code> 包裹消息，这样能使翻译生效</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Good</span></div><div class="line">ValidationError(_(<span class="string">'Invalid value'</span>))</div><div class="line"></div><div class="line"><span class="comment"># Bad</span></div><div class="line">ValidationError(<span class="string">'Invalid value'</span>)</div></pre></td></tr></table></figure>
<p>把这些合在一起，就长这样子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">raise</span> ValidationError(</div><div class="line">    _(<span class="string">'Invalid value: %(value)s'</span>),</div><div class="line">    code=<span class="string">'invalid'</span>,</div><div class="line">    params=&#123;<span class="string">'value'</span>: <span class="string">'42'</span>&#125;,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>但如果你在验证的最后一步或者你知道你永远也不会去重写错误消息，那么你可以像这样些简单点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ValidationError(_(<span class="string">'Invalid value: %s'</span>) % value)</div></pre></td></tr></table></figure></p>
<p><a href="https://docs.djangoproject.com/en/1.11/ref/forms/api/#django.forms.Form.errors.as_data" target="_blank" rel="external"><code>Form.errors.as_data()</code></a>，<a href="https://docs.djangoproject.com/en/1.11/ref/forms/api/#django.forms.Form.errors.as_json" target="_blank" rel="external"><code>Form.errors.as_json()</code></a> 这两个方法以各自不同的形式返回 <code>ValidationError</code>s 的所有错误信息。（以 <code>code</code> 名字为键名）</p>
<h3 id="抛出多重异常"><a href="#抛出多重异常" class="headerlink" title="抛出多重异常"></a>抛出多重异常</h3><p>当在一个 <code>clean</code> 方法中检测到多个错误，可以通过给 <code>ValidationError</code> 构造器传递一个错误信息的列表，以此返回给表单提交者。</p>
<p>按照上面的规范，传递错误列表建议这么写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Good</span></div><div class="line"><span class="keyword">raise</span> ValidationError([</div><div class="line">    ValidationError(_(<span class="string">'Error 1'</span>), code=<span class="string">'error1'</span>),</div><div class="line">    ValidationError(_(<span class="string">'Error 2'</span>), code=<span class="string">'error2'</span>),</div><div class="line">])</div><div class="line"></div><div class="line"><span class="comment"># Bad</span></div><div class="line"><span class="keyword">raise</span> ValidationError([</div><div class="line">    _(<span class="string">'Error 1'</span>),</div><div class="line">    _(<span class="string">'Error 2'</span>),</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h3 id="具体情况下如何使用"><a href="#具体情况下如何使用" class="headerlink" title="具体情况下如何使用"></a>具体情况下如何使用</h3><h4 id="使用验证器"><a href="#使用验证器" class="headerlink" title="使用验证器"></a>使用验证器</h4><p>Django <code>form</code> 表单（<code>model</code> 模型）字段支持使用一些简单的工具函数以及类作为验证器。</p>
<p>验证器仅仅是一个可调对象或者函数。接收一个值，如果值有效则不返回任何东西，否则抛 <code>ValidationError</code> 异常。</p>
<p>验证器可以直接传给字段构造器的 <code>validators</code> 参数，或者在该字段类中定义 <code>default_validators</code> 属性。</p>
<p>比方说 Django 的 <code>SlugField</code> 字段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.forms <span class="keyword">import</span> CharField</div><div class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> validators</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlugField</span><span class="params">(CharField)</span>:</span></div><div class="line">    default_validators = [validators.validate_slug]</div></pre></td></tr></table></figure></p>
<p>正如你所见的，<code>SlugField</code> 仅仅是一个带有自定义验证器的 <code>CharField</code> 字段，该验证器检测提交的文本是否遵守某些规则。这样在字段定义的时候这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slug = forms.SlugField()</div></pre></td></tr></table></figure>
<p>上面的写法等同于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slug = forms.CharField(validators=[validators.validate_slug])</div></pre></td></tr></table></figure>
<p><a href="https://docs.djangoproject.com/en/1.11/ref/validators/" target="_blank" rel="external">点我</a> 查看 Django 内置的一些验证器以及如何自定义验证器</p>
<h4 id="表单字段的默认验证"><a href="#表单字段的默认验证" class="headerlink" title="表单字段的默认验证"></a>表单字段的默认验证</h4><p>我们来看下怎样验证提交的表单中的字符串是否包含逗号分隔的邮箱地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</div><div class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> validate_email</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiEmailField</span><span class="params">(forms.Field)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_python</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="string">"""Normalize data to a list of strings."""</span></div><div class="line">        <span class="comment"># Return an empty list if no input was given.</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> value:</div><div class="line">            <span class="keyword">return</span> []</div><div class="line">        <span class="keyword">return</span> value.split(<span class="string">','</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, value)</span>:</span></div><div class="line">        <span class="string">"""Check if value consists only of valid emails."""</span></div><div class="line">        <span class="comment"># Use the parent's handling of required fields, etc.</span></div><div class="line">        <span class="comment"># 重写父类方法，实现我们多邮箱表单的验证效果</span></div><div class="line">        super(MultiEmailField, self).validate(value)</div><div class="line">        <span class="keyword">for</span> email <span class="keyword">in</span> value:</div><div class="line">            validate_email(email)</div></pre></td></tr></table></figure>
<p>任何使用该字段的表单都会先经过这些方法，然后才进行后面的操作。</p>
<p>我们创建一个简单的 <code>ContactForm</code> 表单来演示下如何使用该字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(forms.Form)</span>:</span></div><div class="line">    subject = forms.CharField(max_length=<span class="number">100</span>)</div><div class="line">    message = forms.CharField()</div><div class="line">    sender = forms.EmailField()</div><div class="line">    recipients = MultiEmailField()</div><div class="line">    cc_myself = forms.BooleanField(required=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>使用的时候，就和其他字段一样。当表单调用 <code>is_valid()</code> 的时候，<code>MultiEmailField.clean()</code> 方法就会作为验证过程中的一环，依次调用我们自定义的 <code>to_python()</code> 和 <code>validate()</code> 方法来验证。</p>
<h4 id="验证特定字段属性"><a href="#验证特定字段属性" class="headerlink" title="验证特定字段属性"></a>验证特定字段属性</h4><p>还是以我们上面的 <code>ContactForm</code> 表单为例。我们想确保 <code>recipients</code> 字段必须包含 <code>fred@example.com</code> 这个邮箱地址。</p>
<p>因为我们只是需要当前这个表单有这个验证，而对于其他使用了 <code>MultiEmailField</code> 字段的表单无需此验证，那么我们就没必要把该验证放到 <code>MultiEmailField</code> 类中，最为一个通用验证。我们只需在 <code>ContactForm</code> 表单类中加上我们需要自定义的验证器即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(forms.Form)</span>:</span></div><div class="line">    <span class="comment"># Everything as before.</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean_recipients</span><span class="params">(self)</span>:</span></div><div class="line">        data = self.cleaned_data[<span class="string">'recipients'</span>]</div><div class="line">        <span class="keyword">if</span> <span class="string">"fred@example.com"</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</div><div class="line">            <span class="keyword">raise</span> forms.ValidationError(<span class="string">"You have forgotten about Fred!"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># Always return a value to use as the new cleaned data, even if</span></div><div class="line">        <span class="comment"># this method didn't change it.</span></div><div class="line">        <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<h4 id="验证相互依赖的字段"><a href="#验证相互依赖的字段" class="headerlink" title="验证相互依赖的字段"></a>验证相互依赖的字段</h4><p>假如，我们 <code>ContactForm</code> 表单中 <code>cc_myself</code> 为 <code>True</code>，那么 <code>subject</code> 字段必须包含 <code>help</code> 这个词。</p>
<p>当我们验证的时候，需要同时依赖多个字段，那么 <code>clean()</code> 方法绝对是个好帮手。</p>
<p>当表单的 <code>clean()</code> 方法调用的时候，会启用所有字段的 <code>clean()</code> 方法，所以，<code>self.cleaned_data</code> 能拿到目前所有“存活”着的数据，也就是说也有可能你的某些字段可能无法或者到达这一步的验证。</p>
<p>到这一步，一般有两种方法来反馈错误信息。其中最常用的是在表单的最上面显示错误信息。你可以在 <code>clean()</code> 方法中抛出 <code>ValidationError</code> 异常来创造这个错误信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(forms.Form)</span>:</span></div><div class="line">    <span class="comment"># Everything as before.</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></div><div class="line">        cleaned_data = super(ContactForm, self).clean()</div><div class="line">        cc_myself = cleaned_data.get(<span class="string">"cc_myself"</span>)</div><div class="line">        subject = cleaned_data.get(<span class="string">"subject"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> cc_myself <span class="keyword">and</span> subject:</div><div class="line">            <span class="comment"># Only do something if both fields are valid so far.</span></div><div class="line">            <span class="comment"># 只有当你想要验证的数据还“活着”的时候才进行接下来的验证</span></div><div class="line">            <span class="keyword">if</span> <span class="string">"help"</span> <span class="keyword">not</span> <span class="keyword">in</span> subject:</div><div class="line">                <span class="keyword">raise</span> forms.ValidationError(</div><div class="line">                    <span class="string">"Did not send for 'help' in the subject despite "</span></div><div class="line">                    <span class="string">"CC'ing yourself."</span></div><div class="line">                )</div></pre></td></tr></table></figure>
<p>以上代码，如果验证失败，表单会在它最上方显示一个错误信息。</p>
<p>代码中 <code>super(ContactForm, self).clean()</code> 是为了确保父类中的一些验证能有效执行。如果你表单继承的父类在它的 <code>clean()</code> 方法中不返回 <code>cleaned_data</code> 这个字典，那么就没必要让 <code>cleaned_data</code> 接收 <code>super()</code> 的返回值，直接使用 <code>self.cleanned_data</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></div><div class="line">    super(ContactForm, self).clean()</div><div class="line">    cc_myself = self.cleaned_data.get(<span class="string">"cc_myself"</span>)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>第二种反馈验证错误信息的方式，可能涉及给某些字段指定错误信息。在这个例子中，我们给 <code>subject</code> 和 <code>cc_myself</code> 字段都指定错误信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactForm</span><span class="params">(forms.Form)</span>:</span></div><div class="line">    <span class="comment"># Everything as before.</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></div><div class="line">        cleaned_data = super(ContactForm, self).clean()</div><div class="line">        cc_myself = cleaned_data.get(<span class="string">"cc_myself"</span>)</div><div class="line">        subject = cleaned_data.get(<span class="string">"subject"</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> cc_myself <span class="keyword">and</span> subject <span class="keyword">and</span> <span class="string">"help"</span> <span class="keyword">not</span> <span class="keyword">in</span> subject:</div><div class="line">            msg = <span class="string">"Must put 'help' in subject when cc'ing yourself."</span></div><div class="line">            self.add_error(<span class="string">'cc_myself'</span>, msg)</div><div class="line">            self.add_error(<span class="string">'subject'</span>, msg)</div></pre></td></tr></table></figure>
<p><code>add_error()</code> 的第二个参数，可以是一个简单的字符串，也可以是 <code>ValidationError</code> 的一个实例。详见 <a href="https://docs.djangoproject.com/en/1.11/ref/forms/validation/#raising-validation-error" target="_blank" rel="external">Raising ValidationError</a>。</p>
<p><strong>注意：</strong><code>add_error()</code> 会自动将这个字段从 <code>cleaned_data</code> 中移除。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django 的表单在调用 &lt;code&gt;is_valid()&lt;/code&gt;、&lt;code&gt;errors&lt;/code&gt;属性、&lt;code&gt;full_clean()&lt;/code&gt; 时会对表单进行验证。&lt;/p&gt;
&lt;p&gt;以上行为都有可能抛出 &lt;code&gt;ValidationError&lt;/code&gt; 异常。如果每异常则会返回经过验证的正常 Python 对象。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="https://yuanblq.github.io/categories/Django/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python 版本控制神器</title>
    <link href="https://yuanblq.github.io/2017/05/27/python-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%A5%9E%E5%99%A8/"/>
    <id>https://yuanblq.github.io/2017/05/27/python-版本控制神器/</id>
    <published>2017-05-27T08:26:32.000Z</published>
    <updated>2017-09-03T14:59:11.109Z</updated>
    
    <content type="html"><![CDATA[<p>由于 python 拥有众多的版本，以及不同模块也有不同的版本。如果每个版本之间相互都不兼容那也就无所谓什么版本控制了，可是同一机器上各个版本的 python 可以相互兼容并存，而且同一模块不同版本有时需要的 python 版本是不相同的，所以 python 的版本控制显得尤为重要。</p>
<p><code>pyenv</code> 是个 shell 脚本，能够轻松得实现各个不同版本 python 的相互间切换，而且各个版本的 python 切换不限于全局切换，甚至不同文件夹都可以拥有不同的 python 版本。</p>
<a id="more"></a>
<p>下面我们就来看看如何使用 <code>pyenv</code>。</p>
<h2 id="管理-python-版本"><a href="#管理-python-版本" class="headerlink" title="管理 python 版本"></a>管理 python 版本</h2><p>如果你既需要使用 <code>python2</code>，也需要使用 <code>python3</code>，<code>pyenv</code> 将是一个很高效的 python 版本管理工具。</p>
<p>由于 <code>pyenv</code> 是脚本插件，所以只能在类 UNIX 系统上使用。所以，如果你想在 windows 上安装，那就点击左上角去隔壁 <code>virtualenv</code> 瞧瞧。</p>
<h3 id="安装-pyenv（Ubuntu）"><a href="#安装-pyenv（Ubuntu）" class="headerlink" title="安装 pyenv（Ubuntu）"></a>安装 pyenv（Ubuntu）</h3><ol>
<li><p><strong>确定你想把 <code>pyenv</code> 安装在哪。</strong>推荐安装在 <code>$HOME/.pyenv</code>，但你也可以安装在任意位置。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/pyenv/pyenv.git ~/.pyenv</div></pre></td></tr></table></figure>
</li>
<li><p><strong>定义你 <code>PYENV_ROOT</code> 的环境变量</strong>来指定你把 pyenv 仓库克隆到了哪，并把 <code>$PYENV_ROOT/bin</code> 添加到你的 <code>$PATH</code> 中，这样就能在命令行使用 <code>pyenv</code> 命令。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&apos; &gt;&gt; ~/.bashrc</div><div class="line">$ echo &apos;export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p><strong>设置启动 shell 时自动加载 pyenv 脚本。</strong>在 shell 配置文件的最后面加上 <code>eval &quot;$(pyenv init -)&quot;</code>。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;eval &quot;$(pyenv init -)&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p><strong>重启 shell，使脚本生效。</strong>  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ exec $SHELL</div></pre></td></tr></table></figure>
</li>
<li><p><strong>安装不同的 python 版本到 <code>$(pyenv root)/versions</code> 文件夹。</strong><br> 在 <code>pyenv</code> 安装之前的所有 python 版本都归为 <code>system</code> 版本。 （可以用 <code>pyenv versions</code> 查看当前安装的 python 版本）<br> 在安装 python 之前，可以使用 <code>pyenv install -l</code> 查看当前可以安装哪些 python 版本。<br> 然后使用 <code>pyenv install 选择的版本</code> 来安装你所选择的 python 版本。比如 <code>pyenv install 3.6.1</code> 安装 python 官网的版本。  </p>
</li>
<li><p><strong>如果在安装 python 时报了如下错误，</strong>那就有可能是你的环境依赖没有装好，一般安装以下几个依赖就可以了。  </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 报错信息</div><div class="line">WARNING: The Python bz2 extension was not compiled. Missing the bzip2 lib</div><div class="line"></div><div class="line">WARNING: The Python readline extension was not compiled. Missing the GNU readline lib</div><div class="line"></div><div class="line">ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib</div></pre></td></tr></table></figure>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 安装以下依赖</div><div class="line">$ sudo apt-get install libbz2-dev</div><div class="line"></div><div class="line">$ sudo apt-get install libssl-dev</div><div class="line"></div><div class="line">$ sudo apt-get install libreadline6 libreadline6-dev</div><div class="line"></div><div class="line">$ sudo apt-get install libsqlite3-dev</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="使用-git-更新-pyenv"><a href="#使用-git-更新-pyenv" class="headerlink" title="使用 git 更新 pyenv"></a>使用 git 更新 pyenv</h3><p>如果你是按照上面的方法安装的 <code>pyenv</code>，那你可以使用 git 来更新。</p>
<h4 id="更新为最新的开发版"><a href="#更新为最新的开发版" class="headerlink" title="更新为最新的开发版"></a>更新为最新的开发版</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd $(pyenv root)</div><div class="line">$ git pull</div></pre></td></tr></table></figure>
<h4 id="更新为指定的版本"><a href="#更新为指定的版本" class="headerlink" title="更新为指定的版本"></a>更新为指定的版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ cd $(pyenv root)</div><div class="line">$ git fetch</div><div class="line">$ git tag</div><div class="line">v0.1.0</div><div class="line">$ git checkout v0.1.0</div></pre></td></tr></table></figure>
<h3 id="pyenv-的基本操作命令"><a href="#pyenv-的基本操作命令" class="headerlink" title="pyenv 的基本操作命令"></a>pyenv 的基本操作命令</h3><ul>
<li><code>pyenv versions</code> 查看当前已安装的 python 版本</li>
<li><code>pyenv install ...</code> 安装指定版本的 python</li>
<li><code>pyenv global python版本</code> 切换全局 python 版本</li>
<li><code>pyenv local python版本</code> 切换当前文件夹下的 python 版本</li>
<li><code>pyenv shell python版本</code> 切换当前 shell 中的 python 版本</li>
<li><code>pyenv version</code> 查看当前使用的 python 版本</li>
</ul>
<h3 id="卸载-pyenv"><a href="#卸载-pyenv" class="headerlink" title="卸载 pyenv"></a>卸载 pyenv</h3><ul>
<li>如果你只是想禁用 <code>pyenv</code>，那么把 <code>pyenv init</code> 从 shell 的配置文件中移除，然后重启 shell 就行了（移除后 <code>pyenv</code> 命令仍然能使用，但是版本切换命令不会生效）。  </li>
<li>完整卸载 pyenv。执行上一步，然后把 pyenv 的根目录删除即可全部删除 pyenv（通过 <code>pyenv install ...</code> 安装的 python 版本都会删除）。    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm -rf $(pyenv root)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="卸载-pyenv-安装的-python-版本"><a href="#卸载-pyenv-安装的-python-版本" class="headerlink" title="卸载 pyenv 安装的 python 版本"></a>卸载 pyenv 安装的 python 版本</h3><ul>
<li>使用 <code>pyenv uninstall ...</code> 命令。  </li>
<li>直接删除 <code>versions</code> 文件夹下的对应 python 版本文件夹。  </li>
</ul>
<h3 id="pyenv-其他操作命令"><a href="#pyenv-其他操作命令" class="headerlink" title="pyenv 其他操作命令"></a>pyenv 其他操作命令</h3><p>参见 <a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" target="_blank" rel="external">commands.md</a></p>
<p><br><br><br></p>
<h2 id="管理-python-模块版本"><a href="#管理-python-模块版本" class="headerlink" title="管理 python 模块版本"></a>管理 python 模块版本</h2><p>使用 <code>virtualenv</code> 和 <code>virtualenvwrapper</code> 管理 python 虚拟环境，每次都需要手动激活或退出。对于懒癌晚期患者，<code>pyenv-virtual</code> 的自动激活和退出虚拟环境功能简直不能再赞。另外搭配 <code>pyenv</code> 食用效果更佳。</p>
<h3 id="安装-pyenv-virtualenv（Ubuntu）"><a href="#安装-pyenv-virtualenv（Ubuntu）" class="headerlink" title="安装 pyenv-virtualenv（Ubuntu）"></a>安装 pyenv-virtualenv（Ubuntu）</h3><p>由于 <code>pyenv-virtualenv</code> 是 <code>pyenv</code> 的一个插件，所以安装之前需要先安装 <code>pyenv</code>。</p>
<p><strong>注意：</strong>如果 <code>pyenv</code> 的安装目录不是 <code>$HOME/.pyenv</code> 需要确保克隆下来的仓库位于你所安装的 <code>pyenv</code> 目录下的 <code>plugin</code> 文件夹下。</p>
<p>接下来就可以执行安装步骤了：</p>
<ol>
<li>克隆 <code>pyenv-virtual</code> 仓库到 <code>plugin</code> 文件夹下。</li>
<li><p>（可选/重点）添加 <code>pyenv virtualenv-init</code> 到你的 shell 配置文件中，这样进入指定文件夹自动进入虚拟环境，离开文件夹退出虚拟环境。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;eval &quot;$(pyenv virtualenv-init -)&quot;&apos; &gt;&gt; ~/.bashrc</div></pre></td></tr></table></figure>
</li>
<li><p>重启 shell。</p>
</li>
</ol>
<h3 id="创建-pyenv-virtualenv-虚拟环境"><a href="#创建-pyenv-virtualenv-虚拟环境" class="headerlink" title="创建 pyenv-virtualenv 虚拟环境"></a>创建 pyenv-virtualenv 虚拟环境</h3><ul>
<li><code>pyenv virtualenv 指定python版本 虚拟环境名字</code></li>
<li><code>pyenv virtualenv 虚拟环境名字</code></li>
</ul>
<p>如果不指定 python 版本，则默认使用当前 <code>pyenv version</code> 的 python 版本。</p>
<p>创建的虚拟环境位于 <code>$(pyenv root)/versions/</code> 下的指定 python 版本的文件夹中 <code>envs/</code> 文件夹下。</p>
<h3 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h3><ul>
<li>自动激活/退出</li>
<li>手动激活/退出</li>
</ul>
<p>自动激活环境：</p>
<ul>
<li>在 <code>.bashrc</code> 文件的最后添加 <code>eval &quot;$(pyenv virtualenv-init -)&quot;</code>，然后在 shell 中输入 <code>exec &quot;$SHELL&quot;</code> 重启 shell，或者手动重启 shell。</li>
<li>在想要激活虚拟环境的文件夹中新建 <code>.python-version</code> 文件，并写入虚拟环境的名字（<code>pyenv local python版本</code> 该命令也是通过创建该文件来达到进入该文件夹后自动使用指定 python 版本的目的）。</li>
<li>以后进入该的文件夹就会自动激活虚拟环境，离开该文件夹就会退出虚拟环境。</li>
</ul>
<p>手动激活环境：</p>
<ul>
<li><code>pyenv activate 虚拟环境名字</code> 激活虚拟环境。</li>
<li><code>pyenv deactivate</code> 退出虚拟环境。</li>
</ul>
<h3 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h3><p>有 2 种方法：  </p>
<ol>
<li>删除 <code>$(pyenv root)/versions</code> 和 <code>$(pyenv root)/versions/{version}/envs</code> 的相关文件夹即可。  </li>
<li>命令行运行 <code>pyenv uninstall 虚拟环境的名字</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于 python 拥有众多的版本，以及不同模块也有不同的版本。如果每个版本之间相互都不兼容那也就无所谓什么版本控制了，可是同一机器上各个版本的 python 可以相互兼容并存，而且同一模块不同版本有时需要的 python 版本是不相同的，所以 python 的版本控制显得尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pyenv&lt;/code&gt; 是个 shell 脚本，能够轻松得实现各个不同版本 python 的相互间切换，而且各个版本的 python 切换不限于全局切换，甚至不同文件夹都可以拥有不同的 python 版本。&lt;/p&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>itertools 模块解析</title>
    <link href="https://yuanblq.github.io/2017/05/21/itertools%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/"/>
    <id>https://yuanblq.github.io/2017/05/21/itertools模块解析/</id>
    <published>2017-05-21T11:32:55.000Z</published>
    <updated>2017-09-03T15:00:03.258Z</updated>
    
    <content type="html"><![CDATA[<p>python 的内建模块 <code>itertools</code> 提供了非常有用的用于操作可迭代对象的函数.<br>通过这些函数, 我们能更好更快的解决许多有关可迭代对象的问题.<br>对于这些函数, 大体分成三类来描述 :  </p>
<ul>
<li>组合产生器</li>
<li>无限迭代器</li>
<li>有限迭代器</li>
</ul>
<a id="more"></a>
<h2 id="组合产生器"><a href="#组合产生器" class="headerlink" title="组合产生器"></a>组合产生器</h2><h3 id="combinations"><a href="#combinations" class="headerlink" title="combinations"></a>combinations</h3><p><code>itertools.combinations</code> 允许你从一个可迭代对象中创建一个迭代器, 迭代中的元素长度相同.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</div><div class="line">c = combinations(<span class="string">'ABC'</span>, <span class="number">2</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;C&apos;)
</code></pre><p>运行上面的代码可见, <code>combinations()</code> 将一个可迭代对象重新组合成指定的几个元素长度, 并且是以元祖的方式返回.</p>
<p><strong>需要注意的是, 组合的元素是不重复的.</strong></p>
<p>通过 <code>join()</code> 方法, 可以将元祖内的元祖进行拼凑.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> combinations(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(<span class="string">''</span>.join(i))</div></pre></td></tr></table></figure>
<pre><code>AB
AC
BC
</code></pre><h3 id="combinations-with-replacement"><a href="#combinations-with-replacement" class="headerlink" title="combinations_with_replacement"></a>combinations_with_replacement</h3><p><code>combinations_with_replacement</code> 和 <code>combinations</code> 类似, 只不过它会创建重复的元素.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations_with_replacement</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;A&apos;)
(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;B&apos;)
(&apos;B&apos;, &apos;C&apos;)
(&apos;C&apos;, &apos;C&apos;)
</code></pre><p><strong>但是, 创建出来的组合是没有顺序的, 即 <code>AB</code> 和 <code>BA</code> 视为同一组合.</strong></p>
<h3 id="product"><a href="#product" class="headerlink" title="product"></a>product</h3><p><code>product</code> 迭代器从一系列的输入中创建笛卡儿积 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</div><div class="line">l = [(<span class="string">'A'</span>, <span class="string">'B'</span>), [<span class="number">1</span>, <span class="number">2</span>], (<span class="string">'w'</span>,)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> product(*l):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, 1, &apos;w&apos;)
(&apos;A&apos;, 2, &apos;w&apos;)
(&apos;B&apos;, 1, &apos;w&apos;)
(&apos;B&apos;, 2, &apos;w&apos;)
</code></pre><p>同样, 也是以元祖的形式返回.</p>
<h3 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h3><p><code>permutations</code> 和 <code>combinations</code> 很像, 只不过, <code>permutations</code> 是有排列顺序的, 即 <code>AB</code> 和 <code>BA</code> 是两个不同的组合.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> permutations(<span class="string">'ABC'</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;A&apos;, &apos;B&apos;)
(&apos;A&apos;, &apos;C&apos;)
(&apos;B&apos;, &apos;A&apos;)
(&apos;B&apos;, &apos;C&apos;)
(&apos;C&apos;, &apos;A&apos;)
(&apos;C&apos;, &apos;B&apos;)
</code></pre><p><strong>另外, <code>permutations</code> 同样是不会重复元素的.</strong></p>
<h2 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a>无限迭代器</h2><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p><code>count(start=0, step=1)</code>, count 迭代器从起始值开始, 按一定的步长, 生成一个能产生无限长度的迭代器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> count(start=<span class="number">10</span>, step=<span class="number">3</span>):</div><div class="line">    <span class="keyword">if</span> i == <span class="number">25</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>10
13
16
19
22
</code></pre><h3 id="islice"><a href="#islice" class="headerlink" title="islice"></a>islice</h3><p>一般无限迭代器可以和 <code>islice</code> 配合使用, 它能使无限迭代器在指定的次数后停止.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> islice</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> islice(count(<span class="number">3</span>, <span class="number">2</span>), <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>3
7
11
15
19
</code></pre><p><code>islice</code> 可以接受三个参数, 即 start, stop, step, 也可以只接收两个, 即 start, stop, 甚至也可以只接受一个参数, 即 stop.</p>
<h3 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> cycle</div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cycle([<span class="number">1</span>,<span class="number">2</span>]):</div><div class="line">    <span class="keyword">if</span> count &gt; <span class="number">5</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    print(i)</div><div class="line">    count += <span class="number">1</span></div></pre></td></tr></table></figure>
<pre><code>1
2
1
2
1
2
</code></pre><p><code>cycle</code> 接收一个参数, 它能生成接收参数的无限循环迭代器.</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p><code>repeat</code> 能够指定循环的次数, 但是它不像 <code>cycle</code> 能循环接受的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> repeat</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> repeat([<span class="number">1</span> ,<span class="number">2</span>], <span class="number">5</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>[1, 2]
[1, 2]
[1, 2]
[1, 2]
[1, 2]
</code></pre><h2 id="有限迭代器"><a href="#有限迭代器" class="headerlink" title="有限迭代器"></a>有限迭代器</h2><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p><code>accumulate</code> (Python3 中提供) 默认返回累加之和, 也可以传入自定义的函数.</p>
<p>例如, 传递 0-9 这个序列, 它会一次相加, 第一次是 0, 第二次是 0+1, 等等 …</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> accumulate</div><div class="line">list(accumulate(range(<span class="number">9</span>)))</div></pre></td></tr></table></figure>
<pre><code>[0, 1, 3, 6, 10, 15, 21, 28, 36]
</code></pre><p>我们也可以传入自定义的函数 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> operator</div><div class="line"></div><div class="line">list(accumulate(range(<span class="number">1</span>,<span class="number">5</span>), <span class="keyword">lambda</span> x,y : x*y))</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 6, 24]
</code></pre><h3 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">my_list = [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</div><div class="line">numbers = range(<span class="number">3</span>)</div><div class="line">cmd = (<span class="string">'ls'</span>, <span class="string">'/home'</span>)</div><div class="line">my_list.extend(numbers)</div><div class="line">my_list.extend(cmd)</div><div class="line">print(my_list)</div></pre></td></tr></table></figure>
<pre><code>[&apos;foo&apos;, &apos;bar&apos;, 0, 1, 2, &apos;ls&apos;, &apos;/home&apos;]
</code></pre><p>如上述代码, 我们能把多个可迭代对象进行融合, 但是 <code>extend()</code> 方法只能接受一个参数, 而且融合后是个列表, 如果数据量比较大, 那么会非常占用内存.</p>
<p>通过 <code>chain</code> 能完成多个可迭代对象的融合, 而且融合后是一个迭代器 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</div><div class="line">s = <span class="string">'abc'</span></div><div class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">t = (<span class="string">'q'</span>, <span class="string">'w'</span>, <span class="string">'e'</span>, <span class="string">'r'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> chain(s, l, t):</div><div class="line">    print(i, end=<span class="string">''</span>)</div></pre></td></tr></table></figure>
<pre><code>abc123qwer
</code></pre><h3 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h3><p><code>compress</code> 接收两个可迭代对象, 并通过第二个可迭代对象对第一个可迭代对象进行过滤 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> compress</div><div class="line">letters = <span class="string">'ABCDEFG'</span></div><div class="line">bools = [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">''</span>, <span class="keyword">True</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> compress(letters, bools):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>A
C
E
</code></pre><h3 id="dropwhile"><a href="#dropwhile" class="headerlink" title="dropwhile"></a>dropwhile</h3><p>从字面意思可以看出, 该迭代器是 : 一直丢弃, 直到 (不满足条件为止) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> dropwhile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dropwhile(<span class="keyword">lambda</span> x : x &lt; <span class="number">5</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>8
10
5
3
1
</code></pre><h3 id="takewhile"><a href="#takewhile" class="headerlink" title="takewhile"></a>takewhile</h3><p><code>takewhile</code> 与 <code>dropwhile</code> 相反 : 一直返回, 直到(满足条件为止) :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> takewhile</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> takewhile(<span class="keyword">lambda</span> x:x &lt; <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
2
1
</code></pre><h3 id="filterfalse"><a href="#filterfalse" class="headerlink" title="filterfalse"></a>filterfalse</h3><p><code>filterfalse</code> (Python2 是 ifilterfalse), 仅仅返回不满足条件的值 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> filterfalse</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> filterfalse(<span class="keyword">lambda</span> x : x&gt;<span class="number">3</span>, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
3
2
1
</code></pre><h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</div><div class="line">vehicles = [(<span class="string">'Ford'</span>, <span class="string">'Taurus'</span>), (<span class="string">'Dodge'</span>, <span class="string">'Durango'</span>), (<span class="string">'Chevrolet'</span>, <span class="string">'Cobalt'</span>),</div><div class="line">           (<span class="string">'Ford'</span>, <span class="string">'F150'</span>), (<span class="string">'Dodge'</span>, <span class="string">'Charger'</span>), (<span class="string">'Ford'</span>, <span class="string">'GT'</span>)]</div><div class="line"><span class="keyword">for</span> group_name, sub_group <span class="keyword">in</span> groupby(sorted(vehicles), <span class="keyword">lambda</span> group : group[<span class="number">0</span>]):</div><div class="line">    print(group_name)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> sub_group:</div><div class="line">        print(i)</div></pre></td></tr></table></figure>
<pre><code>Chevrolet
(&apos;Chevrolet&apos;, &apos;Cobalt&apos;)
Dodge
(&apos;Dodge&apos;, &apos;Charger&apos;)
(&apos;Dodge&apos;, &apos;Durango&apos;)
Ford
(&apos;Ford&apos;, &apos;F150&apos;)
(&apos;Ford&apos;, &apos;GT&apos;)
(&apos;Ford&apos;, &apos;Taurus&apos;)
</code></pre><p>在传入 <code>groupby</code> 之前, 一般先对数据进行排序, 使数据更加密集, 并且能让 <code>groupby</code> 正确的将元素聚集在一起.</p>
<p><code>groupby</code> 接收两个参数, 第一个是可迭代对象, 第二个是 keyfunc 函数. keyfunc 函数用来定义以什么为标准, 进行分组.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> key, sub_group <span class="keyword">in</span> groupby(<span class="string">'AaBbBaBCCC'</span>, <span class="keyword">lambda</span> x : x.upper()):</div><div class="line">    print(key, list(sub_group))</div></pre></td></tr></table></figure>
<pre><code>A [&apos;A&apos;, &apos;a&apos;]
B [&apos;B&apos;, &apos;b&apos;, &apos;B&apos;]
A [&apos;a&apos;]
B [&apos;B&apos;]
C [&apos;C&apos;, &apos;C&apos;, &apos;C&apos;]
</code></pre><p>当数据排序不够密集时, 就会出现上面数据分类不够紧凑的问题, 所以在分组前, 一般现对数据进行排序处理.</p>
<h3 id="starmap"><a href="#starmap" class="headerlink" title="starmap"></a>starmap</h3><p><code>starmap</code> 使用传入的函数和可迭代对象进行计算, 返回一个新的迭代器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> starmap</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> starmap(<span class="keyword">lambda</span> x,y: x+y, [[<span class="number">1</span>, <span class="number">2</span>], (<span class="number">3</span>, <span class="number">4</span>), [<span class="string">'a'</span>, <span class="string">'b'</span>]]):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>3
7
ab
</code></pre><p><code>starmap</code> 和 <code>map</code> 的区别在于, 传入的函数分别为 func(a, b) 和 func(*c)</p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</div><div class="line">data = <span class="string">'ABCDE'</span></div><div class="line">iter1, iter2 = tee(data)</div><div class="line">print(list(iter1))</div><div class="line">print(list(iter2))</div></pre></td></tr></table></figure>
<pre><code>[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> tee</div><div class="line">data = <span class="string">'ABCDE'</span></div><div class="line">iter1, iter2, iter3 = tee(data, <span class="number">3</span>)</div><div class="line">print(list(iter1))</div><div class="line">print(list(iter2))</div><div class="line">print(list(iter3))</div></pre></td></tr></table></figure>
<pre><code>[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]
</code></pre><p>相当于复制, 默认复制 2 个.</p>
<h3 id="zip-longest"><a href="#zip-longest" class="headerlink" title="zip_longest"></a>zip_longest</h3><p><code>zip_longest</code> (Python3 支持) 可以用来将两个可迭代对象打包在一起, 如果两个对象长度一部样, 可以传入 <code>fillvalue</code> :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> zip_longest</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip_longest(<span class="string">'abc'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], fillvalue=<span class="string">'哈'</span>):</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>(&apos;a&apos;, 1)
(&apos;b&apos;, 2)
(&apos;c&apos;, 3)
(&apos;哈&apos;, 4)
(&apos;哈&apos;, 5)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python 的内建模块 &lt;code&gt;itertools&lt;/code&gt; 提供了非常有用的用于操作可迭代对象的函数.&lt;br&gt;通过这些函数, 我们能更好更快的解决许多有关可迭代对象的问题.&lt;br&gt;对于这些函数, 大体分成三类来描述 :  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合产生器&lt;/li&gt;
&lt;li&gt;无限迭代器&lt;/li&gt;
&lt;li&gt;有限迭代器&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="文档" scheme="https://yuanblq.github.io/categories/%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>从输入url到显示页面发生了什么</title>
    <link href="https://yuanblq.github.io/2017/05/14/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>https://yuanblq.github.io/2017/05/14/从输入url到显示页面发生了什么/</id>
    <published>2017-05-14T09:59:04.000Z</published>
    <updated>2017-09-03T15:03:13.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong>当我们在浏览器的地址栏输入访问的 URL，然后回车，到浏览器显示对应的页面。这期间，到底发生了什么？</strong>  </p>
<p>以下，我大概按如这几部分来探索关于浏览器是怎么呈现出我们想要的页面：  </p>
<ul>
<li>输入 url</li>
<li>解析域名</li>
<li>建立连接</li>
<li>发起请求</li>
<li>响应请求</li>
<li>渲染页面</li>
<li>断开连接</li>
</ul>
<a id="more"></a>
<h2 id="输入-url"><a href="#输入-url" class="headerlink" title="输入 url"></a>输入 url</h2><p>在一个网络中，不同计算机拥有的 ip 地址都是唯一的。提供网页的服务器也是一台计算机，所以同样拥有唯一的一个 ip。  </p>
<p>比如百度的某一台服务器 ip 为 111.13.101.208，你完全可以通过 111.13.101.208:80 去访问百度的首页。但如果你还想访问腾讯、淘宝等其他网站呢？  </p>
<p>显然以 ip 方式去访问一个网站是很费劲的。就像我们说天安门在哪的时候不会说天安门在经纬多少多少度一样，而是以人话说在北京哪哪哪。  </p>
<p>所以，我们同样以别名的方式去记住每一个网站。而这就是 DNS 服务器干的活。  </p>
<p>我们在浏览器输入的是一个，人能够轻松记住的域名网址。当我们回车的时候 DNS 服务器就会去找该域名网址在网络中对应的 ip 地址，称之为解析域名。  </p>
<h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>一般来说，浏览器会先从本地的 hosts 文件中查找该域名对应的 ip 地址。  </p>
<p>没有的话再从网络运营商的 DNS 服务器中请求解析，如果没有就再以递归的方式往下不断请求 DNS 解析。找到之后，再一层层返回到你的电脑。  </p>
<h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>浏览器拿到 ip 地址之后，会以一个随机端口（1024-65535）向服务器 web 程序的 80/443 端口发起 TCP 连接请求，即所谓的三次握手，如下图所示：<br><img src="/2017/05/14/从输入url到显示页面发生了什么/三次握手.PNG" alt="PNG">  </p>
<h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><p>TCP 连接建立完成之后，浏览器就会向服务器发起 http request header 请求。  </p>
<p>一般为 GET 和 POST 两种请求。  </p>
<p>一个简单的 GET 请求的 request header 包含：</p>
<ul>
<li>请求行：HTTP/1.1 / GET</li>
<li>请求头：’User-Agent’: ‘Mozilla/5.0 (Windows NT 10.0; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0’, …</li>
<li>请求体：?key1=value1&amp;key2=value2…</li>
</ul>
<p>请求头和请求体的最后一行之间有两个 ‘\r\n’，用于告诉服务器没有其他请求头了。（POST 方式的请求信息一般不放在请求体，而是通过表单提交）  </p>
<h2 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h2><p>服务器接收到浏览器的请求之后，根据其响应内容会给浏览器相应的响应，服务器的 HTTP 响应同样也分为，响应行、响应头、响应体。  </p>
<h2 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h2><p>浏览器拿到服务器返回的响应数据后，根据其内容在把它渲染出来。</p>
<h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p>当我们在浏览器关闭正在访问的页面的时候，浏览器会发送断开连接的请求，及四次挥手过程，如下图所示：<br><img src="/2017/05/14/从输入url到显示页面发生了什么/四次挥手.PNG" alt="PNG">  </p>
<p>以上基本就是一个简单的从输入 url 到浏览器显示最终页面，期间所发生的一些事。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;当我们在浏览器的地址栏输入访问的 URL，然后回车，到浏览器显示对应的页面。这期间，到底发生了什么？&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;以下，我大概按如这几部分来探索关于浏览器是怎么呈现出我们想要的页面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入 url&lt;/li&gt;
&lt;li&gt;解析域名&lt;/li&gt;
&lt;li&gt;建立连接&lt;/li&gt;
&lt;li&gt;发起请求&lt;/li&gt;
&lt;li&gt;响应请求&lt;/li&gt;
&lt;li&gt;渲染页面&lt;/li&gt;
&lt;li&gt;断开连接&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
      <category term="网络" scheme="https://yuanblq.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>yield理解</title>
    <link href="https://yuanblq.github.io/2017/05/08/yield%E7%90%86%E8%A7%A3/"/>
    <id>https://yuanblq.github.io/2017/05/08/yield理解/</id>
    <published>2017-05-08T12:54:59.000Z</published>
    <updated>2017-09-03T14:58:37.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案"><a href="#这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案" class="headerlink" title="这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案"></a>这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案</h3><p>原文: <a href="http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained" target="_blank" rel="external">http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained</a></p>
<h4 id="提问者的问题"><a href="#提问者的问题" class="headerlink" title="提问者的问题"></a>提问者的问题</h4><p>Python 关键字 yield 的作用是什么? 用来干什么的?</p>
<p>比如, 我正在试图理解下面的代码 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></div><div class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</div><div class="line">        <span class="keyword">yield</span> self._leftchild</div><div class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</div><div class="line">        <span class="keyword">yield</span> self._rightchild</div></pre></td></tr></table></figure>
<p>下面的是调用 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">result, candidates = list(), [self]</div><div class="line"><span class="keyword">while</span> candidates:</div><div class="line">    node = candidates.pop()</div><div class="line">    distance = node._get_dist(obj)</div><div class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</div><div class="line">        result.extend(node._values)</div><div class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>当调用 _get_child_candidates 的时候发生了什么? 返回了一个列表? 返回了一个元素? 被重复调用了么? 什么时候这个调用结束呢?</p>
<a id="more"></a>
<h4 id="回答部分"><a href="#回答部分" class="headerlink" title="回答部分"></a>回答部分</h4><p>为了理解什么是 yield ,你必须理解什么是生成器. 在理解生成器之前, 让我们先走近迭代.</p>
<h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>当你建立了一个列表, 你可以逐项地读取这个列表, 这叫做一个可迭代对象 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>1
2
3
</code></pre><p>mylist 是一个可迭代对象. 当你使用一个列表生成式来建立一个列表的时候, 就建立了一个可迭代对象 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mylist = [x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>0
1
4
</code></pre><p>所有你可以使用 for .. in .. 语法的叫做一个迭代器 : 列表, 字符串, 文件 … 你经常使用它们是因为你可以如你所愿的读取其中的元素, 但是你把所有的值都存储到了内存中, 如果你有大量数据的话, 这个方式并不是你想要的.</p>
<h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>生成器是可以迭代的, 但是你 <strong><em>只可以读取它一次</em></strong> ,因为它并不把所有的值放在内存中, 它是实时地生成数据 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mygenerator = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>))</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>0
1
4
</code></pre><p>看起来除了把 [] 换成 () 外没什么不同. 但是, 你不可以再次使用 for i in mygenerator , 因为生成器只能被迭代一次 : 先计算出 0, 然后继续计算 1, 然后计算 4, 一个接一个的 …</p>
<h5 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h5><p>yield 是一个类似 rerun 的关键字, 只是这个函数返回的是一个生成器.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></div><div class="line">    mylist = range(<span class="number">3</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> mylist:</div><div class="line">        <span class="keyword">yield</span> i*i</div><div class="line"></div><div class="line">mygenerator = createGenerator()</div><div class="line">print(mygenerator)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mygenerator:</div><div class="line">    print(i)</div></pre></td></tr></table></figure>
<pre><code>&lt;generator object createGenerator at 0x00C189C0&gt;
0
1
4
</code></pre><p>这个例子没什么用途, 但是它让你知道, 这个函数会返回一大批你只需要读一次的值.</p>
<p>为了精通 yield ,你必须要理解 : <strong>当你调用这个函数的时候, 函数内部的代码并不立马执行</strong> , 这个函数只是返回一个生成器对象, 这有点蹊跷不是吗.</p>
<p>那么, 函数的代码什么时候执行呢? 当你使用 for 进行迭代的时候.</p>
<p>现在到了关键点了 !</p>
<p>第一次迭代中你的函数会执行, 从开始到达 yield 关键字, 然后返回 yield 后的值作为第一次迭代的返回值, 然后, 每次执行这个函数都会继续执行你在函数内部定义的那个循环的下一次, 再返回那个值, 直到没有可以返回的.</p>
<p>如果生成器内部没有定义 yield 关键字, 那么这个生成器被认为空的. 这种情况可能因为是循环进行没了, 或者是没有满足 if/else 条件.</p>
<h5 id="回到你的代码"><a href="#回到你的代码" class="headerlink" title="回到你的代码"></a>回到你的代码</h5><p>生成器 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建 node 对象的一个方法, 该方法返回一个生成器</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span>.<span class="title">_get_child_candidates</span><span class="params">(self, distance, min_dist, max_dist)</span>:</span></div><div class="line">    <span class="comment"># 如果 node 对象的左边仍然有 child</span></div><div class="line">    <span class="comment"># 并且距离合适, 则返回下一个 child</span></div><div class="line">    <span class="keyword">if</span> self._leftchild <span class="keyword">and</span> distance - max_dist &lt; self._median:</div><div class="line">        <span class="keyword">yield</span> self._leftchild</div><div class="line">    </div><div class="line">    <span class="comment"># 如果 node 对象的右边仍然有 child</span></div><div class="line">    <span class="comment"># 并且距离合适, 则返回下一个 child</span></div><div class="line">    <span class="keyword">if</span> self._rightchild <span class="keyword">and</span> distance + max_dist &gt;= self._median:</div><div class="line">        <span class="keyword">yield</span> self._rightchild</div><div class="line">        </div><div class="line">    <span class="comment"># 如果函数执行到这了, 则认为生成器已经空了</span></div><div class="line">    <span class="comment"># 不再有这两个值: leftchild, rightchild</span></div></pre></td></tr></table></figure>
<p>调用者 : </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个空列表, 和带有当前对象引用的列表</span></div><div class="line">result, candidates = list(), [self]</div><div class="line"></div><div class="line"><span class="comment"># candidates 的循环 (一开始他们只包含一个元素 --&gt; self)</span></div><div class="line"><span class="keyword">while</span> candidates:</div><div class="line">    </div><div class="line">    <span class="comment"># 获取最后一位 candidate , 并把它从列表中移除</span></div><div class="line">    node = candidates.pop()</div><div class="line">    </div><div class="line">    <span class="comment"># 获取 obj 和 candidate 之间的 distance</span></div><div class="line">    distance = node._get_dist(obj)</div><div class="line">    </div><div class="line">    <span class="comment"># 如果距离合适, 加入result</span></div><div class="line">    <span class="keyword">if</span> distance &lt;= max_dist <span class="keyword">and</span> distance &gt;= min_dist:</div><div class="line">        result.extend(node._values)</div><div class="line">        </div><div class="line">    <span class="comment"># 在 candidates 列表中添加 candidate 的 children</span></div><div class="line">    <span class="comment"># 这样, 循环就能持续执行, 直到它查遍 candidate 的所有 children</span></div><div class="line">    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</div><div class="line">    </div><div class="line"><span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>这个代码包含了几个小部分 :</p>
<ul>
<li>我们对一个列表进行迭代, 但是迭代中列表还在不断的扩展. 它是一个迭代这些嵌套的数据的简洁方式, 即使这样有点危险, 因为可能导致无限迭代.<br>  <code>candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))</code><br>  <strong>穷尽了生成器的所有制</strong>, 但 <code>while</code> 不断地在产生新的生成器, 他们会产生和上一次不一样的值, 但没有作用到同一个节点上.</li>
<li><code>extend()</code> 是一个迭代器方法, 作用于迭代器, 并把参数追加到迭代器的后面.</li>
</ul>
<p>通常我们传给它一个列表参数 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">b = [<span class="number">3</span>, <span class="number">4</span>]</div><div class="line">a.extend(b)</div><div class="line">print(a)</div></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4]
</code></pre><p>但是在你的代码中是一个生成器, 这是不错的, 因为 :</p>
<ul>
<li>你不必读两次所有的值.</li>
<li>你可以有很多子对象, 但不必叫他们都储存在内存里面.</li>
</ul>
<p>并且这很奏效, 因为 Python 不关心一个方法的参数是不是个列表. Python 只希望它是一个可以迭代的, 所以这个参数可以是列表, 元祖, 字符串, 生成器 … 这叫做 <code>duck typing</code>, 这也是为何 Python 如此棒的原因之一, 但这已经是另外一个问题了 … </p>
<p>你可以在这里停下, 来看看生成器的一些高级用法 : </p>
<font color="red">控制生成器的穷尽</font>


<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span><span class="params">()</span>:</span>   <span class="comment"># 让我们创建一个银行, 生成 ATM</span></div><div class="line">    crisis = <span class="keyword">False</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_atm</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.crisis:</div><div class="line">            <span class="keyword">yield</span> <span class="string">'$100'</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hsbc = Bank()</div><div class="line">corner_street_atm = hsbc.create_atm()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>$100
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>$100
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print([corner_street_atm.__next__() <span class="keyword">for</span> cash <span class="keyword">in</span> range(<span class="number">5</span>)])</div></pre></td></tr></table></figure>
<pre><code>[&apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;, &apos;$100&apos;]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hsbc.crisis = <span class="keyword">True</span> <span class="comment"># 经济危机来了, 没钱啦!</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-21-0291977c370d&gt; in &lt;module&gt;()
----&gt; 1 print(corner_street_atm.__next__())


StopIteration: 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wall_street_atm = hsbc.create_atm() <span class="comment"># 甚至新的 ATM 也有危机</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(wall_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-32-b42bcf449bd2&gt; in &lt;module&gt;()
----&gt; 1 print(wall_street_atm.__next__())


StopIteration: 
</code></pre><p><strong>糟糕的是, 危机走了, 但是 ATM 却依然没钱 …</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hsbc.crisis = <span class="keyword">False</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(corner_street_atm.__next__())</div></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

&lt;ipython-input-36-0291977c370d&gt; in &lt;module&gt;()
----&gt; 1 print(corner_street_atm.__next__())


StopIteration: 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brand_new_atm = hsbc.create_atm()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">7</span></div><div class="line"><span class="keyword">for</span> cash <span class="keyword">in</span> brand_new_atm:</div><div class="line">    i -= <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</div><div class="line">        print(cash)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure>
<pre><code>$100
$100
$100
$100
$100
$100
</code></pre><p>对于控制一些资源的访问来说, 这很有用.</p>
<font color="red">Itertools, 你最好的朋友</font>

<p>itertools 包含了很多特殊的迭代方法. 是不是曾想过复制一个迭代器? 串联两个迭代器? 把嵌套的列表分组? 不用创造一个新的列表的 <code>zip/map</code> ?</p>
<p>只要 <code>import itertools</code></p>
<p>需要个例子? 让我们看看比赛中 4 匹马可能到达终点的先后顺序的可能情况 :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> itertools</div><div class="line"></div><div class="line">horses = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line">races = itertools.permutations(horses)</div><div class="line">print(races)</div></pre></td></tr></table></figure>
<pre><code>&lt;itertools.permutations object at 0x012B9DB0&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(list(races))</div></pre></td></tr></table></figure>
<pre><code>[(1, 2, 3, 4), (1, 2, 4, 3), (1, 3, 2, 4), (1, 3, 4, 2), (1, 4, 2, 3), (1, 4, 3, 2), (2, 1, 3, 4), (2, 1, 4, 3), (2, 3, 1, 4), (2, 3, 4, 1), (2, 4, 1, 3), (2, 4, 3, 1), (3, 1, 2, 4), (3, 1, 4, 2), (3, 2, 1, 4), (3, 2, 4, 1), (3, 4, 1, 2), (3, 4, 2, 1), (4, 1, 2, 3), (4, 1, 3, 2), (4, 2, 1, 3), (4, 2, 3, 1), (4, 3, 1, 2), (4, 3, 2, 1)]
</code></pre><font color="red">了解迭代器的内部机理</font>

<p>迭代是一个实现可迭代对象(实现的是 <code>__iter__()</code> )和迭代器(实现的是 <code>__next__()</code> )的过程. 可迭代对象是你可以从其获取到一个迭代器的任一对象. 迭代器是那些允许你迭代可迭代对象的对象.</p>
<p>更多见这个文章 <a href="http://effbot.org/zone/python-for-statement.htm" target="_blank" rel="external">http://effbot.org/zone/python-for-statement.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案&quot;&gt;&lt;a href=&quot;#这是-StackOverflow-上的一个很热的帖子-这里是投票最高的一个答案&quot; class=&quot;headerlink&quot; title=&quot;这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案&quot;&gt;&lt;/a&gt;这是 StackOverflow 上的一个很热的帖子, 这里是投票最高的一个答案&lt;/h3&gt;&lt;p&gt;原文: &lt;a href=&quot;http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained&quot;&gt;http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;提问者的问题&quot;&gt;&lt;a href=&quot;#提问者的问题&quot; class=&quot;headerlink&quot; title=&quot;提问者的问题&quot;&gt;&lt;/a&gt;提问者的问题&lt;/h4&gt;&lt;p&gt;Python 关键字 yield 的作用是什么? 用来干什么的?&lt;/p&gt;
&lt;p&gt;比如, 我正在试图理解下面的代码 :&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;node&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;_get_child_candidates&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, distance, min_dist, max_dist)&lt;/span&gt;:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self._leftchild &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance - max_dist &amp;lt; self._median:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; self._leftchild&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self._rightchild &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance + max_dist &amp;gt;= self._median:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; self._rightchild&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面的是调用 :&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;result, candidates = list(), [self]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; candidates:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    node = candidates.pop()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    distance = node._get_dist(obj)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; distance &amp;lt;= max_dist &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; distance &amp;gt;= min_dist:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        result.extend(node._values)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当调用 _get_child_candidates 的时候发生了什么? 返回了一个列表? 返回了一个元素? 被重复调用了么? 什么时候这个调用结束呢?&lt;/p&gt;
    
    </summary>
    
      <category term="知识点" scheme="https://yuanblq.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Python" scheme="https://yuanblq.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
